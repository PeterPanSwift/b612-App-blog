<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>成功和失敗二擇一的 Result type</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">成功和失敗二擇一的 Result type</h1>
</header>
<section data-field="subtitle" class="p-summary">
Swift 裡有個很特別的型別叫 Result，就像它名字 result(結果)暗示的，它可以告訴我們結果。而結果也跟我們生活中大部分的事一樣，只有兩種可能，成功或失敗。就像彼得潘會不會跟 IU 在一起，只有成功或失敗兩種結果，不會有第三種可能。
</section>
<section data-field="body" class="e-content">
<section name="f142" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a755" id="a755" class="graf graf--h3 graf--leading graf--title">成功和失敗二擇一的 Result type</h3><figure name="d7aa" id="d7aa" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*U8AOGxBMfdD8VkKKpureyQ.jpeg" data-width="1240" data-height="816" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*U8AOGxBMfdD8VkKKpureyQ.jpeg"></figure><p name="04be" id="04be" class="graf graf--p graf-after--figure">Swift 裡有個很特別的型別叫 Result，就像它名字 result(結果)暗示的，它可以告訴我們結果。而結果也跟我們生活中大部分的事一樣，只有兩種可能，成功或失敗。就像彼得潘會不會跟 IU 在一起，只有成功或失敗兩種結果，不會有第三種可能。</p><h3 name="71e6" id="71e6" class="graf graf--h3 graf-after--p">Result type 的定義</h3><p name="6c27" id="6c27" class="graf graf--p graf-after--h3">只有兩種結果的 Result 型別其實是以 enum 定義的，它的宣告如下，case <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">success</strong></code> 代表成功，case <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">failure</strong></code> 代表失敗，另外它還以 associated value 儲存成功和失敗的相關資料，以 generic 宣告資料的型別 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Success</strong></code> &amp; <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Failure</strong></code>。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1606" id="1606" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Success</span>, <span class="hljs-title class_">Failure</span>&gt; <span class="hljs-title class_">where</span> <span class="hljs-title class_">Failure</span> : <span class="hljs-title class_">Error</span> {<br />    <span class="hljs-comment">/// A success, storing a `Success` value.</span><br />    <span class="hljs-keyword">case</span> success(<span class="hljs-type">Success</span>)<br />    <span class="hljs-comment">/// A failure, storing a `Failure` value.</span><br />    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">Failure</span>)</span></pre><div name="1bc2" id="1bc2" class="graf graf--mixtapeEmbed graf-after--pre"><a href="https://developer.apple.com/documentation/swift/result" data-href="https://developer.apple.com/documentation/swift/result" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/result"><strong class="markup--strong markup--mixtapeEmbed-strong">Result | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">A value that represents either a success or a failure, including an associated value in each case.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/result" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="977647b9e8eda02cbd09da17930ac4f2" data-thumbnail-img-id="0*S0rYCEKvAdcOBCUs" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*S0rYCEKvAdcOBCUs);"></a></div><div name="b750" id="b750" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/enum-%E5%84%B2%E5%AD%98%E7%9B%B8%E9%97%9C%E8%81%AF%E8%B3%87%E6%96%99%E7%9A%84-associated-value-26ab3e061a16" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/enum-%E5%84%B2%E5%AD%98%E7%9B%B8%E9%97%9C%E8%81%AF%E8%B3%87%E6%96%99%E7%9A%84-associated-value-26ab3e061a16" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/enum-%E5%84%B2%E5%AD%98%E7%9B%B8%E9%97%9C%E8%81%AF%E8%B3%87%E6%96%99%E7%9A%84-associated-value-26ab3e061a16"><strong class="markup--strong markup--mixtapeEmbed-strong">enum 儲存相關聯資料的 associated value</strong><br><em class="markup--em markup--mixtapeEmbed-em">Swift 的 enum 有個特別的 associated value 語法，它將讓 enum 的 case 具有儲存相關聯資料的特異功能。接下來讓我們透過實際的例子好好認識它吧。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/enum-%E5%84%B2%E5%AD%98%E7%9B%B8%E9%97%9C%E8%81%AF%E8%B3%87%E6%96%99%E7%9A%84-associated-value-26ab3e061a16" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="0efebdc54d2da8727e0ddceb42e8b5c2" data-thumbnail-img-id="1*Sm5CHxdh5AEA7LM6aoEYaw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*Sm5CHxdh5AEA7LM6aoEYaw.jpeg);"></a></div><h3 name="92ee" id="92ee" class="graf graf--h3 graf-after--mixtapeEmbed">Result type 的好處和解決的問題</h3><p name="91be" id="91be" class="graf graf--p graf-after--h3">不過到底 Result type 有什麼好處，什麼時候適合使用 Result type 呢 ? 讓我們先看看以下的例子。</p><p name="f06c" id="f06c" class="graf graf--p graf-after--p">開發 iOS App 時，我們時常會定義做某件事的 function，想要它成功時回傳結果，失敗時以 throw 丟出錯誤。比方以下例子我們定義檢查密碼回傳答案的 function getAnswer，當密碼有問題時丟出錯誤。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3a50" id="3a50" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PasswordError</span>: <span class="hljs-title class_">Error</span> {<br />    <span class="hljs-keyword">case</span> wrongPassword<br />    <span class="hljs-keyword">case</span> emptyPassword<br />}<br /><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">getAnswer</span>(<span class="hljs-params">password</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">String</span> {<br />    <span class="hljs-keyword">guard</span> password.isEmpty <span class="hljs-operator">==</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">else</span> {<br />        <span class="hljs-keyword">throw</span> <span class="hljs-type">PasswordError</span>.emptyPassword<br />    }<br />    <span class="hljs-keyword">guard</span> password <span class="hljs-operator">==</span> <span class="hljs-string">&quot;deeplove&quot;</span> <span class="hljs-keyword">else</span> {<br />        <span class="hljs-keyword">throw</span> <span class="hljs-type">PasswordError</span>.wrongPassword<br />    }<br />    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;只有用心看才看得清楚，重要的東西是眼睛看不見的&quot;</span><br />}<br /><br /><span class="hljs-keyword">do</span> {<br />    <span class="hljs-keyword">let</span> answer <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> getAnswer(password: <span class="hljs-string">&quot;deeplove&quot;</span>)<br />    <span class="hljs-built_in">print</span>(answer)<br />} <span class="hljs-keyword">catch</span> <span class="hljs-type">PasswordError</span>.wrongPassword {<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;wrongPassword&quot;</span>)<br />} <span class="hljs-keyword">catch</span> <span class="hljs-type">PasswordError</span>.emptyPassword {<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;emptyPassword&quot;</span>)<br />} <span class="hljs-keyword">catch</span> {<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;other error&quot;</span>)<br />}</span></pre><p name="b219" id="b219" class="graf graf--p graf-after--pre">然而當 function 裡使用到非同步的程式時，我們並不能用 throw 丟出錯誤。以下程式我們呼叫非同步的 function dataTask(with:completionHandler:)，在 completionHandler 的 closure throw 錯誤將造成問題。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="49a9" id="49a9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">NetworkError</span>: <span class="hljs-title class_">Error</span> {<br />    <span class="hljs-keyword">case</span> invalidUrl<br />    <span class="hljs-keyword">case</span> requestFailed<br />}<br /><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">downloadImage</span>(<span class="hljs-params">urlString</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">throws</span> {<br />    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) <span class="hljs-keyword">else</span> {<br />        <span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.invalidUrl<br />    }<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error {<br />            <span class="hljs-keyword">throw</span> <span class="hljs-type">NetworkError</span>.requestFailed<br />        }<br />    }.resume()<br />}</span></pre><p name="ab6b" id="ab6b" class="graf graf--p graf-after--pre">因為 completionHandler 的型別是 <code class="markup--code markup--p-code">(Data?, URLResponse?, Error?) -&gt; Void</code>，沒有寫到 throws，所以我們不能在 closure 裡丟出錯誤。</p><figure name="1913" id="1913" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2PvUvib2HiOQ17dfW0YRfA.jpeg" data-width="1966" data-height="296" src="https://cdn-images-1.medium.com/max/800/1*2PvUvib2HiOQ17dfW0YRfA.jpeg"></figure><p name="813c" id="813c" class="graf graf--p graf-after--figure">此時正是 Result type 登場的時候，它具有以下幾點好處:</p><ul class="postList"><li name="3d2a" id="3d2a" class="graf graf--li graf-after--p">可回傳非同步程式產生的錯誤。</li><li name="53e4" id="53e4" class="graf graf--li graf-after--li">讓程式的可讀性更好和更容易維護。</li></ul><p name="3575" id="3575" class="graf graf--p graf-after--li">原本使用 URLSession 抓資料時，它的程式其實有些缺點，讓我們先看看以下傳統 URLSession 抓資料的寫法。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="36f5" id="36f5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">NetworkError</span>: <span class="hljs-title class_">Error</span> {<br />    <span class="hljs-keyword">case</span> invalidUrl<br />    <span class="hljs-keyword">case</span> requestFailed(<span class="hljs-type">Error</span>)<br />    <span class="hljs-keyword">case</span> invalidData<br />    <span class="hljs-keyword">case</span> invalidResponse<br />}<br /><br /><span class="hljs-keyword">func</span> <span class="hljs-title function_">downloadImage</span>(<span class="hljs-params">urlString</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">UIImage</span>?, <span class="hljs-type">NetworkError</span>?) -&gt; <span class="hljs-type">Void</span>) {<br />    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) <span class="hljs-keyword">else</span> {<br />        completion(<span class="hljs-literal">nil</span>, .invalidUrl)<br />        <span class="hljs-keyword">return</span><br />    }<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error {<br />            completion(<span class="hljs-literal">nil</span>, .requestFailed(error))<br />            <span class="hljs-keyword">return</span><br />        }<br />        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> httpResponse <span class="hljs-operator">=</span> response <span class="hljs-keyword">as?</span> <span class="hljs-type">HTTPURLResponse</span>, httpResponse.statusCode <span class="hljs-operator">==</span> <span class="hljs-number">200</span> <span class="hljs-keyword">else</span> {<br />            completion(<span class="hljs-literal">nil</span>, .invalidResponse)<br />            <span class="hljs-keyword">return</span><br />        }<br />        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> data, <br />              <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) <span class="hljs-keyword">else</span> {<br />            completion(<span class="hljs-literal">nil</span>, .invalidData)<br />            <span class="hljs-keyword">return</span><br />        }<br />        completion(image, <span class="hljs-literal">nil</span>)<br />    }.resume()<br />}</span></pre><p name="0fac" id="0fac" class="graf graf--p graf-after--pre">因為 dataTask(with:completionHandler:) 的參數 completionHandler 的型別是 <code class="markup--code markup--p-code">(Data?, URLResponse?, Error?) -&gt; Void</code>，( ) 裡的三個參數都是 optional，所以我們要辛苦地從 optional 取值，判斷是否有 data 和 error。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f316" id="f316" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">downloadImage(urlString: <span class="hljs-string">&quot;https://images-na.ssl-images-amazon.com/images/I/61Zi2jjgfIL.jpg&quot;</span>) { image, error <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> image {<br />        <span class="hljs-built_in">print</span>(image)<br />    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error {<br />        <span class="hljs-built_in">print</span>(error)<br />    }<br />}</span></pre><p name="db54" id="db54" class="graf graf--p graf-after--pre">然後在呼叫 downloadImage(urlString:completion:) 時參數 completion 的型別是 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">(UIImage?, NetworkError?) -&gt; Void</strong></code>，也是 optional，因此我們又要再辛苦地從 optional 取值，判斷是否有圖片和 error。</p><p name="004a" id="004a" class="graf graf--p graf-after--p">此外 downloadImage(urlString:completion:) 的設計其實不太好，因為 completion 裡要嘛有圖片，要嘛有錯誤，不會兩者都有，也不會兩者皆無，但型別 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">(UIImage?, NetworkError?) -&gt; Void</strong></code> 卻代表依據小時候我們數學考試考 100 的排列組合，它會有四種可能，但其實只會有兩種可能。(就好像彼得潘能否追到 IU，有兩種結果，但其實只會有一種結果。)</p><figure name="01e4" id="01e4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XeCrXX3Pf4eh25enHJh8uw.jpeg" data-width="758" data-height="740" src="https://cdn-images-1.medium.com/max/800/1*XeCrXX3Pf4eh25enHJh8uw.jpeg"></figure><p name="0f3f" id="0f3f" class="graf graf--p graf-after--figure">剛剛提到的這些問題，都可以透過 Result type 解決，接下來讓我們請 Result type 救救我們。</p><h3 name="de8e" id="de8e" class="graf graf--h3 graf-after--p">Result type 的應用，以 URLSession 為例</h3><p name="fb22" id="fb22" class="graf graf--p graf-after--h3">我們將 downloadImage 抓取圖片的結果改以 Result 型別回傳，將型別宣告為 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">Result&lt;UIImage, NetworkError&gt;</strong></code>。此時程式變得更清楚了，抓圖的結果只有兩種可能，成功時回傳 Result 的 success case，在裡面包含 UIImage 。失敗時則回傳 Result 的 failure case，在裡面包含 NetworkError<strong class="markup--strong markup--p-strong">。</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="613d" id="613d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">downloadImage</span>(<span class="hljs-params">urlString</span>: <span class="hljs-type">String</span>, <span class="hljs-params">completion</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">UIImage</span>, <span class="hljs-type">NetworkError</span>&gt;) -&gt; <span class="hljs-type">Void</span>) {<br />    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) <span class="hljs-keyword">else</span> {<br />        completion(.failure(.invalidUrl))<br />        <span class="hljs-keyword">return</span><br />    }<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error {<br />            completion(.failure(.requestFailed(error)))<br />            <span class="hljs-keyword">return</span><br />        }<br />        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> httpResponse <span class="hljs-operator">=</span> response <span class="hljs-keyword">as?</span> <span class="hljs-type">HTTPURLResponse</span>, httpResponse.statusCode <span class="hljs-operator">==</span> <span class="hljs-number">200</span> <span class="hljs-keyword">else</span> {<br />            completion(.failure(.invalidResponse))<br />            <span class="hljs-keyword">return</span><br />        }<br />        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> data, <br />              <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) <span class="hljs-keyword">else</span> {<br />            completion(.failure(.invalidData))<br />            <span class="hljs-keyword">return</span><br />        }<br />        completion(.success(image))<br />    }.resume()<br />}</span></pre><p name="d53d" id="d53d" class="graf graf--p graf-after--pre">呼叫 downloadImage 的範例如下，此時我們不用再為讀取 optional 煩心，而且可用 switch 清楚描述成功和失敗時要做的事情。swtich 還能幫我們檢查是否有處理各種 case，減少程式出錯的機率。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f3f0" id="f3f0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">downloadImage(urlString: <span class="hljs-string">&quot;https://images-na.ssl-images-amazon.com/images/I/61Zi2jjgfIL.jpg&quot;</span>) { result <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">switch</span> result {<br />    <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> image):<br />        <span class="hljs-built_in">print</span>(image)<br />    <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> networkError):<br />        <span class="hljs-keyword">switch</span> networkError {<br />        <span class="hljs-keyword">case</span> .invalidUrl:<br />            <span class="hljs-built_in">print</span>(networkError)<br />        <span class="hljs-keyword">case</span> .requestFailed(<span class="hljs-keyword">let</span> error):<br />            <span class="hljs-built_in">print</span>(networkError, error)<br />        <span class="hljs-keyword">case</span> .invalidData:<br />            <span class="hljs-built_in">print</span>(networkError)<br />        <span class="hljs-keyword">case</span> .invalidResponse:<br />            <span class="hljs-built_in">print</span>(networkError)<br />        }<br />    }<br />}</span></pre><h3 name="69fe" id="69fe" class="graf graf--h3 graf-after--pre">Result type 的其它例子: Alamofire</h3><p name="4926" id="4926" class="graf graf--p graf-after--h3">知名的網路套件 Alamofire 也使用到 Result type，例如以下例子:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="5840" id="5840" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">AF</span>.request(<span class="hljs-string">&quot;https://httpbin.org/get&quot;</span>)<br />    .validate(statusCode: <span class="hljs-number">200</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">300</span>)<br />    .validate(contentType: [<span class="hljs-string">&quot;application/json&quot;</span>])<br />    .responseData { response <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">switch</span> response.result {<br />        <span class="hljs-keyword">case</span> .success:<br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Validation Successful&quot;</span>)<br />        <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .failure(error):<br />            <span class="hljs-built_in">print</span>(error)<br />        }<br />    }</span></pre><div name="f7f2" id="f7f2" class="graf graf--mixtapeEmbed graf-after--pre"><a href="https://github.com/Alamofire/Alamofire/blob/master/Documentation/Usage.md#making-requests" data-href="https://github.com/Alamofire/Alamofire/blob/master/Documentation/Usage.md#making-requests" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/Alamofire/Alamofire/blob/master/Documentation/Usage.md#making-requests"><strong class="markup--strong markup--mixtapeEmbed-strong">Alamofire/Alamofire</strong><br><em class="markup--em markup--mixtapeEmbed-em">Alamofire provides an elegant and composable interface to HTTP network requests. It does not implement its own HTTP…</em>github.com</a><a href="https://github.com/Alamofire/Alamofire/blob/master/Documentation/Usage.md#making-requests" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="06f43abab6fd74d4666d306f6c578edf" data-thumbnail-img-id="0*Rind0UudilxiM0fC" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Rind0UudilxiM0fC);"></a></div><h3 name="5948" id="5948" class="graf graf--h3 graf-after--mixtapeEmbed"><strong class="markup--strong markup--h3-strong">利用 extension 讓 URLSession 回傳 Result</strong></h3><p name="50c4" id="50c4" class="graf graf--p graf-after--h3">若想讓 URLSession 的程式變得更清楚，不想重覆寫判斷是否有 data 和 error 的程式，可參考以下 Sundell 大大的範例，利用 extension 定義回傳 Result 型別資料的 function dataTask(with:handler:)。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b627" id="b627" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">dataTask</span>(<span class="hljs-params">with</span> <span class="hljs-params">url</span>: <span class="hljs-type">URL</span>, <span class="hljs-params">handler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Data</span>, <span class="hljs-type">Error</span>&gt;) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">URLSessionDataTask</span></span></pre><div name="de7b" id="de7b" class="graf graf--mixtapeEmbed graf-after--pre"><a href="https://www.swiftbysundell.com/basics/result/" data-href="https://www.swiftbysundell.com/basics/result/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.swiftbysundell.com/basics/result/"><strong class="markup--strong markup--mixtapeEmbed-strong">The Result Type | Swift by Sundell</strong><br><em class="markup--em markup--mixtapeEmbed-em">The Swift standard library&#39;s Result type enables us to express the outcome of a given operation - whether it succeeded…</em>www.swiftbysundell.com</a><a href="https://www.swiftbysundell.com/basics/result/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="73bf561ca7193810e3644b59eedfb4d1" data-thumbnail-img-id="0*6wnyqI3IO7xq07cD" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*6wnyqI3IO7xq07cD);"></a></div><h3 name="208d" id="208d" class="graf graf--h3 graf-after--mixtapeEmbed">其它參考資料</h3><div name="d6d2" id="d6d2" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://developer.apple.com/documentation/swift/writing-failable-asynchronous-apis" data-href="https://developer.apple.com/documentation/swift/writing-failable-asynchronous-apis" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/writing-failable-asynchronous-apis"><strong class="markup--strong markup--mixtapeEmbed-strong">Writing Failable Asynchronous APIs | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Vend results as part of an API when you can&#39;t return errors synchronously.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/writing-failable-asynchronous-apis" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a6867e787832b4753ab1cc99adae0ee0" data-thumbnail-img-id="0*j1YQJ06phSgOHeAn" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*j1YQJ06phSgOHeAn);"></a></div><div name="e78d" id="e78d" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-swifts-result-type" data-href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-swifts-result-type" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.hackingwithswift.com/books/ios-swiftui/understanding-swifts-result-type"><strong class="markup--strong markup--mixtapeEmbed-strong">Understanding Swift&#39;s Result type</strong><br><em class="markup--em markup--mixtapeEmbed-em">Paul Hudson @twostraws It is common to want a function to return some data if it was successful, or return an error if…</em>www.hackingwithswift.com</a><a href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-swifts-result-type" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="40013ac8b5b02f9fb62e7bb5bb0da71d" data-thumbnail-img-id="0*MCGxKaFpFH4EmxCb" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*MCGxKaFpFH4EmxCb);"></a></div><figure name="7f1a" id="7f1a" class="graf graf--figure graf--iframe graf-after--mixtapeEmbed graf--trailing"><iframe src="https://www.youtube.com/embed/XbozdoXWWr0?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">沒有輸，那應該是 Result type 的 success 吧</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/e234c6fccc9c"><time class="dt-published" datetime="2020-04-06T09:31:01.450Z">April 6, 2020</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E6%88%90%E5%8A%9F%E5%92%8C%E5%A4%B1%E6%95%97%E4%BA%8C%E6%93%87%E4%B8%80%E7%9A%84-result-type-e234c6fccc9c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>