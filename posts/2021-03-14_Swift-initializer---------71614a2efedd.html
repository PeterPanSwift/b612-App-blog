<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift initializer 的屬性初始規則</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift initializer 的屬性初始規則</h1>
</header>
<section data-field="subtitle" class="p-summary">
當物件建立時，將透過 initializer 進行相關的初始動作，確保物件所有的 stored property 都完成初始。然而物件的屬性除了在自己的類別裡宣告外，也可能從父類別繼承。為了保證程式的安全性，確保屬性已正確初始後才使用，Swift 訂定 2…
</section>
<section data-field="body" class="e-content">
<section name="6503" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7f89" id="7f89" class="graf graf--h3 graf--leading graf--title">Swift <strong class="markup--strong markup--h3-strong">initializer 的</strong>屬性初始規則</h3><p name="a4f2" id="a4f2" class="graf graf--p graf-after--h3">當物件建立時，將透過 initializer 進行相關的初始動作，確保物件所有的 stored property 都完成初始。然而物件的屬性除了在自己的類別裡宣告外，也可能從父類別繼承。為了保證程式的安全性，確保屬性已正確初始後才使用，Swift 訂定 2 個一定要遵守的原則，所有的機制，所有的檢查都以此原則為中心思想。</p><ul class="postList"><li name="9562" id="9562" class="graf graf--li graf-after--p">原則一: 屬性的初始，必須在當初宣告屬性的類別裡進行。</li><li name="ec8e" id="ec8e" class="graf graf--li graf-after--li">原則二: 子類別得先完成自己屬性的初始後，才能進行父類別屬性的初始。</li></ul><p name="8694" id="8694" class="graf graf--p graf-after--li">讓我們看看以下的例子。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3fec" id="3fec" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span><br />    <br />    <span class="hljs-keyword">init</span>() {<br />        age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br />    }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperBaby</span>: <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> magic: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">magic</span>: <span class="hljs-type">String</span>) {<br />        <span class="hljs-keyword">self</span>.magic <span class="hljs-operator">=</span> magic<br />        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br />    }<br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby <span class="hljs-operator">=</span> <span class="hljs-type">SuperBaby</span>(magic: <span class="hljs-string">&quot;速速前&quot;</span>)</span></pre><p name="f58b" id="f58b" class="graf graf--p graf-after--pre">從繼承自 Baby 的 SuperBaby，我們觀察到以下屬性初始的現象:</p><ul class="postList"><li name="6672" id="6672" class="graf graf--li graf-after--p">magic 在 SuperBaby 的 initializer 初始，age 在 Baby 的 initializer 初始。符合原則一<code class="markup--code markup--li-code">屬性的初始，必須在當初宣告屬性的類別裡進行</code>。</li><li name="ae53" id="ae53" class="graf graf--li graf-after--li">magic 初始後，才利用 super.init( ) 呼叫父類別的 initializer 初始 age。符合原則二<code class="markup--code markup--li-code">子類別得先完成自己屬性的初始後，才能進行父類別屬性的初始</code>。</li></ul><p name="4246" id="4246" class="graf graf--p graf-after--li">若違反原則，Xcode 將毫不留情地產生紅色錯誤! 例如以下例子:</p><ul class="postList"><li name="2d0a" id="2d0a" class="graf graf--li graf-after--p">在子類別 SuperBaby 初始父類別 Baby 宣告的 age，違反原則一，錯誤訊息顯示 <code class="markup--code markup--li-code">&#39;self&#39; used in property access &#39;age&#39; before &#39;super.init&#39; call</code>。</li></ul><figure name="2266" id="2266" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*1igBGUQgV_3d9P0WGgp_jg.png" data-width="1536" data-height="446" src="https://cdn-images-1.medium.com/max/800/1*1igBGUQgV_3d9P0WGgp_jg.png"></figure><ul class="postList"><li name="236d" id="236d" class="graf graf--li graf-after--figure">先呼叫 super.init( ) 初始父類別的 age，然後才初始子類別的 magic，違反原則二，錯誤訊息顯示 <code class="markup--code markup--li-code">Property &#39;self.magic&#39; not initialized at super.init call</code>。</li></ul><figure name="99ec" id="99ec" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*RvKnbrfyHpRDrWJ2Fkv9ow.png" data-width="1536" data-height="422" src="https://cdn-images-1.medium.com/max/800/1*RvKnbrfyHpRDrWJ2Fkv9ow.png"></figure><p name="6a76" id="6a76" class="graf graf--p graf-after--figure">也許有人好奇為何先呼叫 super.init( ) 會被禁止，所謂不見棺材不掉淚，讓我們以底下的例子說明吧。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="5628" id="5628" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span><br />    <br />    <span class="hljs-keyword">init</span>() {<br />        age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br />        sing()<br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">sing</span>() {<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;為愛往前飛&quot;</span>)<br />    }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperBaby</span>: <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> magic: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">magic</span>: <span class="hljs-type">String</span>) {<br />        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br />        <span class="hljs-keyword">self</span>.magic <span class="hljs-operator">=</span> magic<br />    }<br />    <br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">sing</span>() {<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;搭配咒語<span class="hljs-subst">\(magic)</span>歌唱&quot;</span>)<br />    }<br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby <span class="hljs-operator">=</span> <span class="hljs-type">SuperBaby</span>(magic: <span class="hljs-string">&quot;速速前&quot;</span>)</span></pre><p name="ffdf" id="ffdf" class="graf graf--p graf-after--pre">當 SuperBaby 先呼叫父類別的 init 再初始自己的 magic 屬性時，由於父類別 Baby 的 init 裡呼叫 function sing，而 SuperBaby 又覆寫 sing，於其中存取 magic 屬性， 所以到時候呼叫的 sing 將是 SuperBaby 定義的 sing。</p><p name="23fb" id="23fb" class="graf graf--p graf-after--p">此時將造成一發不可收拾的可怕後果，存取 magic 屬性時它還未被初始! 因此，子類別得先完成自己屬性的初始後，才能進行父類別屬性的初始。</p><p name="e37b" id="e37b" class="graf graf--p graf-after--p">以剛剛介紹的兩個原則為中心思想，當一個物件建立時，初始的過程可分為兩個階段。</p><figure name="832d" id="832d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cYzQx0H9X6vC-mQHqw0mYA.png" data-width="1414" data-height="766" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*cYzQx0H9X6vC-mQHqw0mYA.png"></figure><ul class="postList"><li name="ce38" id="ce38" class="graf graf--li graf-after--figure">階段一: 由下而上，從子類別的 initializer，一路往上進行每個父類別的 initializer。 過程裡一定得先將自己的屬性初始後，才能呼叫父類別的 initializer。當階段一完成時，物件的所有屬性皆已完成初始。</li><li name="c854" id="c854" class="graf graf--li graf-after--li">階段二:階段一其實是一連串呼叫 initializer 的過程。由於 initializer 就像 function， 所以當 initializer 執行完，將返回當初呼叫它的程式，繼續執行下一行，形成所謂的階段二，由上而下，從父類別的 initializer，一路往下返回進行每個子類別的 initializer。在階段二，由於物件的所有屬性皆已完成初始，所以此時可放心對屬性做任何存取，或者呼叫其它的方法。</li></ul><p name="1ef6" id="1ef6" class="graf graf--p graf-after--li">接下來，讓我們以實際的例子，看看物件建立時兩階段的初始過程。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7bd2" id="7bd2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span><br />    <br />    <span class="hljs-keyword">init</span>() {<br />        age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br />        sing()<br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">sing</span>() {<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;為愛往前飛&quot;</span>)<br />    }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperBaby</span>: <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> magic: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">magic</span>: <span class="hljs-type">String</span>) {<br />        <span class="hljs-keyword">self</span>.magic <span class="hljs-operator">=</span> magic<br />        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br />        age <span class="hljs-operator">=</span> <span class="hljs-number">1000</span><br />        sing()<br />    }<br />    <br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">sing</span>() {<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(age)</span>歲的寶寶搭配咒語<span class="hljs-subst">\(magic)</span>歌唱&quot;</span>)<br />    }<br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby <span class="hljs-operator">=</span> <span class="hljs-type">SuperBaby</span>(magic: <span class="hljs-string">&quot;速速前&quot;</span>)</span></pre><p name="2ae5" id="2ae5" class="graf graf--p graf-after--pre">結果</p><pre name="0689" id="0689" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">18歲的寶寶搭配咒語速速前歌唱</strong></pre><pre name="7b20" id="7b20" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">1000歲的寶寶搭配咒語速速前歌唱</strong></pre><p name="b964" id="b964" class="graf graf--p graf-after--pre graf--trailing">在階段一的過程，SuperBaby 和 Baby 的 init 依序被呼叫，magic 和 age 依序設為速速前和 18。當 <code class="markup--code markup--p-code">age = 18</code> 執行完，階段一完成時，物件的屬性都已初始，因此接下來階段二的過程裡，我們可以放心存取屬性和呼叫方法。當 Baby 的 init 呼叫 sing 時，age 是 18，因此印出<code class="markup--code markup--p-code">18歲的寶寶搭配咒語速速前歌唱</code>。接著 SuperBaby 的 init 將 age 改成 1000，然後再呼叫 sing，因此印出<code class="markup--code markup--p-code">1000歲的寶寶搭配咒語速速前歌唱</code>。 以上例子也說明了子類別想客製繼承的屬性內容，必須耐心等到階段二才能進行。</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/71614a2efedd"><time class="dt-published" datetime="2021-03-14T15:18:46.595Z">March 14, 2021</time></a>.</p><p><a href="https://medium.com/@apppeterpan/swift-initializer-%E7%9A%84%E5%B1%AC%E6%80%A7%E5%88%9D%E5%A7%8B%E6%AD%B8-71614a2efedd" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>