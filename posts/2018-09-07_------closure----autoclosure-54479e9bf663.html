<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>把參數變成 closure 的 @autoclosure</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">把參數變成 closure 的 @autoclosure</h1>
</header>
<section data-field="subtitle" class="p-summary">
@autoclosure 擁有把我們呼叫 function 時傳入的參數變成 closure 的神奇魔力，例如以下例子。
</section>
<section data-field="body" class="e-content">
<section name="8346" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c6bb" id="c6bb" class="graf graf--h3 graf--leading graf--title">把參數變成 closure 的 <strong class="markup--strong markup--h3-strong">@autoclosure</strong></h3><p name="67f5" id="67f5" class="graf graf--p graf-after--h3">@autoclosure 擁有把我們呼叫 function 時傳入的參數變成 closure 的神奇魔力，例如以下例子。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="6c65" id="6c65" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sing</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">String</span>, <span class="hljs-params">at</span> <span class="hljs-params">hour</span>: <span class="hljs-type">Int</span>) {<br />   <span class="hljs-keyword">if</span> hour <span class="hljs-operator">&gt;=</span> <span class="hljs-number">22</span> {<br />      <span class="hljs-keyword">let</span> song <span class="hljs-operator">=</span> sing()<br />      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;深夜適合播放<span class="hljs-subst">\(song)</span>&quot;</span>)<br />   } <span class="hljs-keyword">else</span> {<br />      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;認真寫 iOS App&quot;</span>)<br />   }<br />}</span></pre><p name="ed23" id="ed23" class="graf graf--p graf-after--pre">呼叫 play function 時，自動完成告訴我們第一個參數應該傳入字串，但剛剛我們明明將第一個參數的型別宣告為 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">() -&gt; String</strong></code> 呀 ? 不是應該傳入 closure 嗎 ?</p><figure name="37ff" id="37ff" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*S2glCpSSdpglCcILN4Kj3g.jpeg" data-width="638" data-height="102" src="https://cdn-images-1.medium.com/max/800/1*S2glCpSSdpglCcILN4Kj3g.jpeg"></figure><p name="2a6d" id="2a6d" class="graf graf--p graf-after--figure">因為 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">() -&gt; String</strong></code>前加了 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">@autoclosure</strong></code>的關係，Swift 會將我們傳入的參數變成 closure。我們只要傳入字串，它就能自動變成型別 () -&gt; String 的 closure。</p><p name="2b7f" id="2b7f" class="graf graf--p graf-after--p">如以下例子，<code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">songs.randomElement()!</strong></code> 會成為被 { } 包起來的 closure <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">{ songs.randomElement()! }</strong></code>。又由於 { } 裡 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">songs.randomElement()!</strong></code> 是唯一的程式，所以 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">randomElement()</strong></code> 得到的字串會回傳，符合當初參數要求的型別 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">() -&gt; String</strong></code>。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="561e" id="561e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> songs <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;真心不騙&quot;</span>, <span class="hljs-string">&quot;已讀不回&quot;</span>]<br />play(songs.randomElement()<span class="hljs-operator">!</span>, at: <span class="hljs-number">23</span>)</span></pre><p name="3ebc" id="3ebc" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="10f5" id="10f5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*j--oFw3Wx0ILiYNBm3ePUA.jpeg" data-width="1878" data-height="660" src="https://cdn-images-1.medium.com/max/800/1*j--oFw3Wx0ILiYNBm3ePUA.jpeg"></figure><p name="f452" id="f452" class="graf graf--p graf-after--figure">但是為什麼要使用 @autoclosure 呢 ? 以剛剛的例子來說，它可以帶來以下幾個好處。</p><ul class="postList"><li name="d4c3" id="d4c3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">傳入的參數不一定會執行。</strong></li></ul><p name="f752" id="f752" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">songs.randomElement()!</strong></code> 不一定會執行。因為白天要認真寫 App，要等到晚上 22 點之後才能開始流淚播放悲傷的情歌。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b842" id="b842" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> hour <span class="hljs-operator">&gt;=</span> <span class="hljs-number">22</span> {<br />   <span class="hljs-keyword">let</span> song <span class="hljs-operator">=</span> sing()<br />   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;深夜適合播放<span class="hljs-subst">\(song)</span>&quot;</span>)<br />} <span class="hljs-keyword">else</span> {<br />   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;認真寫 iOS App&quot;</span>)<br />}</span></pre><ul class="postList"><li name="b595" id="b595" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">傳入的參數延後執行。</strong></li></ul><p name="fa94" id="fa94" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">play(songs.randomElement()!, at: 23)</strong></code> 只是先傳入程式碼 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">songs.randomElement()!</strong></code>，要等 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">sing()</strong></code> 時才會執行。</p><p name="03fc" id="03fc" class="graf graf--p graf-after--p">其實我們平常開發 iOS App 時，很常使用的 assert function 就含有兩個參數是 @autoclosure 呢 !</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3ff4" id="3ff4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">assert</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">condition</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Bool</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">message</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">default</span>, <span class="hljs-params">file</span>: <span class="hljs-type">StaticString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">#file</span>, <span class="hljs-params">line</span>: <span class="hljs-type">UInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">#line</span>)</span></pre><div name="e1d2" id="e1d2" class="graf graf--mixtapeEmbed graf-after--pre"><a href="https://developer.apple.com/documentation/swift/assert%28_:_:file:line:%29" data-href="https://developer.apple.com/documentation/swift/assert(_:_:file:line:)" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/assert(_:_:file:line:)"><strong class="markup--strong markup--mixtapeEmbed-strong">assert(_:_:file:line:) | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Performs a traditional C-style assert with an optional message.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/assert%28_:_:file:line:%29" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="eb696491098a5fc43d7955d170634ae9" data-thumbnail-img-id="0*0BGDrYYSsc0cWUK7" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*0BGDrYYSsc0cWUK7);"></a></div><div name="d88e" id="d88e" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%AA%A2%E6%9F%A5%E6%A2%9D%E4%BB%B6%E6%98%AF%E5%90%A6%E6%BB%BF%E8%B6%B3%E5%92%8C%E8%AE%93-app-%E8%87%AA%E6%AE%BA%E7%9A%84-assert-precondition-%E5%92%8C-fatalerror-4ba8f437471f" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%AA%A2%E6%9F%A5%E6%A2%9D%E4%BB%B6%E6%98%AF%E5%90%A6%E6%BB%BF%E8%B6%B3%E5%92%8C%E8%AE%93-app-%E8%87%AA%E6%AE%BA%E7%9A%84-assert-precondition-%E5%92%8C-fatalerror-4ba8f437471f" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%AA%A2%E6%9F%A5%E6%A2%9D%E4%BB%B6%E6%98%AF%E5%90%A6%E6%BB%BF%E8%B6%B3%E5%92%8C%E8%AE%93-app-%E8%87%AA%E6%AE%BA%E7%9A%84-assert-precondition-%E5%92%8C-fatalerror-4ba8f437471f"><strong class="markup--strong markup--mixtapeEmbed-strong">檢查條件是否滿足和讓 App 自殺的 assert，precondition 和 fatalError</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，我們會遇到兩種錯誤，一種是 App 可以繼續運作，比方網路斷線，無法顯示資料，像以下 IG App 顯示無法連線上網。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%AA%A2%E6%9F%A5%E6%A2%9D%E4%BB%B6%E6%98%AF%E5%90%A6%E6%BB%BF%E8%B6%B3%E5%92%8C%E8%AE%93-app-%E8%87%AA%E6%AE%BA%E7%9A%84-assert-precondition-%E5%92%8C-fatalerror-4ba8f437471f" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="31391cfd584aa68e63c88235dacd09c5" data-thumbnail-img-id="1*daQ5O2m-TSTlQvb3j3G3Sw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*daQ5O2m-TSTlQvb3j3G3Sw.jpeg);"></a></div><p name="266d" id="266d" class="graf graf--p graf-after--mixtapeEmbed">因為 @autoclosure 的關係，它的自動完成提示將如下圖， condition &amp; message 的型別分別為 Bool 和 String，但最後其實會變成 () -&gt; Bool 和 () -&gt; String 型別的 closure 。</p><figure name="fc40" id="fc40" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jJ4ms_J6onL3tQFOwI1t6Q.jpeg" data-width="932" data-height="90" src="https://cdn-images-1.medium.com/max/800/1*jJ4ms_J6onL3tQFOwI1t6Q.jpeg"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8dec" id="8dec" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> songIndex <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br /><span class="hljs-keyword">let</span> songs <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;小幸運&quot;</span>, <span class="hljs-string">&quot;中幸運&quot;</span>, <span class="hljs-string">&quot;大幸運&quot;</span>]<br /><span class="hljs-built_in">assert</span>(songIndex <span class="hljs-operator">&lt;</span> songs.count, <span class="hljs-string">&quot;沒有這首歌!&quot;</span>)</span></pre><figure name="6ef6" id="6ef6" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*X5nMVJR_xAB_B63pKzfnMw.jpeg" data-width="1750" data-height="370" src="https://cdn-images-1.medium.com/max/800/1*X5nMVJR_xAB_B63pKzfnMw.jpeg"></figure><p name="25dd" id="25dd" class="graf graf--p graf-after--figure">為什麼 assert 要將參數 condition &amp; message 宣告為 @autoclosure 呢? 加了 @autoclosure，參數 condition &amp; message 會變成 closure，不會馬上執行，於是 assert 可以檢查 build 的模式，只在 debug builds 時執行參數 condition &amp; message 的 closure。</p><p name="1995" id="1995" class="graf graf--p graf-after--p">關於 @autoclosure，最後還有個 2 個小地方可以補充。</p><ul class="postList"><li name="e180" id="e180" class="graf graf--li graf-after--p">可以跟 @escaping 結合。</li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="66b4" id="66b4" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sing</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">String</span>, <span class="hljs-params">at</span> <span class="hljs-params">hour</span>: <span class="hljs-type">Int</span>) {<br />}</span></pre><p name="2484" id="2484" class="graf graf--p graf-after--pre">2 它搭配的 function 型別必須沒有參數，因此 () -&gt; String 可以，但 (Int) -&gt; String 不行。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="cf57" id="cf57" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sing</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">String</span>, <span class="hljs-params">at</span> <span class="hljs-params">hour</span>: <span class="hljs-type">Int</span>) {<br />}</span></pre><figure name="28c1" id="28c1" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*0gwj61CeCiUoOpz8CnjHKQ.jpeg" data-width="1382" data-height="278" src="https://cdn-images-1.medium.com/max/800/1*0gwj61CeCiUoOpz8CnjHKQ.jpeg"></figure><pre name="a762" id="a762" class="graf graf--pre graf-after--figure graf--trailing">Argument type of <a href="http://twitter.com/autoclosure" data-href="http://twitter.com/autoclosure" class="markup--anchor markup--pre-anchor" title="Twitter profile for @autoclosure" rel="noopener" target="_blank">@autoclosure</a> parameter must be &#39;()&#39;</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/54479e9bf663"><time class="dt-published" datetime="2018-09-07T14:51:56.653Z">September 7, 2018</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E6%8A%8A%E5%8F%83%E6%95%B8%E8%AE%8A%E6%88%90-closure-%E7%9A%84-autoclosure-54479e9bf663" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>