<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift 的 Hashable protocol</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift 的 Hashable protocol</h1>
</header>
<section data-field="subtitle" class="p-summary">
Swift 裡有一個特別的 Hashable protocol，我們在很多地方都可以看到它的蹤跡。
</section>
<section data-field="body" class="e-content">
<section name="abf7" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="31c5" id="31c5" class="graf graf--h3 graf--leading graf--title">Swift 的 Hashable protocol</h3><p name="1dcf" id="1dcf" class="graf graf--p graf-after--h3">Swift 裡有一個特別的 Hashable protocol，我們在很多地方都可以看到它的蹤跡。</p><div name="422e" id="422e" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/swift/hashable" data-href="https://developer.apple.com/documentation/swift/hashable" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/hashable"><strong class="markup--strong markup--mixtapeEmbed-strong">Hashable | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">A type that can be hashed into a to produce an integer hash value.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/hashable" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="5f74f615585c8b97cab5d84a7c32334a" data-thumbnail-img-id="0*cchpV3l3pObbgco4" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*cchpV3l3pObbgco4);"></a></div><p name="7b74" id="7b74" class="graf graf--p graf-after--mixtapeEmbed">比方 Set 要求它的成員型別一定要遵從 Hashable，因此遵從 Hashable 的字串可以存入 Set，沒有遵從 Hashable 的 CGPoint 資料無法。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7f7d" id="7f7d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Element</span>&gt; <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span> : <span class="hljs-title class_">Hashable</span></span></pre><figure name="1043" id="1043" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*EpnWMnMEyVbWiuUQiJbZ9w.jpeg" data-width="1762" data-height="538" src="https://cdn-images-1.medium.com/max/800/1*EpnWMnMEyVbWiuUQiJbZ9w.jpeg"></figure><h3 name="9773" id="9773" class="graf graf--h3 graf-after--figure">讓自訂型別遵從 Hashable protocol</h3><p name="58a3" id="58a3" class="graf graf--p graf-after--h3">當型別遵從 Hashable protocol 時，它可以產生一個稱為 hash value 的特別數字。這類的資料很適合存在 Set 或 Dictionary 裡，因為 Set 或 Dictionary 可以利用此數字區分資料跟快速找到資料。</p><p name="f918" id="f918" class="graf graf--p graf-after--p">Swift 裡很多基本的型別都遵從 Hashable，比方 String，Int，Double 等。不過我們也可以讓自訂的型別遵從 Hashable。</p><p name="e2b6" id="e2b6" class="graf graf--p graf-after--p">當 struct 的 property 都遵從 Hashable 時，我們只要讓它遵從 Hashable，不用定義 Hashable 的 function hash(into:)，因為 Swift 可以幫我們產生。以下例子 Swift 產生的 function hash(into:) 將利用 name &amp; height 產生 hash value。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ae35" id="ae35" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span>: <span class="hljs-title class_">Hashable</span> {<br />    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> height: <span class="hljs-type">Double</span><br />}<br /><br /><span class="hljs-keyword">let</span> hero1 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">180</span>)<br /><span class="hljs-keyword">let</span> hero2 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Park&quot;</span>, height: <span class="hljs-number">173</span>)<br /><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">=</span> <span class="hljs-type">Set</span>(arrayLiteral: hero1, hero2)</span></pre><p name="db02" id="db02" class="graf graf--p graf-after--pre">而 enum 則更厲害，當它沒有 associated value 時將自動遵從 Hashable protocol。當它有 associated value，而且 associated value 的型別遵從 Hashable protocol 時，跟剛剛的 struct 一樣，我們只要讓它遵從 Hashable，不用定義 Hashable 的 function hash(into:)，因為 Swift 可以幫我們產生。</p><p name="5cea" id="5cea" class="graf graf--p graf-after--p">看來讓自訂型別遵從 Hashable protocol 滿容易的，我們甚至不用定義它的 function hash(into:)。不過還是有幾種例外的 case。</p><ul class="postList"><li name="ea19" id="ea19" class="graf graf--li graf-after--p">當 struct 的 property 不遵從 Hashable</li><li name="388d" id="388d" class="graf graf--li graf-after--li">當型別是 class。</li><li name="1718" id="1718" class="graf graf--li graf-after--li">我們想自己定義 function hash(into:)。</li><li name="2913" id="2913" class="graf graf--li graf-after--li">搭配 associated value 的 enum，而且 associated value 的型別沒有遵從 Hashable protocol。</li></ul><p name="b48a" id="b48a" class="graf graf--p graf-after--li">因此接下來讓我們看個自訂 hash(into:) 的例子。</p><h3 name="74f8" id="74f8" class="graf graf--h3 graf-after--p">自訂 function hash(into:)</h3><p name="6a47" id="6a47" class="graf graf--p graf-after--h3">以下例子裡，我們自訂 function hash(into:)。hasher.combine(name) &amp; hasher.combine(gender) 表示我們將利用 name &amp; gender 計算 hash value，而 height 則對 hash value 無任何影響。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="da4a" id="da4a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span>: <span class="hljs-title class_">Hashable</span> {<br />   <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">let</span> height: <span class="hljs-type">Double</span><br />   <span class="hljs-keyword">let</span> gender: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">into</span> <span class="hljs-params">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Hasher</span>) {<br />      hasher.combine(name)<br />      hasher.combine(gender)<br />   }<br />}<br /><br /><span class="hljs-keyword">let</span> hero1 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">180</span>, gender: <span class="hljs-string">&quot;Male&quot;</span>)<br /><span class="hljs-keyword">let</span> hero2 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">173</span>, gender: <span class="hljs-string">&quot;Male&quot;</span>)<br /><span class="hljs-keyword">let</span> hero3 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">160</span>, gender: <span class="hljs-string">&quot;Female&quot;</span>)</span></pre><p name="aadd" id="aadd" class="graf graf--p graf-after--pre">因此同樣是男彼得潘的 hero1 &amp; hero2 有一樣的 hash value，但女彼得潘 hero3 則有不同的 hash value。</p><figure name="0ecd" id="0ecd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qtKicFEPqjnLIy9U-k0zOA.jpeg" data-width="700" data-height="562" src="https://cdn-images-1.medium.com/max/800/1*qtKicFEPqjnLIy9U-k0zOA.jpeg"></figure><p name="3198" id="3198" class="graf graf--p graf-after--figure">若是我們沒有自訂 hash(into:)，Hero 產生 hash value 時將使用到每個 property，因此它將同時考慮 name，height &amp; gender，最後 hero1，hero2 &amp; hero3 將產生不同的 hash value。</p><figure name="f7c7" id="f7c7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*E6jdmOdtt3yp-5HYL-Wp0w.jpeg" data-width="696" data-height="560" src="https://cdn-images-1.medium.com/max/800/1*E6jdmOdtt3yp-5HYL-Wp0w.jpeg"></figure><h3 name="b2a4" id="b2a4" class="graf graf--h3 graf-after--figure">利用 name &amp; gender 判斷英雄是否重覆</h3><p name="743d" id="743d" class="graf graf--p graf-after--h3">Set 可以保證集合裡的成員不會有重覆的。以剛剛的型別 Hero 為例，我們想在 set 裡裝不重覆的英雄，只要 name &amp; gender 不一樣就當成不同的英雄。因此 Hero 型別必須加入以下程式</p><ul class="postList"><li name="2dde" id="2dde" class="graf graf--li graf-after--p">遵從 protocol Hashable</li><li name="1605" id="1605" class="graf graf--li graf-after--li">function hash 裡利用 name &amp; gender 計算 hash value。</li><li name="679f" id="679f" class="graf graf--li graf-after--li">function == 利用 name &amp; gender 判斷是否相等。</li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c9d1" id="c9d1" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span>: <span class="hljs-title class_">Hashable</span> {<br />    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span><br />    <span class="hljs-keyword">var</span> gender: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">into</span> <span class="hljs-params">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Hasher</span>) {<br />        hasher.combine(name)<br />        hasher.combine(gender)<br />    }<br />    <br />    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-type">Bool</span> {<br />        lhs.name <span class="hljs-operator">==</span> rhs.name <span class="hljs-operator">&amp;&amp;</span> lhs.gender <span class="hljs-operator">==</span> rhs.gender<br />    }<br />}<br /><br /><span class="hljs-keyword">let</span> hero1 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">180</span>, gender: <span class="hljs-string">&quot;Male&quot;</span>)<br /><span class="hljs-keyword">let</span> hero2 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">173</span>, gender: <span class="hljs-string">&quot;Male&quot;</span>)<br /><span class="hljs-keyword">let</span> hero3 <span class="hljs-operator">=</span> <span class="hljs-type">Hero</span>(name: <span class="hljs-string">&quot;Peter Pan&quot;</span>, height: <span class="hljs-number">160</span>, gender: <span class="hljs-string">&quot;Female&quot;</span>)<br /><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> <span class="hljs-operator">=</span> <span class="hljs-type">Set</span>(arrayLiteral: hero1, hero2, hero3)</span></pre><h3 name="5a41" id="5a41" class="graf graf--h3 graf-after--pre">定義 function ==</h3><p name="e50a" id="e50a" class="graf graf--p graf-after--h3">剛剛提到某些情況我們要自己定義 hash(into:)。然而當 property 不遵從 Hashable 時，我們還要自己定義 function ==，例如以下例子。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3d9a" id="3d9a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pet</span> {<br />   <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span>: <span class="hljs-title class_">Hashable</span> {<br />   <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">let</span> pet: <span class="hljs-type">Pet</span><br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">into</span> <span class="hljs-params">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Hasher</span>) {<br />      hasher.combine(name)<br />      hasher.combine(pet.name)<br />   }<br />}</span></pre><p name="7000" id="7000" class="graf graf--p graf-after--pre">以上程式將產生錯誤 does not conform to protocol Equatable。</p><figure name="4189" id="4189" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fP_pxqwW5_vZ82SOLwTMnw.jpeg" data-width="1062" data-height="318" src="https://cdn-images-1.medium.com/max/800/1*fP_pxqwW5_vZ82SOLwTMnw.jpeg"></figure><p name="36b4" id="36b4" class="graf graf--p graf-after--figure">為什麼會有這個錯誤呢 ? 這和 protocol Hashable 的定義有關。protocol Hashable 本身又遵從 Equatable，所以當我們的自訂型別遵從 Hashable 時，它同時也要遵從 Equatable。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d5ef" id="d5ef" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Hashable</span> : <span class="hljs-title class_">Equatable</span></span></pre><p name="1f26" id="1f26" class="graf graf--p graf-after--pre">當 struct 的 property 都遵從 Equatable 時，我們只要讓它遵從 Equatable，Swift 即可幫我們定義 Equatable 的 function ==。因此以下的 Hero 型別遵從 protocol Hashable ＆ Equatable，而且我們不用自己定義 protocol 的 function。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2338" id="2338" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span>: <span class="hljs-title class_">Hashable</span> {<br />   <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">let</span> height: <span class="hljs-type">Double</span><br />}</span></pre><p name="7c4e" id="7c4e" class="graf graf--p graf-after--pre">然而剛剛出問題的例子裡，Hero 的 property pet 型別為 Pet，Pet 並不遵從 Hashable &amp; Equatable，因此我們得自己定義 function == &amp; hash(into:)。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ddb7" id="ddb7" class="graf graf--pre graf-after--p graf--trailing graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span>: <span class="hljs-title class_">Hashable</span> {<br />   <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">let</span> pet: <span class="hljs-type">Pet</span><br /><br />   <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span> (<span class="hljs-params">lhs</span>: <span class="hljs-type">Hero</span>, <span class="hljs-params">rhs</span>: <span class="hljs-type">Hero</span>) -&gt; <span class="hljs-type">Bool</span> {<br />      <span class="hljs-keyword">return</span> lhs.name <span class="hljs-operator">==</span> rhs.name <span class="hljs-operator">&amp;&amp;</span> lhs.pet.name <span class="hljs-operator">==</span> rhs.pet.name<br />   }<br /><br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">into</span> <span class="hljs-params">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Hasher</span>) {<br />      hasher.combine(name)<br />      hasher.combine(pet.name)<br />   }<br />}</span></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/6df8adfdcb54"><time class="dt-published" datetime="2019-07-13T18:19:24.605Z">July 13, 2019</time></a>.</p><p><a href="https://medium.com/@apppeterpan/swift-%E7%9A%84-hashable-protocol-6df8adfdcb54" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>