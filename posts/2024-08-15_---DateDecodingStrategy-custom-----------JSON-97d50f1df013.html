<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>利用 DateDecodingStrategy.custom 處理多種時間格式的 JSON</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">利用 DateDecodingStrategy.custom 處理多種時間格式的 JSON</h1>
</header>
<section data-field="subtitle" class="p-summary">
透過 DateDecodingStrategy 提供的各種 case，我們可以處理多種時間格式的 JSON 資料，比方 iso8601 和 secondsSince1970。
</section>
<section data-field="body" class="e-content">
<section name="65e7" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c52f" id="c52f" class="graf graf--h3 graf--leading graf--title">利用 DateDecodingStrategy.custom 處理多種時間格式的 JSON</h3><figure name="7cc4" id="7cc4" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*G9KaJ6pALIfLPuxoLjQpAg.png" data-width="1438" data-height="506" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*G9KaJ6pALIfLPuxoLjQpAg.png"></figure><p name="c781" id="c781" class="graf graf--p graf-after--figure">透過 DateDecodingStrategy 提供的各種 case，我們可以處理多種時間格式的 JSON 資料，比方 iso8601 和 secondsSince1970。</p><div name="cf94" id="cf94" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193"><strong class="markup--strong markup--mixtapeEmbed-strong">JSONDecoder 解析時間的 DateDecodingStrategy</strong><br><em class="markup--em markup--mixtapeEmbed-em">當我們利用 JSONDecoder 串接 API 回傳的 JSON 資料時，通常我們會將時間欄位的資料對應到 Date 型別，方便之後App 使用一些時間運算的 function。不過 API 回傳的時間有許多格式，因此我們須告訴…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fad371785dbafdf71cb84bb33b2027f6" data-thumbnail-img-id="1*ReAitj-hKl0IxZ2546Jyeg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*ReAitj-hKl0IxZ2546Jyeg.jpeg);"></a></div><p name="3da1" id="3da1" class="graf graf--p graf-after--mixtapeEmbed">不過如果 JSON 裡有多種時間格式，我們要如何處理呢 ? 比方以下 JSON 的 time1 是 iso8601，time2 是 secondsSince1970。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="json" name="656a" id="656a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-punctuation">{</span><br />       <span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br />            <span class="hljs-attr">&quot;time1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2019-12-15T12:00:00Z&quot;</span><span class="hljs-punctuation">,</span><br />            <span class="hljs-attr">&quot;time2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1723700000</span><span class="hljs-punctuation">,</span><br />       <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <br />       <span class="hljs-attr">&quot;number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><br />    <span class="hljs-punctuation">}</span></span></pre><p name="d727" id="d727" class="graf graf--p graf-after--pre">此時我們可透過 DateDecodingStrategy 的 custom case 處理，在 custom 的 closure 裡依據 key 撰寫對應的時間解析程式。</p><p name="deee" id="deee" class="graf graf--p graf-after--p">以剛剛的 JSON 為例，假設我們定義了對應的 struct TimeData，將 time1 &amp; time2 宣告為 Date 型別。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="92d6" id="92d6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TimeData</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> time: <span class="hljs-type">Time</span><br />    <span class="hljs-keyword">let</span> number: <span class="hljs-type">Int</span><br /><br />    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Time</span>: <span class="hljs-title class_">Codable</span> {<br />        <span class="hljs-keyword">let</span> time1: <span class="hljs-type">Date</span><br />        <span class="hljs-keyword">let</span> time2: <span class="hljs-type">Date</span><br />    }<br />}</span></pre><p name="3032" id="3032" class="graf graf--p graf-after--pre">以下我們在 ViewController 裡定義解析 JSON 的 function decodeTime。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="4d3b" id="4d3b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <span class="hljs-keyword">let</span> iso8601Formatter <span class="hljs-operator">=</span> <span class="hljs-type">ISO8601DateFormatter</span>()<br />    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;<br />    {<br />       &quot;time&quot;: {<br />            &quot;time1&quot;: &quot;2019-12-15T12:00:00Z&quot;,<br />            &quot;time2&quot;: 1723700000,<br />       }, <br />       &quot;number&quot;: 100<br />    }<br />    &quot;&quot;&quot;</span>.data(using: .utf8)<span class="hljs-operator">!</span><br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">decodeTime</span>() {<br />        <span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br />        decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .custom({ decoder <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.singleValueContainer()<br />            <span class="hljs-keyword">let</span> codingPath <span class="hljs-operator">=</span> decoder.codingPath<br />            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> key <span class="hljs-operator">=</span> codingPath.last<span class="hljs-operator">?</span>.stringValue <span class="hljs-keyword">else</span> {<br />                <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;key is nil&quot;</span>)<br />            }<br />            <span class="hljs-keyword">switch</span> key {<br />            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;time1&quot;</span>:<br />                <span class="hljs-keyword">let</span> dateString <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br />                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.iso8601Formatter.date(from: dateString) {<br />                    <span class="hljs-keyword">return</span> date<br />                } <span class="hljs-keyword">else</span> {<br />                    <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;Invalid date string for time1&quot;</span>)<br />                }<br />            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;time2&quot;</span>:<br />                <span class="hljs-keyword">let</span> dateNumber <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Double</span>.<span class="hljs-keyword">self</span>)<br />                <span class="hljs-keyword">return</span> <span class="hljs-type">Date</span>(timeIntervalSince1970: dateNumber)<br />            default:<br />                <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;Unexpected key: <span class="hljs-subst">\(key)</span>&quot;</span>)<br />            }<br />        })<br />        <span class="hljs-keyword">do</span> {<br />            <span class="hljs-keyword">let</span> timeData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.decode(<span class="hljs-type">TimeData</span>.<span class="hljs-keyword">self</span>, from: data)<br />            <span class="hljs-built_in">print</span>(timeData)<br />        } <span class="hljs-keyword">catch</span> {<br />            <span class="hljs-built_in">print</span>(error)<br />        }<br />    }<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        <span class="hljs-comment">// Do any additional setup after loading the view.</span><br />        decodeTime()<br />        <br />    }<br />}</span></pre><p name="56fd" id="56fd" class="graf graf--p graf-after--pre">說明。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f359" id="f359" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> iso8601Formatter <span class="hljs-operator">=</span> <span class="hljs-type">ISO8601DateFormatter</span>()</span></pre><p name="fd5d" id="fd5d" class="graf graf--p graf-after--pre">將 iso8601Formatter 宣告為 property。此做法可提升效能，避免每次解碼 <code class="markup--code markup--p-code">time1</code> 時重新建立 <code class="markup--code markup--p-code">ISO8601DateFormatter</code>。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b6dd" id="b6dd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"> decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .custom({ decoder <span class="hljs-keyword">in</span></span></pre><p name="ea56" id="ea56" class="graf graf--p graf-after--pre">利用 custom 解析 JSON 裡的時間欄位。它將解析我們在 TimeData 裡宣告為 Date 型別的 property，因此 custom 的 closure 會解析 JSON 裡的 time1 &amp; time2。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="2b99" id="2b99" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> codingPath <span class="hljs-operator">=</span> decoder.codingPath<br /><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> key <span class="hljs-operator">=</span> codingPath.last<span class="hljs-operator">?</span>.stringValue <span class="hljs-keyword">else</span> {<br />    <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;key is nil&quot;</span>)<br />}</span></pre><p name="07a2" id="07a2" class="graf graf--p graf-after--pre">從 codingPath 取得 key，以剛剛的 JSON 為例，解碼時 custom 的 closure 會執行兩次，取得的 codingPath 分別是 <code class="markup--code markup--p-code">[CodingKeys(stringValue: &quot;time&quot;, intValue: nil), CodingKeys(stringValue: &quot;time1&quot;, intValue: nil)]</code> 和<code class="markup--code markup--p-code"> [CodingKeys(stringValue: &quot;time&quot;, intValue: nil), CodingKeys(stringValue: &quot;time2&quot;, intValue: nil)]</code>。我們想取得 key time1 &amp; time2，因此利用 codingPath.last?.stringValue 取得 key。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="830b" id="830b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">switch</span> key {<br /><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;time1&quot;</span>:<br />     <span class="hljs-keyword">let</span> dateString <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br />     <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.iso8601Formatter.date(from: dateString) {<br />         <span class="hljs-keyword">return</span> date<br />     } <span class="hljs-keyword">else</span> {<br />         <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;Invalid date string for time1&quot;</span>)<br />     }<br /><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;time2&quot;</span>:<br />     <span class="hljs-keyword">let</span> dateNumber <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Double</span>.<span class="hljs-keyword">self</span>)<br />     <span class="hljs-keyword">return</span> <span class="hljs-type">Date</span>(timeIntervalSince1970: dateNumber)<br /><span class="hljs-keyword">default</span>:<br />     <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;Unexpected key: <span class="hljs-subst">\(key)</span>&quot;</span>)<br />}</span></pre><p name="0167" id="0167" class="graf graf--p graf-after--pre graf--trailing">依據 key 用不同的方法將資料轉換成 Date 型別，key 為 time1 時資料是 iso8601 格式的字串，使用 iso8601Formatter 轉換。key 為 time2 時資料是距離 1970/1/1 的秒數，使用 Date(timeIntervalSince1970:) 生成時間。</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/97d50f1df013"><time class="dt-published" datetime="2024-08-15T18:10:20.966Z">August 15, 2024</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E5%88%A9%E7%94%A8-datedecodingstrategy-custom-%E8%99%95%E7%90%86%E5%A4%9A%E7%A8%AE%E6%99%82%E9%96%93%E6%A0%BC%E5%BC%8F%E7%9A%84-json-97d50f1df013" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>