<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>幫助 protocol 實現型別代號的 Associated Type</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">幫助 protocol 實現型別代號的 Associated Type</h1>
</header>
<section data-field="subtitle" class="p-summary">
Swift 裡很多東西都可以 generic，除了我們熟悉的 generic type &amp; generic function 外，還有我們本篇文章的主角 generic protocol。
</section>
<section data-field="body" class="e-content">
<section name="77f3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bdaf" id="bdaf" class="graf graf--h3 graf--leading graf--title">幫助 protocol 實現型別代號的 Associated Type</h3><p name="9cf7" id="9cf7" class="graf graf--p graf-after--h3">Swift 裡很多東西都可以 generic，除了我們熟悉的 generic type &amp; generic function 外，還有我們本篇文章的主角 generic protocol。</p><p name="1b34" id="1b34" class="graf graf--p graf-after--p">protocol 可以透過 Associated Type 宣告類似 generic 的型別代號，代號的真正型別則由到時候遵從 protocol 的型別決定。如此我們將能寫出更彈性的程式碼，不用一開始就將 protocol 裡 function 的參數型別限定。(ps: protocol with associated type 的縮寫是 PAT)</p><p name="380e" id="380e" class="graf graf--p graf-after--p">比方我們看看以下例子 :</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6083" id="6083" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Princess</span> {<br />   <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">HandyMan</span><br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">buyFoodForMe</span>(<span class="hljs-params">boyFriend</span>:<span class="hljs-type">HandyMan</span>)<br />}</span></pre><p name="f0e3" id="f0e3" class="graf graf--p graf-after--pre">在 protocol Princess 裡，我們利用關鍵字 associatedtype 宣告型別代號 HandyMan。HandyMan 就是所謂的工具人，當公主肚子餓時，她將呼叫 function buyFoodForMe，傳入型別工具人的男朋友，請男朋友買吃的給她。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="703c" id="703c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaiwanPrince</span> {<br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">buyFoodForMyPrincess</span>() {<br />      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;珍珠奶茶&quot;</span>)<br />   }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeautifulPrincess</span>:<span class="hljs-title class_">Princess</span> {<br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">buyFoodForMe</span>(<span class="hljs-params">boyFriend</span>:<span class="hljs-type">TaiwanPrince</span>) {<br />      boyFriend.buyFoodForMyPrincess()<br />   }<br />}</span></pre><p name="3e5f" id="3e5f" class="graf graf--p graf-after--pre">每個公主喜歡的菜都不一樣，我們可以定義不同的公主型別，讓它們交不同的男朋友。像美麗的公主，一般都喜歡台灣的王子。因此我們定義遵從 protocol Princess 的類別 BeautifulPrincess，定義 function buyFoodForMe。這時候神奇的事就發生了 ! 當我們定義 buyFoodForMe 的參數 boyFrined 型別為 TaiwanPrince 時，Swift 很聰明，它知道 buyFoodForMe(boyFriend:TaiwanPrince) 對應到當初 protocol 裡宣告的 buyFoodForMe(boyFriend:HandyMan)，所以型別代號 HandyMan 其實是 TaiwanPrince。因此，之後能夠買食物給美麗公主的男朋友，只能是來自台灣的王子。</p><figure name="2956" id="2956" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8L-Xiabac7igoveyBfztDg.jpeg" data-width="1556" data-height="1060" src="https://cdn-images-1.medium.com/max/800/1*8L-Xiabac7igoveyBfztDg.jpeg"></figure><p name="4752" id="4752" class="graf graf--p graf-after--figure">如以下例子所示，童話故事的結局都是美好的，最後溫蒂將開心地吃到彼得潘精心準備的珍珠奶茶。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f7b7" id="f7b7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> wendy <span class="hljs-operator">=</span> <span class="hljs-type">BeautifulPrincess</span>()<br /><span class="hljs-keyword">var</span> peterPan <span class="hljs-operator">=</span> <span class="hljs-type">TaiwanPrince</span>()<br />wendy.buyFoodForMe(boyFriend: peterPan)</span></pre><figure name="4b01" id="4b01" class="graf graf--figure graf--iframe graf-after--pre"><iframe src="https://www.youtube.com/embed/bBcp_ljCBGU?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe></figure><p name="8062" id="8062" class="graf graf--p graf-after--figure">前面說完了美麗公主的故事，接著我們要公平，關心一下邪惡的公主。如以下例子所示，邪惡公主 EvilPrincess 將 function buyFoodForMe 的 boyFriend 參數型別定義為 Monster，所以她這輩子只能跟怪獸交往，到時候 protocol 裡的型別代號 HandyMan 也就變成了 Monster。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="4c39" id="4c39" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> {<br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">buyFoodForMyPrincess</span>() {<br />      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我很醜，可是我有很好吃的食物&quot;</span>)<br />   }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilPrincess</span>:<span class="hljs-title class_">Princess</span> {<br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">buyFoodForMe</span>(<span class="hljs-params">boyFriend</span>:<span class="hljs-type">Monster</span>) {<br />      boyFriend.buyFoodForMyPrincess()<br />   }<br />}</span></pre><h3 name="b0a8" id="b0a8" class="graf graf--h3 graf-after--pre">決定 associated type 型別的六種方法</h3><div name="3726" id="3726" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%B1%BA%E5%AE%9A-associated-type-%E5%9E%8B%E5%88%A5%E7%9A%84%E5%85%AD%E7%A8%AE%E6%96%B9%E6%B3%95-e1991424f12f" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%B1%BA%E5%AE%9A-associated-type-%E5%9E%8B%E5%88%A5%E7%9A%84%E5%85%AD%E7%A8%AE%E6%96%B9%E6%B3%95-e1991424f12f" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%B1%BA%E5%AE%9A-associated-type-%E5%9E%8B%E5%88%A5%E7%9A%84%E5%85%AD%E7%A8%AE%E6%96%B9%E6%B3%95-e1991424f12f"><strong class="markup--strong markup--mixtapeEmbed-strong">決定 associated type 型別的六種方法</strong><br><em class="markup--em markup--mixtapeEmbed-em">protocol 可以透過 associated type 宣告型別代號，而代號的真正型別則可從遵從 protocol 的型別，protocol 的 extension，遵從 protocol 的型別的 extension，在宣告…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%B1%BA%E5%AE%9A-associated-type-%E5%9E%8B%E5%88%A5%E7%9A%84%E5%85%AD%E7%A8%AE%E6%96%B9%E6%B3%95-e1991424f12f" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7378d72498ab97d7176a1f05041e5152" data-thumbnail-img-id="1*rV3v1Evs47_a04d4L75tRQ.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*rV3v1Evs47_a04d4L75tRQ.jpeg);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/44cb2d25952e"><time class="dt-published" datetime="2017-02-10T04:08:33.370Z">February 10, 2017</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E5%B9%AB%E5%8A%A9-protocol-%E5%AF%A6%E7%8F%BE%E5%9E%8B%E5%88%A5%E4%BB%A3%E8%99%9F%E7%9A%84-associated-type-44cb2d25952e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>