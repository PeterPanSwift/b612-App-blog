<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>定義 Decodable 的 init(from:) 解析 JSON</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">定義 Decodable 的 init(from:) 解析 JSON</h1>
</header>
<section data-field="subtitle" class="p-summary">
透過 JSONDecoder，我們可以方便地將 JSON 資料變成遵從 protocol Decodable 的自訂型別，而且大部分的時候我們只要宣告型別裡的 property，不用自己撰寫解析 JSON 的 init(from: Decoder)，因為 Apple…
</section>
<section data-field="body" class="e-content">
<section name="c717" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="490f" id="490f" class="graf graf--h3 graf--leading graf--title">定義 Decodable 的 init(from:) 解析 JSON</h3><figure name="55f4" id="55f4" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*rvyZe7kQUWeREkieUQqrug.png" data-width="1674" data-height="828" src="https://cdn-images-1.medium.com/max/800/1*rvyZe7kQUWeREkieUQqrug.png"></figure><p name="0fe9" id="0fe9" class="graf graf--p graf-after--figure">透過 JSONDecoder，我們可以方便地將 JSON 資料變成遵從 protocol Decodable 的自訂型別，而且大部分的時候我們只要宣告型別裡的 property，不用自己撰寫解析 JSON 的 init(from:)，因為 Apple 已幫我們寫好 init(from:) 的程式。</p><div name="195b" id="195b" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-swift-4-%E7%9A%84-jsondecoder-%E5%92%8C-codable-%E8%A7%A3%E6%9E%90-json-%E5%92%8C%E7%94%9F%E6%88%90%E8%87%AA%E8%A8%82%E5%9E%8B%E5%88%A5%E8%B3%87%E6%96%99-ee793622629e" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-swift-4-%E7%9A%84-jsondecoder-%E5%92%8C-codable-%E8%A7%A3%E6%9E%90-json-%E5%92%8C%E7%94%9F%E6%88%90%E8%87%AA%E8%A8%82%E5%9E%8B%E5%88%A5%E8%B3%87%E6%96%99-ee793622629e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-swift-4-%E7%9A%84-jsondecoder-%E5%92%8C-codable-%E8%A7%A3%E6%9E%90-json-%E5%92%8C%E7%94%9F%E6%88%90%E8%87%AA%E8%A8%82%E5%9E%8B%E5%88%A5%E8%B3%87%E6%96%99-ee793622629e"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 JSONDecoder 和 Codable 解析 JSON 和生成自訂型別資料</strong><br><em class="markup--em markup--mixtapeEmbed-em">抓取網路上的 JSON 資料並不是太困難的事，但是如果想要解析它，甚至是把它變成方便 App 使用的自訂型別，卻需要寫許多程式碼才能實現。因此從前一些解析 JSON 和將 JSON 變成自訂型別的第三方套件大受歡迎，不過在 Swift…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-swift-4-%E7%9A%84-jsondecoder-%E5%92%8C-codable-%E8%A7%A3%E6%9E%90-json-%E5%92%8C%E7%94%9F%E6%88%90%E8%87%AA%E8%A8%82%E5%9E%8B%E5%88%A5%E8%B3%87%E6%96%99-ee793622629e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a1068ad2918bf3673e0459e185327c1a" data-thumbnail-img-id="1*l-tGFvpI-VyDff3rAGlYUQ.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*l-tGFvpI-VyDff3rAGlYUQ.png);"></a></div><p name="687c" id="687c" class="graf graf--p graf-after--mixtapeEmbed">以產生隨機 meme 的 API 為例。</p><pre name="d0f8" id="d0f8" class="graf graf--pre graf-after--p"><a href="https://some-random-api.ml/meme" data-href="https://some-random-api.ml/meme" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://some-random-api.ml/meme</a></pre><p name="b9f4" id="b9f4" class="graf graf--p graf-after--pre">它的 JSON 內容如下。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="json" name="0d09" id="0d09" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;https://i.some-random-api.ml/VM2Dkpp7VX.png&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caption&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Hmm I wonder if this was planned&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;math&quot;</span><span class="hljs-punctuation">}</span></span></pre><p name="e44b" id="e44b" class="graf graf--p graf-after--pre">我們可用 JSONDecoder 將它變成型別 Meme 的資料。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="64c9" id="64c9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Decodable</span> {<br />   <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />   <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />   <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span><br />}</span></pre><p name="e549" id="e549" class="graf graf--p graf-after--pre">然而遇到以下情況，我們可能會想自訂 init(from:) 解析 JSON。</p><ul class="postList"><li name="8a92" id="8a92" class="graf graf--li graf-after--p">property 的型別不是 Decodable，無法自動產生 init(from:)，因此我們要自己定義 init(from:)。</li></ul><p name="1336" id="1336" class="graf graf--p graf-after--li">下圖的 color 型別是 Color，沒有遵從 protocol Decodable，無法解碼。</p><figure name="4272" id="4272" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*VZpVKtdljq8n6AlXGyeM6g.png" data-width="1458" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*VZpVKtdljq8n6AlXGyeM6g.png"></figure><ul class="postList"><li name="4b00" id="4b00" class="graf graf--li graf-after--figure">想對 JSON 裡的資料做特別處理，比方將它整理成方便 App 使用的 model 型別。</li></ul><p name="4309" id="4309" class="graf graf--p graf-after--li">接下來就讓我們透過實際的例子，學習如何定義 init(from:) 解析 JSON。</p><div name="4426" id="4426" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/swift/decodable/init%28from:%29-8ezpn" data-href="https://developer.apple.com/documentation/swift/decodable/init(from:)-8ezpn" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/decodable/init(from:)-8ezpn"><strong class="markup--strong markup--mixtapeEmbed-strong">init(from:) | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Creates a new instance by decoding from the given decoder.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/decodable/init%28from:%29-8ezpn" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="8fdd8ffc1b6b165d358a5a7c623eec49" data-thumbnail-img-id="0*VVpsNgeBV_Spxho0" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*VVpsNgeBV_Spxho0);"></a></div><h3 name="266c" id="266c" class="graf graf--h3 graf-after--mixtapeEmbed">利用 container(keyedBy:) 解析第一層的 dictionary</h3><p name="3b4f" id="3b4f" class="graf graf--p graf-after--h3">我們先以剛剛產生隨機 meme 的 API 為例，說明如何搭配 CodingKey 解析 JSON 的 dictionary。</p><pre name="8780" id="8780" class="graf graf--pre graf-after--p"><a href="https://some-random-api.ml/meme" data-href="https://some-random-api.ml/meme" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener" target="_blank">https://some-random-api.ml/meme</a></pre><p name="f6cd" id="f6cd" class="graf graf--p graf-after--pre">以下為 JSON 的內容。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="json" name="0790" id="0790" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-punctuation">{</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;https://i.some-random-api.ml/VM2Dkpp7VX.png&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caption&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Hmm I wonder if this was planned&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;math&quot;</span><span class="hljs-punctuation">}</span></span></pre><p name="3abe" id="3abe" class="graf graf--p graf-after--pre">JSON 對應的型別 Meme 如下。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="a592" id="a592" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> Foundation <br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)<br />        image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />        caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)<br />    }<br />}</span></pre><p name="d13b" id="d13b" class="graf graf--p graf-after--pre">我們遵從 protocol Codable，然後在 init(from: Decoder) 撰寫解析 JSON 的程式。由於 JSON 的第一層是 dictionary，所以我們在 Meme 宣告 property id，image &amp; caption 儲存 dictionary 的內容，利用<code class="markup--code markup--p-code"> try decoder.container(keyedBy: CodingKeys.self)</code> 得到包含 dictionary 的 container。</p><p name="96f3" id="96f3" class="graf graf--p graf-after--p">傳入的參數 keyedBy 十分重要，它代表我們讀取 dictionary 時可以傳入的 key。</p><figure name="148e" id="148e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WCNGZ47WS_wKHakKzWkMkg.jpeg" data-width="1244" data-height="106" src="https://cdn-images-1.medium.com/max/800/1*WCNGZ47WS_wKHakKzWkMkg.jpeg"></figure><p name="8354" id="8354" class="graf graf--p graf-after--figure">參數 keyedBy 的型別是 protocol CodingKey，當我們遵從 prototcol Codable 時，Swift 會幫我們生成遵從 protocol CodingKey 的型別 CodingKeys，因此我們可以直接使用，在呼叫 container(keyedBy:) 時傳入 CodingKeys.self。它是一個 enum，裡面宣告的 case 的名稱將對應 property 的名字，所以會有 case id，image &amp; caption。</p><p name="b783" id="b783" class="graf graf--p graf-after--p">通常 property &amp; case 的名字會跟 JSON key 一模一樣，不過有時我們會想要 property &amp; case 的名字跟 JSON key 不一樣，相關的做法可參考以下連結。</p><div name="3873" id="3873" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-enum-codingkeys-%E5%AE%A2%E8%A3%BD-json-%E5%B0%8D%E6%87%89%E7%9A%84-property-1b27f29c0c32" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-enum-codingkeys-%E5%AE%A2%E8%A3%BD-json-%E5%B0%8D%E6%87%89%E7%9A%84-property-1b27f29c0c32" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-enum-codingkeys-%E5%AE%A2%E8%A3%BD-json-%E5%B0%8D%E6%87%89%E7%9A%84-property-1b27f29c0c32"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 enum CodingKeys 客製 JSON 對應的 property</strong><br><em class="markup--em markup--mixtapeEmbed-em">利用 JSONDecoder 我們可以方便地串接 API，將網路上的 JSON 資料轉換成方便 App 使用的自訂型別。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-enum-codingkeys-%E5%AE%A2%E8%A3%BD-json-%E5%B0%8D%E6%87%89%E7%9A%84-property-1b27f29c0c32" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f9911457c2d20b76f9dea0fff2d83a17" data-thumbnail-img-id="1*BEnqHultUN2yBm6iZwfeAw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*BEnqHultUN2yBm6iZwfeAw.jpeg);"></a></div><p name="627f" id="627f" class="graf graf--p graf-after--mixtapeEmbed">ps: 也許有人想到不一定要遵從 protocol Codable，解碼可以只遵從 Decodable。不過若是只遵從 protocol Decodable，並不會自動產生 CodingKeys，我們必須自己定義 CodingKeys。</p><figure name="72ab" id="72ab" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RoaL8IWfAw98UuN5o4RdIw.png" data-width="1976" data-height="862" src="https://cdn-images-1.medium.com/max/800/1*RoaL8IWfAw98UuN5o4RdIw.png"></figure><p name="1e63" id="1e63" class="graf graf--p graf-after--figure">得到 container 後，我們呼叫它的 function decode 讀取內容，在 decode 的第一個參數傳入資料的型別，第二個參數傳入對應的 key。值得注意的，key 的型別和生成 container 時傳入的參數 keyedBy 有關。我們剛剛在 keyedBy 傳入 CodingKeys.self，因此 forKey 的型別為 CodingKeys，我們可傳入的 key 是 CodingKeys 的 case，有 caption，id，image 三種。</p><figure name="b705" id="b705" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nKkygEGCm9KGPBoRzEmqdQ.jpeg" data-width="1170" data-height="148" src="https://cdn-images-1.medium.com/max/800/1*nKkygEGCm9KGPBoRzEmqdQ.jpeg"></figure><figure name="c95c" id="c95c" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*Qu6tFh_RBFvna4pw8aK9dA.png" data-width="998" data-height="378" src="https://cdn-images-1.medium.com/max/800/1*Qu6tFh_RBFvna4pw8aK9dA.png"></figure><p name="88e6" id="88e6" class="graf graf--p graf-after--figure">我們想讀取 JSON dictionary key id, image &amp; caption 的內容，它們的型別分別為 Int, URL &amp; String，因此我們利用以下程式讀取內容，然後存入 Meme 的 property。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c8d4" id="c8d4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)<br />image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)</span></pre><p name="f1ee" id="f1ee" class="graf graf--p graf-after--pre">在使用 decode(_:forKey:) 時有以下幾個小地方要特別注意:</p><p name="4448" id="4448" class="graf graf--p graf-after--p">1. 只能傳入遵從 Decodable 的型別，因為它只能將東西解碼成遵從 Decodable 的型別。</p><figure name="6837" id="6837" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pGZMwQGFSYtuWDfwVWPI-w.jpeg" data-width="1360" data-height="156" src="https://cdn-images-1.medium.com/max/800/1*pGZMwQGFSYtuWDfwVWPI-w.jpeg"></figure><p name="28cc" id="28cc" class="graf graf--p graf-after--figure">2. decode(_:forKey:) 有可能失敗。</p><p name="da6b" id="da6b" class="graf graf--p graf-after--p">要誠實，說謊的話 decode 會失敗。比方剛剛的 id 是整數，因此我們須傳入 Int.self。如果傳入 String.self 將造成解析失敗丟出錯誤。</p><p name="0958" id="0958" class="graf graf--p graf-after--p">定義好 JSON 對應的型別 Meme 後，我們即可利用 JSONDecoder 將 JSON 資料變成型別 Meme。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6404" id="6404" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://some-random-api.ml/meme&quot;</span>) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> meme <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Meme</span>.<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-built_in">print</span>(meme)<br />            } <span class="hljs-keyword">catch</span>  {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><h3 name="7f7e" id="7f7e" class="graf graf--h3 graf-after--pre">定義 init(from:) 時要設定每個 property</h3><p name="11dc" id="11dc" class="graf graf--p graf-after--h3">值得注意的，定義 init(from:) 時要確保每個 property 都有內容，除非它是 optional。比方以下例子忘了設定 caption，因此產生錯誤</p><pre name="e50b" id="e50b" class="graf graf--pre graf-after--p">Return from initializer without initializing all stored properties</pre><figure name="a151" id="a151" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*9NLwIKBuW9tbbPvkWu8wBQ.png" data-width="1980" data-height="688" src="https://cdn-images-1.medium.com/max/800/1*9NLwIKBuW9tbbPvkWu8wBQ.png"></figure><h3 name="c5f7" id="c5f7" class="graf graf--h3 graf-after--figure">快速輸入 init(from:)</h3><div name="6f39" id="6f39" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/add-explicit-codable-implementation-xcode-14-%E6%96%B0%E5%8A%9F%E8%83%BD-86be0b2ceafc" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/add-explicit-codable-implementation-xcode-14-%E6%96%B0%E5%8A%9F%E8%83%BD-86be0b2ceafc" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/add-explicit-codable-implementation-xcode-14-%E6%96%B0%E5%8A%9F%E8%83%BD-86be0b2ceafc"><strong class="markup--strong markup--mixtapeEmbed-strong">Add Explicit Codable Implementation — Xcode 14 新功能</strong><br><em class="markup--em markup--mixtapeEmbed-em">當我們串接 REST API 時，時常會定義遵從 protocol Codable 的資料型別對應 API 回傳的 JSON 資料，例如以下的 StoreItem 例子。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/add-explicit-codable-implementation-xcode-14-%E6%96%B0%E5%8A%9F%E8%83%BD-86be0b2ceafc" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="0b00e863d0deecc2420ce8f42bf9c903" data-thumbnail-img-id="1*nUdQP_Ai_KzZeWU0LCrWzA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*nUdQP_Ai_KzZeWU0LCrWzA.png);"></a></div><h3 name="bf5e" id="bf5e" class="graf graf--h3 graf-after--mixtapeEmbed">透過 extension 遵從 Codable</h3><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="8167" id="8167" class="graf graf--pre graf-after--h3 graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meme</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span>  <br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)<br />        image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />        caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)<br />    }<br />}</span></pre><p name="5a7b" id="5a7b" class="graf graf--p graf-after--pre">我們也可以透過 extension 遵從 Codable，得到以下兩個好處。</p><ul class="postList"><li name="8c7c" id="8c7c" class="graf graf--li graf-after--p">將 Codable 的相關程式切出來，讓程式更容易維護。</li><li name="2297" id="2297" class="graf graf--li graf-after--li">讓資料原本自動生成的 initializer 保留，我們可以用 memberwise initializer 生成資料。</li></ul><figure name="865a" id="865a" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*uecxq3m9yI0IT4F2QmpltQ.png" data-width="2180" data-height="1016" src="https://cdn-images-1.medium.com/max/800/1*uecxq3m9yI0IT4F2QmpltQ.png"></figure><p name="5e6b" id="5e6b" class="graf graf--p graf-after--figure">若是直接在 struct 裡定義 init，將失去原本自動生成的 initializer。</p><figure name="368d" id="368d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Z12o4FDdtHCvM84R2wlkkg.png" data-width="2170" data-height="1000" src="https://cdn-images-1.medium.com/max/800/1*Z12o4FDdtHCvM84R2wlkkg.png"></figure><h3 name="dd24" id="dd24" class="graf graf--h3 graf-after--figure">當 Codable 型別是 class， init(from:) 要加上 <strong class="markup--strong markup--h3-strong">required 或加上 final</strong></h3><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b696" id="b696" class="graf graf--pre graf-after--h3 graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)<br />        image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />        caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)<br />    }<br />}</span></pre><p name="4764" id="4764" class="graf graf--p graf-after--pre">如果不想加上 required，另一個方法是在 class 前加上 final。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b01b" id="b01b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span><br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        id <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>, forKey: .id)<br />        image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />        caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)<br />    }<br />}</span></pre><h3 name="7189" id="7189" class="graf graf--h3 graf-after--pre">將 JSON 裡的資料型別做轉換，比方字串轉數字</h3><p name="bd96" id="bd96" class="graf graf--p graf-after--h3">在定義 JSON 對應的自訂型別時，property 的型別通常會跟 JSON key 對應的 value 型別一致。不過有時我們希望可以轉換成方便 App 使用的型別，比方以下例子我們希望 id 是整數，然而 JSON 回傳的 id 是字串。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="5dd9" id="5dd9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;<br />{<br />   &quot;id&quot;: &quot;2&quot;,<br />   &quot;image&quot;: &quot;https://i.some-random-api.ml/VM2Dkpp7VX.png&quot;,<br />   &quot;caption&quot;: &quot;Hmm I wonder if this was planned&quot;,<br />   &quot;category&quot;: &quot;math&quot;<br />}<br />&quot;&quot;&quot;</span>.data(using: .utf8)<br /><br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> data {<br />    <span class="hljs-keyword">do</span> {<br />        <span class="hljs-keyword">let</span> meme <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Meme</span>.<span class="hljs-keyword">self</span>, from: data)<br />        <span class="hljs-built_in">print</span>(meme)<br />    } <span class="hljs-keyword">catch</span>  {<br />        <span class="hljs-built_in">print</span>(error)<br />    }<br />}</span></pre><p name="8936" id="8936" class="graf graf--p graf-after--pre">因此以上解法將印出以下解析 JSON 失敗的錯誤訊息。</p><pre name="7929" id="7929" class="graf graf--pre graf-after--p">typeMismatch(Swift.Int, Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: &quot;id&quot;, intValue: nil)], debugDescription: &quot;Expected to decode Int but found a string/data instead.&quot;, underlyingError: nil))</pre><p name="0a85" id="0a85" class="graf graf--p graf-after--pre">為了轉換型別，我們必須定義 init(from:) 自己轉換。以下我們先將 id 解碼成 String，再將它轉換成 Int。不過字串轉數字有可能失敗，所以我們要在失敗時丟出錯誤，在此我們丟出內建的 DecodingError。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7607" id="7607" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meme</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        <span class="hljs-keyword">let</span> idString <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .id)<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> id <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(idString) {<br />            <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br />        } <span class="hljs-keyword">else</span> {<br />            <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(forKey: <span class="hljs-type">CodingKeys</span>.id, in: container, debugDescription: <span class="hljs-string">&quot;id error&quot;</span>)<br />        }<br />        image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />        caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)<br />    }<br />}</span></pre><h3 name="611c" id="611c" class="graf graf--h3 graf-after--pre">利用 decodeIfPresent 解析 JSON 不一定會有的欄位</h3><p name="28eb" id="28eb" class="graf graf--p graf-after--h3">JSON 有時會出現不一定會有的欄位，此時我們可利用 decodeIfPresent 解碼，例如以下例子。</p><p name="2af9" id="2af9" class="graf graf--p graf-after--p">假設 Meme API 的 JSON 裡不一定會有 caption，因此我們將 struct Meme 的 property caption 宣告為 optional，然後利用 decodeIfPresent 解碼 JSON 裡的 caption 欄位。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="d7cd" id="d7cd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meme</span> {<br />    <span class="hljs-keyword">let</span> image: <span class="hljs-type">URL</span><br />    <span class="hljs-keyword">let</span> category: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> caption: <span class="hljs-type">String</span>?<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Meme</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        image <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">URL</span>.<span class="hljs-keyword">self</span>, forKey: .image)<br />        category <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .category)<br />        caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decodeIfPresent(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)<br />    }<br />}<br /><br /><span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;<br />{<br />   &quot;image&quot;: &quot;https://i.some-random-api.ml/VM2Dkpp7VX.png&quot;,<br />   &quot;category&quot;: &quot;math&quot;<br />}<br />&quot;&quot;&quot;</span>.data(using: .utf8)<br /><br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />    <span class="hljs-keyword">do</span> {<br />        <span class="hljs-keyword">let</span> meme <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Meme</span>.<span class="hljs-keyword">self</span>, from: data)<br />        <span class="hljs-built_in">print</span>(meme)<br />    } <span class="hljs-keyword">catch</span>  {<br />        <span class="hljs-built_in">print</span>(error)<br />    }<br />}</span></pre><p name="2121" id="2121" class="graf graf--p graf-after--pre">ps: 我們也可以用 decode 解析不一定會有的欄位，但是前面要搭配 try?，如此失敗時才不會丟出錯誤。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="efde" id="efde" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">caption <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .caption)</span></pre><h3 name="f263" id="f263" class="graf graf--h3 graf-after--pre">利用 <code class="markup--code markup--h3-code">unkeyedContainer </code>解析第一層的 array</h3><p name="b027" id="b027" class="graf graf--p graf-after--h3">以 Dcard API 為例。</p><pre name="a9ad" id="a9ad" class="graf graf--pre graf-after--p"><a href="https://dcard.tw/_api/posts" data-href="https://dcard.tw/_api/posts" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://dcard.tw/_api/posts</a></pre><p name="0f17" id="0f17" class="graf graf--p graf-after--pre">以下為 JSON 的內容。</p><figure name="6298" id="6298" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CwdwtJxGnMQD19dMmsHzeg.jpeg" data-width="552" data-height="576" src="https://cdn-images-1.medium.com/max/800/1*CwdwtJxGnMQD19dMmsHzeg.jpeg"></figure><p name="6355" id="6355" class="graf graf--p graf-after--figure">JSON 對應的 Decodable 型別 DcardData 如下。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="5998" id="5998" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dcard</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DcardData</span> {<br />    <span class="hljs-keyword">var</span> dcards: [<span class="hljs-type">Dcard</span>]<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DcardData</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        dcards <span class="hljs-operator">=</span> [<span class="hljs-type">Dcard</span>]()<br />        <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.unkeyedContainer()<br />        <span class="hljs-keyword">while</span> <span class="hljs-operator">!</span>container.isAtEnd {<br />            <span class="hljs-keyword">let</span> dcard <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Dcard</span>.<span class="hljs-keyword">self</span>)<br />            dcards.append(dcard)<br />        }<br />    }<br />}</span></pre><p name="8165" id="8165" class="graf graf--p graf-after--pre">由於 JSON 的第一層是 array，因此我們在 DcardData 裡宣告儲存 array 的 property dcards。我們利用 <code class="markup--code markup--p-code">try decoder.unkeyedContainer() </code>得到包含 array 的 container。由於沒有 key，所以讀取的方式比較特別。我們使用 while 搭配 isAtEnd 判斷，迴圈將一直執行，直到已經讀完最後一筆資料。</p><p name="4dbc" id="4dbc" class="graf graf--p graf-after--p">得到 container 後，我們呼叫它的 function decode 解碼資料。當我們從 container 第一次呼叫 decode 時，它將解碼 array 裡的第一筆資料。若 decode 成功，container 將改變，下次 decode 時將解碼 array 裡的下一筆資料。因此我們將依序讀完 array 的每一筆資料，直到 isAtEnd 變成 true。若是資料型別有問題，解碼失敗，我們也會 throw 錯誤，因此不用擔心變成無窮迴圈。</p><p name="96c5" id="96c5" class="graf graf--p graf-after--p">利用 JSONDecoder 將 JSON 資料變成型別 DcardData。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="66a9" id="66a9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://dcard.tw/_api/posts&quot;</span>) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> dcardData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">DcardData</span>.<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-built_in">print</span>(dcardData)<br />            } <span class="hljs-keyword">catch</span>  {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><p name="077a" id="077a" class="graf graf--p graf-after--pre">ps: 如果沒有自訂 init(from: Decoder)，我們也可用以下寫法解析剛剛的 JSON。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="5bf1" id="5bf1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dcard</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://dcard.tw/_api/posts&quot;</span>) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> dcardData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode([<span class="hljs-type">Dcard</span>].<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-built_in">print</span>(dcardData)<br />            } <span class="hljs-keyword">catch</span>  {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><h3 name="0dad" id="0dad" class="graf graf--h3 graf-after--pre">利用 nestedContainer &amp; nestedUnkeyedContainer 讀取內層的 dictionary &amp; array</h3><p name="5f26" id="5f26" class="graf graf--p graf-after--h3">在剛剛的 dcard 例子裡，我們將 array 裡的 dictionary decode 成型別 Dcard。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="5f2a" id="5f2a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> dcard <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Dcard</span>.<span class="hljs-keyword">self</span>)</span></pre><p name="f578" id="f578" class="graf graf--p graf-after--pre">不過我們也可以試試將 dictionary 的內容一個個取出再生成 dcard。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="c18a" id="c18a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dcard</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> excerpt: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DcardData</span> {<br />    <span class="hljs-keyword">var</span> dcards: [<span class="hljs-type">Dcard</span>]<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DcardData</span>: <span class="hljs-title class_">Codable</span> {<br />    <br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DcardDataKeys</span>: <span class="hljs-title class_">CodingKey</span> {<br />        <span class="hljs-keyword">case</span> title, excerpt<br />    }<br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        dcards <span class="hljs-operator">=</span> [<span class="hljs-type">Dcard</span>]()<br />        <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.unkeyedContainer()<br />        <span class="hljs-keyword">while</span> <span class="hljs-operator">!</span>container.isAtEnd {<br />            <span class="hljs-keyword">let</span> dcardContainer <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.nestedContainer(keyedBy: <span class="hljs-type">DcardDataKeys</span>.<span class="hljs-keyword">self</span>)<br />            <span class="hljs-keyword">let</span> title <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> dcardContainer.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .title)<br />            <span class="hljs-keyword">let</span> excerpt <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> dcardContainer.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .excerpt)<br />            <span class="hljs-keyword">let</span> dcard <span class="hljs-operator">=</span> <span class="hljs-type">Dcard</span>(title: title, excerpt: excerpt)<br />            dcards.append(dcard)<br />        }<br />    }<br />}</span></pre><p name="da3a" id="da3a" class="graf graf--p graf-after--pre">由於 array 的成員是 dictionary，因此我們可用 <code class="markup--code markup--p-code">container.nestedContainer(keyedBy: CodingKeys.self)</code> 取得包含 dictionary 的 container，然後用 decode 將 key 對應的 value 一個個讀出後再生成 dcard 加到 array。</p><p name="6142" id="6142" class="graf graf--p graf-after--p">值得注意的，由於 DcardData 裡自動生成的 enum CodingKeys 只有 case dcards，沒有 title &amp; excerpt，以下程式將產生錯誤，因此我們必須另外定義遵從 CodingKey 的 enum DcardDataKeys，如此才能讀取 title &amp; excerpt。</p><figure name="cb55" id="cb55" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YiSwE3xBUVdnzLfy9GlqGA.png" data-width="2016" data-height="1008" src="https://cdn-images-1.medium.com/max/800/1*YiSwE3xBUVdnzLfy9GlqGA.png"></figure><p name="7d29" id="7d29" class="graf graf--p graf-after--figure">既然有讀取 container 裡 dictionary 的 nestedContainer，當然也有讀取 container 裡 array 的 nestedUnkeyedContainer，比方以下 iTunes API 的例子。</p><pre name="7210" id="7210" class="graf graf--pre graf-after--p"><a href="https://itunes.apple.com/search?term=" data-href="https://itunes.apple.com/search?term=" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://itunes.apple.com/search?term=</a>小球&amp;media=music&amp;country=TW</pre><p name="b0cb" id="b0cb" class="graf graf--p graf-after--pre">JSON 內容如下</p><figure name="8d3b" id="8d3b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BT8GAEc7LvC6RMmUIn3RrA.jpeg" data-width="1070" data-height="1008" src="https://cdn-images-1.medium.com/max/800/1*BT8GAEc7LvC6RMmUIn3RrA.jpeg"></figure><p name="5179" id="5179" class="graf graf--p graf-after--figure">若是自訂型別的架構和 JSON 一致，我們可以透過以下程式將 JSON 轉換成 SearchResponse。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="54b4" id="54b4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StoreItem</span> {<br />    <span class="hljs-keyword">let</span> artistName: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> trackName: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">StoreItem</span>: <span class="hljs-title class_">Codable</span> { }<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SearchResponse</span> {<br />    <span class="hljs-keyword">var</span> results: [<span class="hljs-type">StoreItem</span>]<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SearchResponse</span>: <span class="hljs-title class_">Codable</span> { }<br /><br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> urlString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://itunes.apple.com/search?term=小球&amp;media=music&amp;country=TW&quot;</span>.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),<br />   <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> searchResponse <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">SearchResponse</span>.<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-built_in">print</span>(searchResponse)<br />            } <span class="hljs-keyword">catch</span>  {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><p name="2415" id="2415" class="graf graf--p graf-after--pre">不過為了學習 nestedUnkeyedContainer，讓我們認識以下比較複雜的寫法。值得注意的，我們定義了兩個遵從 CodingKey 的型別，SearchResponse 對應 JSON 第一層 dictionary 的 key，StoreItemKeys 對應 results array 裡 dictionary 的 key。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="4dd5" id="4dd5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StoreItem</span> {<br />    <span class="hljs-keyword">let</span> artistName: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> trackName: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">StoreItem</span>: <span class="hljs-title class_">Codable</span> { }<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SearchResponse</span> {<br />    <span class="hljs-keyword">var</span> storeItems: [<span class="hljs-type">StoreItem</span>]<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SearchResponse</span>: <span class="hljs-title class_">Codable</span> {<br />    <br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SearchResponseKeys</span>: <span class="hljs-title class_">CodingKey</span> {<br />        <span class="hljs-keyword">case</span> results<br />    }<br />    <br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">StoreItemKeys</span>: <span class="hljs-title class_">CodingKey</span> {<br />        <span class="hljs-keyword">case</span> artistName, trackName<br />    }<br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        storeItems <span class="hljs-operator">=</span> [<span class="hljs-type">StoreItem</span>]()<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">SearchResponseKeys</span>.<span class="hljs-keyword">self</span>)<br />        <span class="hljs-keyword">var</span> itemsContainer <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.nestedUnkeyedContainer(forKey: .results)<br />        <span class="hljs-keyword">while</span> <span class="hljs-operator">!</span>itemsContainer.isAtEnd {<br />            <span class="hljs-keyword">let</span> itemContainer <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> itemsContainer.nestedContainer(keyedBy: <span class="hljs-type">StoreItemKeys</span>.<span class="hljs-keyword">self</span>)<br />            <span class="hljs-keyword">let</span> artistName <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> itemContainer.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .artistName)<br />            <span class="hljs-keyword">let</span> trackName <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> itemContainer.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .trackName)<br />            <span class="hljs-keyword">let</span> song <span class="hljs-operator">=</span> <span class="hljs-type">StoreItem</span>(artistName: artistName, trackName: trackName)<br />            storeItems.append(song)<br />        }<br />    }<br />}</span></pre><h3 name="4545" id="4545" class="graf graf--h3 graf-after--pre">不固定數量和名字的 key</h3><p name="3617" id="3617" class="graf graf--p graf-after--h3">前面我們看到的 API，它們的 JSON dictionary key 都是固定的數量和名字，所以我們知道如何抄襲，明白如何在遵從 Decodable &amp; 遵從 CodingKey 的自訂型別裡宣告 property &amp; case。</p><p name="3783" id="3783" class="graf graf--p graf-after--p">但如果 key 的數量和名字是不固定的呢 ? 比方以下的動森 API。</p><pre name="dbcf" id="dbcf" class="graf graf--pre graf-after--p">https://acnhapi.com/v1/villagers</pre><p name="46f5" id="46f5" class="graf graf--p graf-after--pre">以下為 JSON 的內容。</p><figure name="d0c2" id="d0c2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Isvw55zP7mqI7DlgrLnoDA.jpeg" data-width="1104" data-height="1224" src="https://cdn-images-1.medium.com/max/800/1*Isvw55zP7mqI7DlgrLnoDA.jpeg"></figure><figure name="1057" id="1057" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*0KaoB1MdkOTy2f7_vLAPiQ.jpeg" data-width="1078" data-height="1144" src="https://cdn-images-1.medium.com/max/800/1*0KaoB1MdkOTy2f7_vLAPiQ.jpeg"></figure><p name="5e3a" id="5e3a" class="graf graf--p graf-after--figure">此 API 將回傳動森的村民清單，因此我們希望能取得村民的 array，顯示類似以下的畫面。</p><figure name="2c88" id="2c88" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Vco2IB5-K0fMb8uiY97S4Q.jpeg" data-width="896" data-height="1652" src="https://cdn-images-1.medium.com/max/800/1*Vco2IB5-K0fMb8uiY97S4Q.jpeg"></figure><div name="6c8e" id="6c8e" class="graf graf--mixtapeEmbed graf-after--figure"><a href="https://github.com/Dimillian/ACHNBrowserUI" data-href="https://github.com/Dimillian/ACHNBrowserUI" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/Dimillian/ACHNBrowserUI"><strong class="markup--strong markup--mixtapeEmbed-strong">Dimillian/ACHNBrowserUI</strong><br><em class="markup--em markup--mixtapeEmbed-em">You can now download the app on the App Store! The best Animal Crossing New Horizons companion app! 最高の「あつまれ…</em>github.com</a><a href="https://github.com/Dimillian/ACHNBrowserUI" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="1de187392286a768808e796c48d958e3" data-thumbnail-img-id="0*ZVNT1aB3yk7PV0YB" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*ZVNT1aB3yk7PV0YB);"></a></div><p name="f23b" id="f23b" class="graf graf--p graf-after--mixtapeEmbed">像這種比較特別的 JSON，我們有以下兩種解析的方法:</p><ul class="postList"><li name="d507" id="d507" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">方法1: 先解析成 dictionary，再將 dictionary 的 value 組合成 array</strong></li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="5861" id="5861" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Villager</span>: <span class="hljs-title class_">Codable</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> gender: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> icon_uri: <span class="hljs-type">URL</span><br />}<br /><br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://acnhapi.com/v1/villagers&quot;</span>) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> villagersDic <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode([String: <span class="hljs-type">Villager</span>].<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-keyword">let</span> villagers <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(villagersDic.values)<br />                <span class="hljs-built_in">print</span>(villagers)<br />            } <span class="hljs-keyword">catch</span> {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><figure name="3120" id="3120" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*Q6eJ4ZG13w230L7jXb5hOA.jpeg" data-width="2360" data-height="304" src="https://cdn-images-1.medium.com/max/800/1*Q6eJ4ZG13w230L7jXb5hOA.jpeg"></figure><p name="fced" id="fced" class="graf graf--p graf-after--figure">不過 dictionary 沒有順序性，因此我們每次組合產生的 array 順序都不一樣。若是希望使用者看到固定的順序，可使用 sorted 排序，比方以下例子利用 id 排序，數字大的 id 在前面。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0ba0" id="0ba0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://acnhapi.com/v1/villagers&quot;</span>) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> villagersDic <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode([String: <span class="hljs-type">Villager</span>].<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-keyword">let</span> villagers <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(villagersDic.values).sorted {<br />                    <span class="hljs-variable">$0</span>.id <span class="hljs-operator">&gt;</span> <span class="hljs-variable">$1</span>.id<br />                }<br />                <span class="hljs-built_in">print</span>(villagers)<br />            } <span class="hljs-keyword">catch</span> {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><figure name="0be2" id="0be2" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*rbDOO6fg7afqwHNQc1l81w.jpeg" data-width="2380" data-height="356" src="https://cdn-images-1.medium.com/max/800/1*rbDOO6fg7afqwHNQc1l81w.jpeg"></figure><ul class="postList"><li name="e7be" id="e7be" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">方法2 : 自訂 init(from:) 解析 JSON</strong></li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="b7c9" id="b7c9" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Villager</span> {<br />    <span class="hljs-keyword">let</span> id: <span class="hljs-type">Int</span><br />    <span class="hljs-keyword">let</span> gender: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> icon_uri: <span class="hljs-type">URL</span><br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Villager</span>: <span class="hljs-title class_">Decodable</span> { }<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VillagersResponse</span> {<br />    <span class="hljs-keyword">var</span> villagers: [<span class="hljs-type">Villager</span>]<br />}<br /><br /><span class="hljs-keyword">extension</span> <span class="hljs-title class_">VillagersResponse</span>: <span class="hljs-title class_">Decodable</span> {<br />    <br />    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CodingKeys</span>: <span class="hljs-title class_">CodingKey</span> {<br />        <span class="hljs-keyword">var</span> intValue: <span class="hljs-type">Int</span>?<br />        <span class="hljs-keyword">init?</span>(<span class="hljs-params">intValue</span>: <span class="hljs-type">Int</span>) {<br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br />        }<br />        <span class="hljs-keyword">var</span> stringValue: <span class="hljs-type">String</span><br />        <span class="hljs-keyword">init?</span>(<span class="hljs-params">stringValue</span>: <span class="hljs-type">String</span>) {<br />            <span class="hljs-keyword">self</span>.stringValue <span class="hljs-operator">=</span> stringValue<br />        }<br />    }<br />    <br />    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> {<br />        villagers <span class="hljs-operator">=</span> [<span class="hljs-type">Villager</span>]()<br />        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br />        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> container.allKeys {<br />            <span class="hljs-keyword">let</span> villager <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">Villager</span>.<span class="hljs-keyword">self</span>, forKey: key)<br />            villagers.append(villager)<br />        }<br />    }<br />}</span></pre><p name="e23f" id="e23f" class="graf graf--p graf-after--pre">以上的程式有個很特別的地方，我們以 struct 遵從 CodingKey，而不是 enum。因為 JSON 裡 dictionary 的 key 是不固定的，我們沒辦法以 enum 的 case 列出每一種可能的 key，所以我們改用 struct 定義，然後定義 CodingKey 需要實作的變數和 init。此處最重要的是以下程式，它將讓 dictionary 的 key 成為 container 的 key。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="5f63" id="5f63" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">init?</span>(<span class="hljs-params">stringValue</span>: <span class="hljs-type">String</span>) {<br />    <span class="hljs-keyword">self</span>.stringValue <span class="hljs-operator">=</span> stringValue<br />}</span></pre><p name="8594" id="8594" class="graf graf--p graf-after--pre">當我們用 <code class="markup--code markup--p-code">try decoder.container(keyedBy: CodingKeys.self) </code>得到包含 dictionary 的 container 後，將可用 <code class="markup--code markup--p-code">for key in container.allKeys</code> 讀取每一個 key 對應的內容，將它們 decode 成 Villager 後加到 array 。</p><p name="87eb" id="87eb" class="graf graf--p graf-after--p">利用 JSONDecoder 將 JSON 資料變成型別 VillagersResponse。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c3c1" id="c3c1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://acnhapi.com/v1/villagers&quot;</span>) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data {<br />            <span class="hljs-keyword">do</span> {<br />                <span class="hljs-keyword">let</span> villagersResponse <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">VillagersResponse</span>.<span class="hljs-keyword">self</span>, from: data)<br />                <span class="hljs-built_in">print</span>(villagersResponse.villagers)<br />            } <span class="hljs-keyword">catch</span> {<br />                <span class="hljs-built_in">print</span>(error)<br />            }<br />        }<br />    }.resume()<br />}</span></pre><h3 name="d2ff" id="d2ff" class="graf graf--h3 graf-after--pre">利用 CodingKey &amp; init(from:) 將不同的 JSON key 對應到同一個 property</h3><div name="cf25" id="cf25" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-codingkey-init-from-%E5%B0%87%E4%B8%8D%E5%90%8C%E7%9A%84-json-key-%E5%B0%8D%E6%87%89%E5%88%B0%E5%90%8C%E4%B8%80%E5%80%8B-property-f73438fdda10" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-codingkey-init-from-%E5%B0%87%E4%B8%8D%E5%90%8C%E7%9A%84-json-key-%E5%B0%8D%E6%87%89%E5%88%B0%E5%90%8C%E4%B8%80%E5%80%8B-property-f73438fdda10" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-codingkey-init-from-%E5%B0%87%E4%B8%8D%E5%90%8C%E7%9A%84-json-key-%E5%B0%8D%E6%87%89%E5%88%B0%E5%90%8C%E4%B8%80%E5%80%8B-property-f73438fdda10"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 CodingKey &amp; init(from:) 將不同的 JSON key 對應到同一個 property</strong><br><em class="markup--em markup--mixtapeEmbed-em">串接 JSON API 時，有時我們會遇到 JSON 的某個 key 名字有多種可能，而我們希望能將它們對應到同一個 property。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-codingkey-init-from-%E5%B0%87%E4%B8%8D%E5%90%8C%E7%9A%84-json-key-%E5%B0%8D%E6%87%89%E5%88%B0%E5%90%8C%E4%B8%80%E5%80%8B-property-f73438fdda10" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="62aa8cd9fd20cc4bb3597318f156c48e" data-thumbnail-img-id="1*-S8FMTFV4vtKvhzbZxfHWw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*-S8FMTFV4vtKvhzbZxfHWw.png);"></a></div><h3 name="3503" id="3503" class="graf graf--h3 graf-after--mixtapeEmbed">透過 init(from:) 解析 JSON 裡包裝成字串的 array 或 dictionary</h3><div name="c965" id="c965" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E9%80%8F%E9%81%8E-init-from-%E8%A7%A3%E6%9E%90-json-%E8%A3%A1%E5%8C%85%E8%A3%9D%E6%88%90%E5%AD%97%E4%B8%B2%E7%9A%84-array-%E6%88%96-dictionary-8a450227c39e" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E9%80%8F%E9%81%8E-init-from-%E8%A7%A3%E6%9E%90-json-%E8%A3%A1%E5%8C%85%E8%A3%9D%E6%88%90%E5%AD%97%E4%B8%B2%E7%9A%84-array-%E6%88%96-dictionary-8a450227c39e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E9%80%8F%E9%81%8E-init-from-%E8%A7%A3%E6%9E%90-json-%E8%A3%A1%E5%8C%85%E8%A3%9D%E6%88%90%E5%AD%97%E4%B8%B2%E7%9A%84-array-%E6%88%96-dictionary-8a450227c39e"><strong class="markup--strong markup--mixtapeEmbed-strong">透過 init(from:) 解析 JSON 裡包裝成字串的 array 或 dictionary</strong><br><em class="markup--em markup--mixtapeEmbed-em">透過 JSONDecoder，我們可以將 JSON 資料變成自訂的型別。不過當 JSON 裡 array 或 dictionary 被包裝成字串時，解析上將麻煩許多。例如以下英國 COVID-19 API 的 JSON。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E9%80%8F%E9%81%8E-init-from-%E8%A7%A3%E6%9E%90-json-%E8%A3%A1%E5%8C%85%E8%A3%9D%E6%88%90%E5%AD%97%E4%B8%B2%E7%9A%84-array-%E6%88%96-dictionary-8a450227c39e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="2f66f3b7e33d85ba0dbc3ef1a2db43a3" data-thumbnail-img-id="1*A1Zz9EmCEFUb07dX0zb1vQ.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*A1Zz9EmCEFUb07dX0zb1vQ.jpeg);"></a></div><h3 name="7202" id="7202" class="graf graf--h3 graf-after--mixtapeEmbed">其它參考範例</h3><p name="b87e" id="b87e" class="graf graf--p graf-after--h3">Apple 的 Decoding structured JSON。</p><div name="fbaf" id="fbaf" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://developer.apple.com/tutorials/app-dev-training/decoding-structured-json" data-href="https://developer.apple.com/tutorials/app-dev-training/decoding-structured-json" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/tutorials/app-dev-training/decoding-structured-json"><strong class="markup--strong markup--mixtapeEmbed-strong">Decoding structured JSON | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">In this tutorial, you&#39;ll use Swift APIs to decode earthquake information that the USGS provides. The USGS encodes the…</em>developer.apple.com</a><a href="https://developer.apple.com/tutorials/app-dev-training/decoding-structured-json" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c4781365295942bde35997b91eb4ca3e" data-thumbnail-img-id="0*WDHsrVlNxwf12c4t" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*WDHsrVlNxwf12c4t);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/f9c8d420cda4"><time class="dt-published" datetime="2020-05-30T15:18:19.612Z">May 30, 2020</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E8%87%AA%E8%A8%82-init-from-decoder-%E8%A7%A3%E6%9E%90-json-f9c8d420cda4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>