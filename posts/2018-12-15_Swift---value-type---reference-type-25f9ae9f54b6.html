<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift 的 value type 和 reference type</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift 的 value type 和 reference type</h1>
</header>
<section data-field="subtitle" class="p-summary">
在 Swift 裡，型別分成 value type 和 reference type。struct，enum 和 tuple 是 value type，而 class，function 和 closure 則是 reference…
</section>
<section data-field="body" class="e-content">
<section name="c280" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="40a0" id="40a0" class="graf graf--h3 graf--leading graf--title">Swift 的 <strong class="markup--strong markup--h3-strong">value type 和 reference type</strong></h3><figure name="c6f1" id="c6f1" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*j4YPbf9cS54TQgFd" data-width="1024" data-height="1536" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*j4YPbf9cS54TQgFd"></figure><p name="5b5e" id="5b5e" class="graf graf--p graf-after--figure">在 Swift 裡，型別分成 value type 和 reference type。struct，enum 和 tuple 是 value type，而 class，function 和 closure 則是 reference type。當我們設定變數(常數)儲存的內容時，這兩種 type 將產生莫大的差別。</p><p name="d393" id="d393" class="graf graf--p graf-after--p">傳說 value type 將從原本的資料複製產生新的資料，reference type 則是共享同一份資料。到底這是什麼意思呢 ? 由於 Swift 裡常見的型別，諸如 Int，String，Array 等都是 struct 定義的 value type，我們就從 value type 開始介紹吧。</p><blockquote name="800d" id="800d" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">struct 定義的型別是 value type</strong></blockquote><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="af81" id="af81" class="graf graf--pre graf-after--blockquote graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br />   <span class="hljs-keyword">var</span> weight <span class="hljs-operator">=</span> <span class="hljs-number">10.5</span><br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby1 <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><span class="hljs-keyword">var</span> cuteBaby2 <span class="hljs-operator">=</span> cuteBaby1<br />cuteBaby1.weight <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br />cuteBaby1.weight<br />cuteBaby2.weight</span></pre><p name="dcec" id="dcec" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="fd30" id="fd30" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7lUriFkqA2oYaIaqlABwTA.jpeg" data-width="510" data-height="370" src="https://cdn-images-1.medium.com/max/800/1*7lUriFkqA2oYaIaqlABwTA.jpeg"><figcaption class="imageCaption">struct 型別的 cuteBaby1 和 cuteBaby2 佔據不同記憶體空間，互不干擾</figcaption></figure><p name="148f" id="148f" class="graf graf--p graf-after--figure">struct 型別 Baby 宣告的 cuteBaby1 和 cuteBaby2 佔據不同記憶體空間，彼此互不干擾。當程式執行 <code class="markup--code markup--p-code">var cuteBaby2 = cuteBaby1</code> 時，將另外配置一塊記憶體空間給 cuteBaby2，然後再把 cuteBaby1 的內容填入 cuteBaby2。而當 cuteBaby1 的 age 改變時，並不會影響 cuteBaby2 的 age。</p><p name="140b" id="140b" class="graf graf--p graf-after--p">這就是 value type 的特性，當我們設定 value type 的變數等於另一個變數時，它將複製(copy)內容到另一個記憶體空間，讓它們一開始的內容一樣。但畢竟它們是不同的東西，所以之後依然有可能不一樣，就好像彼得潘跟梁朝偉剛出生時，其實長得一樣。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0961" id="0961" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> 彼得潘 <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><span class="hljs-keyword">var</span> 梁朝偉 <span class="hljs-operator">=</span> 彼得潘</span></pre><figure name="cd60" id="cd60" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*W0rOj2kHnb7mqwC_2bennQ.jpeg" data-width="1188" data-height="600" src="https://cdn-images-1.medium.com/max/800/1*W0rOj2kHnb7mqwC_2bennQ.jpeg"><figcaption class="imageCaption">想當年1 歲時，彼得潘跟梁朝偉長得一模一樣</figcaption></figure><p name="8ea0" id="8ea0" class="graf graf--p graf-after--figure">誰知男大十八變，過了二十年，他們的帥度和體重有了很大的差別。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="4a5f" id="4a5f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">彼得潘.weight <span class="hljs-operator">=</span> <span class="hljs-number">55</span><br />梁朝偉.weight <span class="hljs-operator">=</span> <span class="hljs-number">65</span></span></pre><figure name="05a1" id="05a1" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*i945FOi2huhmbh4Et4yyUw.jpeg" data-width="1184" data-height="596" src="https://cdn-images-1.medium.com/max/800/1*i945FOi2huhmbh4Et4yyUw.jpeg"><figcaption class="imageCaption">過了二十年，景物依舊，人事已非，彼得潘跟梁朝偉變得不太一樣了</figcaption></figure><blockquote name="9c9b" id="9c9b" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">Int，String，Array 由 struct 定義。</strong></blockquote><p name="be8f" id="be8f" class="graf graf--p graf-after--blockquote">Swift 的基本型別，諸如 Int，String，Array，皆由 struct 定義。</p></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="f6cd" id="f6cd" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--p" style="width: 50.926%;"><img class="graf-image" data-image-id="1*Wbh73LIaUHg2Mp0hSPdrFA.jpeg" data-width="1384" data-height="680" src="https://cdn-images-1.medium.com/max/800/1*Wbh73LIaUHg2Mp0hSPdrFA.jpeg"></figure><figure name="9f4a" id="9f4a" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 49.074%;"><img class="graf-image" data-image-id="1*8fwEVBUampUdjB3qiDru_g.jpeg" data-width="1322" data-height="674" src="https://cdn-images-1.medium.com/max/600/1*8fwEVBUampUdjB3qiDru_g.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="68dd" id="68dd" class="graf graf--p graf-after--figure">因此以下字串的例子，當程式執行 <code class="markup--code markup--p-code">var hookGirlFriend = peterGirlFriend</code> 時，將另外配置一塊記憶體空間給 hookGirlFriend，然後再把 peterGirlFriend 的內容填入 hookGirlFriend。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="fe28" id="fe28" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> peterGirlFriend <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wendy&quot;</span><br /><span class="hljs-keyword">var</span> hookGirlFriend <span class="hljs-operator">=</span> peterGirlFriend<br />hookGirlFriend <span class="hljs-operator">=</span> <span class="hljs-string">&quot;虎姑婆&quot;</span><br /><span class="hljs-keyword">var</span> message <span class="hljs-operator">=</span> <span class="hljs-string">&quot;彼得潘的女朋友是<span class="hljs-subst">\(peterGirlFriend)</span>，虎克船長的女朋友是<span class="hljs-subst">\(hookGirlFriend)</span>&quot;</span></span></pre><p name="e64e" id="e64e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="9534" id="9534" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pS6JfIIIcAnilmC1c0Jcww.jpeg" data-width="1312" data-height="328" src="https://cdn-images-1.medium.com/max/800/1*pS6JfIIIcAnilmC1c0Jcww.jpeg"><figcaption class="imageCaption">字串型別的 peterGirlFriend 和 hookGirlFriend 佔據不同記憶體空間</figcaption></figure><p name="9cc5" id="9cc5" class="graf graf--p graf-after--figure">從以上例子，我們看到一個動人心弦的愛情故事。彼得潘和虎克船長的初戀女朋友其實是不同的人，只是名字剛好都叫 wendy。之後當花心的虎克船長換女朋友，變成和虎姑婆在一起時，彼得潘依然專一，還是跟wendy 在一起。hookGirlFriend 和 peterGirlFriend 分別佔據不同的記憶體空間，當我們修改其中一個的內容時，並不影響另一個。</p><blockquote name="c023" id="c023" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">class 定義的型別是 reference type</strong></blockquote><p name="a920" id="a920" class="graf graf--p graf-after--blockquote">接著讓我們看看 reference type 的代表，class 的例子。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0d6d" id="0d6d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br />   <span class="hljs-keyword">var</span> weight <span class="hljs-operator">=</span> <span class="hljs-number">10.5</span><br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby1 <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><span class="hljs-keyword">var</span> cuteBaby2 <span class="hljs-operator">=</span> cuteBaby1<br />cuteBaby1.weight <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br />cuteBaby1.weight<br />cuteBaby2.weight</span></pre><p name="918c" id="918c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="c7a6" id="c7a6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BCN3ZutjjfeBVqq8yrJUuw.jpeg" data-width="504" data-height="354" src="https://cdn-images-1.medium.com/max/800/1*BCN3ZutjjfeBVqq8yrJUuw.jpeg"><figcaption class="imageCaption">class 型別的 cuteBaby1 和 cuteBaby2 指到同一個寶寶物件</figcaption></figure><p name="77a8" id="77a8" class="graf graf--p graf-after--figure">當我們設定 reference type 的變數等於另一個變數時，它們將儲存同一個記憶體位址，此時兩個變數指到同一個資料。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="db4e" id="db4e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> cuteBaby1 <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><span class="hljs-keyword">var</span> cuteBaby2 <span class="hljs-operator">=</span> cuteBaby1</span></pre><p name="518f" id="518f" class="graf graf--p graf-after--pre">當程式執行 <code class="markup--code markup--p-code">var cuteBaby2 = cuteBaby1</code> 時，將如下圖所示，cuteBaby1 &amp; cuteBaby2 指到同一個寶寶，因此 cuteBaby1.weight &amp; cuteBaby2.weight 都是 10.5。</p><figure name="8472" id="8472" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Z5fo2VSOjkEKqdDtgscGMw.jpeg" data-width="1162" data-height="612" src="https://cdn-images-1.medium.com/max/800/1*Z5fo2VSOjkEKqdDtgscGMw.jpeg"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7fb8" id="7fb8" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content">cuteBaby1.weight <span class="hljs-operator">=</span> <span class="hljs-number">20</span></span></pre><p name="8982" id="8982" class="graf graf--p graf-after--pre">修改其中一個變數的屬性也等於修改另一個。因此 <code class="markup--code markup--p-code">cuteBaby1.weight = 20</code> 將讓 cuteBaby2.weight 也變成 20。</p><figure name="1db1" id="1db1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4_2h8kudKuXTiQMS9AJRZQ.jpeg" data-width="1362" data-height="758" src="https://cdn-images-1.medium.com/max/800/1*4_2h8kudKuXTiQMS9AJRZQ.jpeg"></figure><p name="0780" id="0780" class="graf graf--p graf-after--figure">剛剛的程式，其實可用實現世界的例子來想像。這就像同一個人有不同的名字，比方彼得潘在江湖中的另一個名字是忠孝新生梁朝偉。</p><blockquote name="43a0" id="43a0" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">當 optional binding 遇上 value type 和 reference type</strong></blockquote><p name="8074" id="8074" class="graf graf--p graf-after--blockquote">當結合 optional binding 時，value type 和 reference type 也有很大的差異。例如以下例子，以 struct 定義 Baby 時，optional binding 的 <code class="markup--code markup--p-code">if var anotherBaby = cuteBaby</code> 將產生複製的效果，anotherBaby 和 cuteBaby 是不同的寶寶。因此雖然 anotherBaby 改名為 Andy，cuteBaby 依然叫 Peter。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6c80" id="6c80" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Peter&quot;</span><br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby: <span class="hljs-type">Baby</span>? <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> anotherBaby <span class="hljs-operator">=</span> cuteBaby {<br />   anotherBaby.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Andy&quot;</span><br />}<br />cuteBaby<span class="hljs-operator">?</span>.name</span></pre><p name="08a3" id="08a3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="f1dc" id="f1dc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*TStFG6bdMLijQb8whzw57g.jpeg" data-width="420" data-height="190" src="https://cdn-images-1.medium.com/max/800/1*TStFG6bdMLijQb8whzw57g.jpeg"></figure><p name="2f5f" id="2f5f" class="graf graf--p graf-after--figure">以 class 定義 Baby 時，optional binding 將讓 anotherBaby 和 cuteBaby 指到同一個寶寶，名字都變成 Andy。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1b8d" id="1b8d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Peter&quot;</span><br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby: <span class="hljs-type">Baby</span>? <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> anotherBaby <span class="hljs-operator">=</span> cuteBaby {<br />   anotherBaby.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Andy&quot;</span><br />}<br />cuteBaby<span class="hljs-operator">?</span>.name</span></pre><p name="4bb4" id="4bb4" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="efa3" id="efa3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_aGAUSWl97nHfoK0q9EOFg.jpeg" data-width="418" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*_aGAUSWl97nHfoK0q9EOFg.jpeg"></figure><blockquote name="c650" id="c650" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">value type &amp; reference type 的記憶體用量</strong></blockquote><p name="3165" id="3165" class="graf graf--p graf-after--blockquote">關於 value type 複製，reference type 共享同一份資料的概念，我們也可透過以下的小實驗，觀察記憶體用量得知。</p><p name="d75d" id="d75d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">當 Baby 是 value type</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="33a1" id="33a1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> heyJude <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;hey jude &quot;</span>, count: <span class="hljs-number">1000</span>)<br />   <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />   <span class="hljs-keyword">var</span> cuteBaby <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br />   <span class="hljs-keyword">var</span> babies <span class="hljs-operator">=</span> [<span class="hljs-type">Baby</span>]()<br /><br />   <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />      <span class="hljs-keyword">super</span>.viewDidLoad()<br />      <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3000</span> {<br />         <span class="hljs-keyword">var</span> newBaby <span class="hljs-operator">=</span> cuteBaby<br />         newBaby.heyJude <span class="hljs-operator">+=</span> <span class="hljs-string">&quot;hey peter&quot;</span> <br />         babies.append(newBaby)<br />      }<br />   }<br />}</span></pre><p name="308c" id="308c" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">var newBaby = cuteBaby</code> 將複製產生一個新的寶寶，所以最後 array 裡將裝著 3000 個可愛的寶寶。</p><p name="0ed3" id="0ed3" class="graf graf--p graf-after--p">App 執行後，如下圖所示，一下子生了那麼多的寶寶，記憶體急速上升到七十幾MB。</p><figure name="7dcf" id="7dcf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bevcaFmwZar1II76cBLWIA.jpeg" data-width="1568" data-height="532" src="https://cdn-images-1.medium.com/max/800/1*bevcaFmwZar1II76cBLWIA.jpeg"></figure><p name="d133" id="d133" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">當 Baby 是 reference type</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="86a2" id="86a2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> heyJude <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;hey jude &quot;</span>, count: <span class="hljs-number">1000</span>)<br />   <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br />}</span></pre><p name="39e6" id="39e6" class="graf graf--p graf-after--pre">程式碼和剛剛一模一樣，只是 Baby 變成 class 定義的 reference type，所以 <code class="markup--code markup--p-code">let newBaby = cuteBaby</code> 的 newBaby 和 cuteBaby 將指到同一個寶寶 ，最後 array 裡存著同一個寶寶。</p><p name="fc74" id="fc74" class="graf graf--p graf-after--p">App 執行後，如下圖所示，由於只有一個寶寶，記憶體比剛剛少了許多，只有四十幾 MB。</p><figure name="72ba" id="72ba" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MPwner-BkOFP2jclI96Z2Q.jpeg" data-width="1536" data-height="522" src="https://cdn-images-1.medium.com/max/800/1*MPwner-BkOFP2jclI96Z2Q.jpeg"></figure><blockquote name="fb6a" id="fb6a" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">讓 value type 效能更好的 copy on write</strong></blockquote><p name="1a52" id="1a52" class="graf graf--p graf-after--blockquote">也許有人會想到，value type 每次都要複製，效能應該會比較不好。不過其實不用太擔心，Swift 很聰明，針對某些 value type 它應用 copy on write 的技巧讓效能更好。</p><p name="56c8" id="56c8" class="graf graf--p graf-after--p">像 String 型別即運用了 copy on write 的技巧，因此它不會馬上複製，它只在內容修改時才進行複製。以剛剛我們用 struct 定義 Baby，for 迴圈生 3000 個寶寶的例子，以下程式碼並不會讓記憶體成長到七十幾 MB，因為 Baby 的屬性 heyJude 是字串型別，一開始 3000 個寶寶的 heyJude 的內容和 cuteBaby 的 heyJude 一樣，所以 3000 個 newBaby 的 heyJude 可以先讀取 cuteBaby 的 heyJude，還不用複製產生新的 heyJude 字串。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d8f7" id="d8f7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3000</span> {<br />   <span class="hljs-keyword">var</span> newBaby <span class="hljs-operator">=</span> cuteBaby<br />   babies.append(newBaby)<br />}</span></pre><p name="375d" id="375d" class="graf graf--p graf-after--pre">然而若我們修改了 newBaby 的 heyJude，此時 copy on write 將被啟動，於是將複製產生 3000 個 heyJude 的字串，讓記憶體上升到七十幾 MB。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8ce6" id="8ce6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">3000</span> {<br />   <span class="hljs-keyword">var</span> newBaby <span class="hljs-operator">=</span> cuteBaby<br />   newBaby.heyJude <span class="hljs-operator">+=</span> <span class="hljs-string">&quot;hey peter&quot;</span><br />   babies.append(newBaby)<br />}</span></pre><blockquote name="0c8f" id="0c8f" class="graf graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">reference type 和 value type 的常數</strong></blockquote><p name="2342" id="2342" class="graf graf--p graf-after--blockquote">當以 let 宣告的常數指到物件時，物件的屬性依然可以修改。因此以下例子的 superIdol 可以改名為小王子，年紀也可以從 18 增長為 20。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="772a" id="772a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Idol</span> {<br />   <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br />   <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) {<br />      <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br />   }<br />}<br /><br /><span class="hljs-keyword">let</span> superIdol <span class="hljs-operator">=</span> <span class="hljs-type">Idol</span>(name: <span class="hljs-string">&quot;彼得潘&quot;</span>)<br />superIdol.age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br />superIdol.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小王子&quot;</span></span></pre><figure name="a820" id="a820" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*z2zoG-w_gi3bHdGNaqRtwA.jpeg" data-width="1282" data-height="748" src="https://cdn-images-1.medium.com/max/800/1*z2zoG-w_gi3bHdGNaqRtwA.jpeg"><figcaption class="imageCaption">class 型別的常數可以改變屬性的內容</figcaption></figure><p name="6650" id="6650" class="graf graf--p graf-after--figure">不能變的是此常數儲存的物件記憶體位址，它必須永遠指著同一個物件，因此我們不能用 <code class="markup--code markup--p-code">superIdol = Idol(name: &quot;虎克&quot;)</code> 將偶像改成虎克。</p><figure name="0f69" id="0f69" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nit69M3MLhqyIje6rn_yhQ.jpeg" data-width="1352" data-height="324" src="https://cdn-images-1.medium.com/max/800/1*nit69M3MLhqyIje6rn_yhQ.jpeg"></figure><figure name="ac13" id="ac13" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*0IDL8gPM-CleHklyvTxHjQ.jpeg" data-width="1300" data-height="866" src="https://cdn-images-1.medium.com/max/800/1*0IDL8gPM-CleHklyvTxHjQ.jpeg"><figcaption class="imageCaption">class 型別的常數儲存物件的記憶體位址，不能重新指定新的物件</figcaption></figure><p name="863e" id="863e" class="graf graf--p graf-after--figure">然而這是 reference type 的規則，如果是 value type，限制將會更多。value type 的常數本身就是資料，因此資料的屬性也不能修改，例如以下例子：</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f9f4" id="f9f4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Idol</span> {<br />   <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br />   <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) {<br />      <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br />   }<br />}<br /><span class="hljs-keyword">let</span> superIdol <span class="hljs-operator">=</span> <span class="hljs-type">Idol</span>(name: <span class="hljs-string">&quot;彼得潘&quot;</span>)<br />superIdol.age <span class="hljs-operator">=</span> <span class="hljs-number">20</span></span></pre><p name="d15c" id="d15c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="e6de" id="e6de" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WmZQT50HZXSlsJ9scUb7_w.jpeg" data-width="1368" data-height="302" src="https://cdn-images-1.medium.com/max/800/1*WmZQT50HZXSlsJ9scUb7_w.jpeg"><figcaption class="imageCaption">struct 型別的常數連屬性也無法修改</figcaption></figure><blockquote name="a8e1" id="a8e1" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">array &amp; dictionary 是 value type</strong></blockquote><p name="d9d1" id="d9d1" class="graf graf--p graf-after--blockquote">Swift 的 array &amp; dictionary 皆由 struct 定義，屬於 value type。當我們設定 array A 等於 array B 時，將複製產生一個新的 array。然而 array 的成員是 value type 還是 reference type，將讓程式的結果有很大的差別。</p><p name="919e" id="919e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">當 array 成員為 value type</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="dedb" id="dedb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br />}<br /><br /><span class="hljs-keyword">var</span> names1 <span class="hljs-operator">=</span> [<span class="hljs-type">Baby</span>(name: <span class="hljs-string">&quot;彼得潘&quot;</span>), <span class="hljs-type">Baby</span>(name: <span class="hljs-string">&quot;虎克&quot;</span>)]<br /><span class="hljs-keyword">var</span> names2 <span class="hljs-operator">=</span> names1<br />names2[<span class="hljs-number">0</span>].name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;蜘蛛人&quot;</span><br />names2[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>(name: <span class="hljs-string">&quot;蝙蝠俠&quot;</span>)</span></pre><p name="60af" id="60af" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="bac3" id="bac3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bE766Enrn53MevRU8Wi72g.jpeg" data-width="560" data-height="518" src="https://cdn-images-1.medium.com/max/800/1*bE766Enrn53MevRU8Wi72g.jpeg"><figcaption class="imageCaption">此時有 2 個 array，4 個寶寶</figcaption></figure><p name="5566" id="5566" class="graf graf--p graf-after--figure">array 的成員是 struct 定義的 Baby，屬於 value type，執行 <code class="markup--code markup--p-code">var names2 = names1</code> 時，names1 的成員將複製一份，塞到 names2。此時兩個 array 互相獨立，array 裡的成員也毫無瓜葛。</p><figure name="e430" id="e430" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ys79NH440QY5bPibZaK4Wg.jpeg" data-width="1290" data-height="458" src="https://cdn-images-1.medium.com/max/800/1*ys79NH440QY5bPibZaK4Wg.jpeg"><figcaption class="imageCaption">此時有 2 個 array，4 個寶寶。</figcaption></figure><p name="81bc" id="81bc" class="graf graf--p graf-after--figure">之後不管我們修改 names2[0] 的屬性， 或是換掉 names2[1] 的成員，都不會影響 names1。</p><figure name="b48a" id="b48a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*yXWH-tArYJyOob0Xtr3S0w.jpeg" data-width="1284" data-height="454" src="https://cdn-images-1.medium.com/max/800/1*yXWH-tArYJyOob0Xtr3S0w.jpeg"><figcaption class="imageCaption"><code class="markup--code markup--figure-code">names2[0].name = &quot;蜘蛛人&quot;</code> 讓 names2[0] 的名字變成蜘蛛人，names1[0] 不受影響</figcaption></figure><figure name="66e9" id="66e9" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*VOo9dboanJcll-hr_D6c3Q.jpeg" data-width="1288" data-height="448" src="https://cdn-images-1.medium.com/max/800/1*VOo9dboanJcll-hr_D6c3Q.jpeg"><figcaption class="imageCaption">names2[1] = Baby(name: <code class="markup--code markup--figure-code">&quot;</code>蝙蝠俠<code class="markup--code markup--figure-code">&quot;</code>) 讓 names2[1] 成為新的寶寶蝙蝠俠，names1[1] 不受影響</figcaption></figure><p name="4001" id="4001" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">當 array 成員為 reference type</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="bdb8" id="bdb8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />   <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br />   <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) {<br />      <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br />   }<br />}<br /><br /><span class="hljs-keyword">var</span> names1 <span class="hljs-operator">=</span> [<span class="hljs-type">Baby</span>(name: <span class="hljs-string">&quot;彼得潘&quot;</span>), <span class="hljs-type">Baby</span>(name: <span class="hljs-string">&quot;虎克&quot;</span>)]<br /><span class="hljs-keyword">var</span> names2 <span class="hljs-operator">=</span> names1<br />names2[<span class="hljs-number">0</span>].name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;蜘蛛人&quot;</span><br />names2[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>(name: <span class="hljs-string">&quot;蝙蝠俠&quot;</span>)</span></pre><p name="d355" id="d355" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><figure name="2023" id="2023" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HsywENZPtG_uRFVXwAUvmA.jpeg" data-width="572" data-height="496" src="https://cdn-images-1.medium.com/max/800/1*HsywENZPtG_uRFVXwAUvmA.jpeg"><figcaption class="imageCaption">此時有 2 個 array，3 個寶寶</figcaption></figure><p name="b06c" id="b06c" class="graf graf--p graf-after--figure">array 的成員是 class 定義的 Baby，屬於 reference type，執行 <code class="markup--code markup--p-code">var names2 = names1</code> 時，names2 將塞入和 names1 一樣的成員。 此時兩個 array 仍然互相獨立，但兩個 array 擁有一樣的成員，所以寶寶有兩個，分別是彼得潘和虎克。</p><figure name="4f54" id="4f54" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*L2tHTe4pe6cZx5ej94Kw_g.jpeg" data-width="1296" data-height="670" src="https://cdn-images-1.medium.com/max/800/1*L2tHTe4pe6cZx5ej94Kw_g.jpeg"><figcaption class="imageCaption">此時有 2 個 array，2 個寶寶。</figcaption></figure><p name="f123" id="f123" class="graf graf--p graf-after--figure">當 names2[0] 的 name 被設為蜘蛛人時，names1[0] 的 name 也一樣會是蜘蛛人，因為它們是同一個寶寶。</p><figure name="eabd" id="eabd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1vCMDzvyh3QIMgQp8lQDWA.jpeg" data-width="1282" data-height="684" src="https://cdn-images-1.medium.com/max/800/1*1vCMDzvyh3QIMgQp8lQDWA.jpeg"><figcaption class="imageCaption"><code class="markup--code markup--figure-code">names2[0].name = &quot;蜘蛛人&quot;</code> 讓 names1[0] &amp; names2[0] 的寶寶名字變成蜘蛛人</figcaption></figure><p name="139b" id="139b" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">names2[1] = Baby(name: &quot;蝙蝠俠&quot;)</code> 讓 names2[1] 成為新的寶寶蝙蝠俠，names1[1] 不受影響，此時變成有三個寶寶。</p><figure name="dd6b" id="dd6b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*EWeH96-7OwSO-TLBDsQoHQ.jpeg" data-width="1414" data-height="656" src="https://cdn-images-1.medium.com/max/800/1*EWeH96-7OwSO-TLBDsQoHQ.jpeg"><figcaption class="imageCaption">此時有 2 個 array，3 個寶寶</figcaption></figure><blockquote name="4850" id="4850" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">App 的 model 是 value type 和 reference type 的差別</strong></blockquote><p name="509b" id="509b" class="graf graf--p graf-after--blockquote">我們開發 iOS App 時，MVC 裡的 model 可用 class 定義，也可用 struct 定義。關於哪個比較好，一直是個眾人爭論的話題。基本上若無特別的考量，選擇 struct 較好，因為程式會更安全，比較不易有 bug。對此議題有興趣的朋友可參考以下連結的說明。</p><div name="d5e7" id="d5e7" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes" data-href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes"><strong class="markup--strong markup--mixtapeEmbed-strong">Choosing Between Structures and Classes | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Decide how to store data and model behavior.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b0a47f02b7f3b6aa0d5fbc158bcdcb0a" data-thumbnail-img-id="0*MuyIeAURiw1Iza7e" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*MuyIeAURiw1Iza7e);"></a></div><p name="420e" id="420e" class="graf graf--p graf-after--mixtapeEmbed">當牽扯到頁面間的資料傳遞時，我們要特別注意 value type 和 reference type 的影響。以下圖 Start Developing iOS Apps 的美食記錄為例，當我們從列表頁點選想修改的美食後，會將型別 Meal 的資料傳到編輯頁面。當 Meal 以 struct 定義時，傳到編輯頁 controller 的將是複製的 Meal。當 Meal 以 class 定義時，傳到編輯頁 controller 的將是原來的 Meal 物件。</p><figure name="864f" id="864f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_39UU1Wg2xRHilqCWLd7iw.jpeg" data-width="936" data-height="850" src="https://cdn-images-1.medium.com/max/800/1*_39UU1Wg2xRHilqCWLd7iw.jpeg"></figure><blockquote name="7b7a" id="7b7a" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">class &amp; struct 的記憶體位置和大小</strong></blockquote><p name="044b" id="044b" class="graf graf--p graf-after--blockquote">對於 class &amp; struct 的記憶體位置和大小有興趣的，可另外參考以下連結。</p><div name="de04" id="de04" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%8F%96%E5%BE%97-swift-%E7%89%A9%E4%BB%B6%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E7%BD%AE-8ed0f1aaf051" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%8F%96%E5%BE%97-swift-%E7%89%A9%E4%BB%B6%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E7%BD%AE-8ed0f1aaf051" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%8F%96%E5%BE%97-swift-%E7%89%A9%E4%BB%B6%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E7%BD%AE-8ed0f1aaf051"><strong class="markup--strong markup--mixtapeEmbed-strong">class &amp; struct 的記憶體位置和大小</strong><br><em class="markup--em markup--mixtapeEmbed-em">在 Swift 裡，class 是 reference type，struct 是 value type，他們有個很大的差別，發生在我們利用 = 指定內容的時候。例如以下例子，當 Baby 是 refernece…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%8F%96%E5%BE%97-swift-%E7%89%A9%E4%BB%B6%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E7%BD%AE-8ed0f1aaf051" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ef826f72966154a1982ed0d11f4ae3a7" data-thumbnail-img-id="1*OV4HlnRLX-tBdt9uVBJfKg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*OV4HlnRLX-tBdt9uVBJfKg.jpeg);"></a></div><h3 name="bbee" id="bbee" class="graf graf--h3 graf-after--mixtapeEmbed">參考連結</h3><div name="d634" id="d634" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://www.swift.org/documentation/articles/value-and-reference-types.html" data-href="https://www.swift.org/documentation/articles/value-and-reference-types.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.swift.org/documentation/articles/value-and-reference-types.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Swift.org</strong><br><em class="markup--em markup--mixtapeEmbed-em">Swift is a general-purpose programming language built using a modern approach to safety, performance, and software…</em>www.swift.org</a><a href="https://www.swift.org/documentation/articles/value-and-reference-types.html" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a8b6e1e17fd31ffc764df95e16564846" data-thumbnail-img-id="0*J0Wd-HQHB3zKNDid" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*J0Wd-HQHB3zKNDid);"></a></div><div name="f8f5" id="f8f5" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes" data-href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes"><strong class="markup--strong markup--mixtapeEmbed-strong">Choosing Between Structures and Classes | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Decide how to store data and model behavior.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b0a47f02b7f3b6aa0d5fbc158bcdcb0a" data-thumbnail-img-id="0*MuyIeAURiw1Iza7e" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*MuyIeAURiw1Iza7e);"></a></div><div name="c616" id="c616" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://developer.apple.com/swift/blog/?id=10" data-href="https://developer.apple.com/swift/blog/?id=10" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/swift/blog/?id=10"><strong class="markup--strong markup--mixtapeEmbed-strong">Value and Reference Types - Swift Blog</strong><br><em class="markup--em markup--mixtapeEmbed-em">Get the latest news and helpful tips on the Swift programming language from the engineers who created it.</em>developer.apple.com</a><a href="https://developer.apple.com/swift/blog/?id=10" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c3995ef65c9ea938fe78f7c62a14e48b" data-thumbnail-img-id="0*Y6lepu6dTrX-WUsX" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Y6lepu6dTrX-WUsX);"></a></div><div name="5389" id="5389" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://www.raywenderlich.com/7320-getting-to-know-enum-struct-and-class-types-in-swift" data-href="https://www.raywenderlich.com/7320-getting-to-know-enum-struct-and-class-types-in-swift" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.raywenderlich.com/7320-getting-to-know-enum-struct-and-class-types-in-swift"><strong class="markup--strong markup--mixtapeEmbed-strong">Getting to Know Enum, Struct and Class Types in Swift</strong><br><em class="markup--em markup--mixtapeEmbed-em">Learn all about enums, structs, and classes in Swift, including value vs reference semantics, dynamic member lookup…</em>www.raywenderlich.com</a><a href="https://www.raywenderlich.com/7320-getting-to-know-enum-struct-and-class-types-in-swift" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="9aaf1fab1c5629239715cec790f6254e" data-thumbnail-img-id="0*5SK_cmFr8PTErCsf" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*5SK_cmFr8PTErCsf);"></a></div><div name="381d" id="381d" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://www.raywenderlich.com/1506-reference-vs-value-types-in-swift-part-1-2" data-href="https://www.raywenderlich.com/1506-reference-vs-value-types-in-swift-part-1-2" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.raywenderlich.com/1506-reference-vs-value-types-in-swift-part-1-2"><strong class="markup--strong markup--mixtapeEmbed-strong">Reference vs Value Types in Swift: Part 1/2</strong><br><em class="markup--em markup--mixtapeEmbed-em">Value types are much more prominent in Swift compared to Objective-C. Learn the difference between reference and value…</em>www.raywenderlich.com</a><a href="https://www.raywenderlich.com/1506-reference-vs-value-types-in-swift-part-1-2" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4386e892c5d100d3605d5f56e2bc60d9" data-thumbnail-img-id="0*aPk452s6BaRUNo9K" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*aPk452s6BaRUNo9K);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/25f9ae9f54b6"><time class="dt-published" datetime="2018-12-15T15:10:17.076Z">December 15, 2018</time></a>.</p><p><a href="https://medium.com/@apppeterpan/swift-%E7%9A%84-value-type-%E5%92%8C-reference-type-25f9ae9f54b6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>