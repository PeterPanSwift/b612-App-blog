<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>使用 JSONDecoder 解碼 array 裡不同的型別</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">使用 JSONDecoder 解碼 array 裡不同的型別</h1>
</header>
<section data-field="subtitle" class="p-summary">
使用 JSONDecoder，只要定義出 JSON 資料對應的 Decodable 型別，我們即可順利解析 JSON。比方以下的數字 array 可解碼成型別 [Int] 的資料。
</section>
<section data-field="body" class="e-content">
<section name="dd5e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6720" id="6720" class="graf graf--h3 graf--leading graf--title">使用 JSONDecoder 解碼 array 裡不同的型別</h3><p name="e099" id="e099" class="graf graf--p graf-after--h3">使用 JSONDecoder，只要定義出 JSON 資料對應的 Decodable 型別，我們即可順利解析 JSON。比方以下的數字 array 可解碼成型別 [Int] 的資料。</p><pre name="58f2" id="58f2" class="graf graf--pre graf-after--p">let data = &quot;&quot;&quot;<br>[1, 2, 3, 4, 5]<br>&quot;&quot;&quot;.data(using: .utf8)!<br>do {<br>    let numbers = try JSONDecoder().decode([Int].self, from: data)<br>    print(numbers)<br>} catch {<br>    print(error)<br>}</pre><p name="63fc" id="63fc" class="graf graf--p graf-after--pre">然而有時我們還是會遇到一些奇怪的 JSON。最近彼得潘串接韋伯字典 API 時遇到了麻煩。</p><div name="0099" id="0099" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.dictionaryapi.com" data-href="https://www.dictionaryapi.com" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.dictionaryapi.com"><strong class="markup--strong markup--mixtapeEmbed-strong">Merriam-Webster Dictionary API</strong><br><em class="markup--em markup--mixtapeEmbed-em">The Merriam-Webster Dictionary API gives developers access to a comprehensive resource of dictionary and thesaurus…</em>www.dictionaryapi.com</a><a href="https://www.dictionaryapi.com" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="18fecf362bf7e060b52c9d2eb796e389" data-thumbnail-img-id="0*yYWtWXbfQqKwDMs-" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*yYWtWXbfQqKwDMs-);"></a></div><p name="7b58" id="7b58" class="graf graf--p graf-after--mixtapeEmbed">如下圖所示，它的 JSON 裡的 array 滿特別的，它的 array 成員竟然有著不同的型別 !</p><figure name="d8c2" id="d8c2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Sk_ztAzJyKUrzE4QVug_ZQ.png" data-width="1240" data-height="410" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Sk_ztAzJyKUrzE4QVug_ZQ.png"></figure><p name="b75f" id="b75f" class="graf graf--p graf-after--figure">沒關係，兵來將擋，水來土掩。接下來讓我們試著將上圖的 JSON 定義成 data，然後用 JSONDecoder 解碼它。</p><pre name="f260" id="f260" class="graf graf--pre graf-after--p">let data = &quot;&quot;&quot;<br>[<br>    &quot;vis&quot;,<br>    [<br>        {&quot;t&quot;:&quot;a {it}complex{/it} system&quot;},<br>        {&quot;t&quot;:&quot;The house&#39;s wiring is {it}complex{/it}.&quot;}<br>    ]<br>]<br>&quot;&quot;&quot;.data(using: .utf8)!</pre><p name="6224" id="6224" class="graf graf--p graf-after--pre">array 的成員有著不同的型別，第一個是字串，第二個是 array，因此我們必須自己寫解碼的程式，另外定義 init(from:)。</p><h3 name="5bad" id="5bad" class="graf graf--h3 graf-after--p">init(from:) 入門</h3><p name="b6c3" id="b6c3" class="graf graf--p graf-after--h3">對 init(from:) 還不熟的朋友，可先參考以下連結的說明。</p><div name="d9bb" id="d9bb" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%87%AA%E8%A8%82-init-from-decoder-%E8%A7%A3%E6%9E%90-json-f9c8d420cda4" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%87%AA%E8%A8%82-init-from-decoder-%E8%A7%A3%E6%9E%90-json-f9c8d420cda4" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%87%AA%E8%A8%82-init-from-decoder-%E8%A7%A3%E6%9E%90-json-f9c8d420cda4"><strong class="markup--strong markup--mixtapeEmbed-strong">定義 Decodable 的 init(from:) 解析 JSON</strong><br><em class="markup--em markup--mixtapeEmbed-em">透過 JSONDecoder，我們可以方便地將 JSON 資料變成遵從 protocol Decodable 的自訂型別，而且大部分的時候我們只要宣告型別裡的 property，不用自己撰寫解析 JSON 的 init(from…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%87%AA%E8%A8%82-init-from-decoder-%E8%A7%A3%E6%9E%90-json-f9c8d420cda4" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="f2f0a35aa460b7489fcc5705881cd7d1" data-thumbnail-img-id="1*rvyZe7kQUWeREkieUQqrug.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*rvyZe7kQUWeREkieUQqrug.png);"></a></div><h3 name="8a27" id="8a27" class="graf graf--h3 graf-after--mixtapeEmbed">解碼 array 裡不同的型別</h3><p name="4fe7" id="4fe7" class="graf graf--p graf-after--h3">了解 init(from:) 的基本概念後，我們可以使用以下兩個方法處理 array 裡不同的型別。</p><h4 name="106c" id="106c" class="graf graf--h4 graf-after--p">方法 1: 若 array 成員數量和型別順序固定</h4><p name="4703" id="4703" class="graf graf--p graf-after--h4">若是 array 只有兩個成員，固定第一個是字串，第二個是 array，我們可用以下解法。</p><pre name="e6ec" id="e6ec" class="graf graf--pre graf-after--p">struct VisArray: Decodable {<br>    var name: String<br>    var texts: [Text]</pre><pre name="5f79" id="5f79" class="graf graf--pre graf-after--pre">    init(from decoder: Decoder) throws {<br>        var container = try decoder.unkeyedContainer()<br>        name = try container.decode(String.self)<br>        texts = try container.decode([Text].self)<br>    }</pre><pre name="c1ae" id="c1ae" class="graf graf--pre graf-after--pre">    struct Text: Decodable {<br>        let t: String<br>    }<br>}</pre><h4 name="2b59" id="2b59" class="graf graf--h4 graf-after--pre">方法 2: 若 array 成員數量和型別順序不固定</h4><pre name="2eb6" id="2eb6" class="graf graf--pre graf-after--h4">struct VisArray: Decodable {<br>    var name: String<br>    var texts: [Text]<br>    <br>    init(from decoder: Decoder) throws {<br>        var name: String?<br>        var texts: [Text]?<br>        var container = try decoder.unkeyedContainer()<br>        <strong class="markup--strong markup--pre-strong">while !container.isAtEnd {<br>            if let decodeName = try? container.decode(String.self) {<br>                name = decodeName<br>            } else if let decodeTexts = try? container.decode([Text].self) {<br>                texts = decodeTexts<br>            } else {<br>                throw DecodingError.dataCorruptedError(in: container, debugDescription: &quot;error&quot;)<br>            }<br>        }</strong><br>        if let name = name,<br>           let texts = texts {<br>            self.name = name<br>            self.texts = texts<br>        } else {<br>            throw DecodingError.dataCorruptedError(in: container, debugDescription: &quot;error&quot;)<br>        }<br>        <br>    }<br>    <br>    struct Text: Decodable {<br>        let t: String<br>    }<br>}</pre><p name="2f25" id="2f25" class="graf graf--p graf-after--pre">說明</p><pre name="013f" id="013f" class="graf graf--pre graf-after--p">while !container.isAtEnd {<br>   if let decodeName = try? container.decode(String.self) {<br>       name = decodeName<br>   } else if let decodeTexts = try? container.decode([Text].self) {<br>       texts = decodeTexts<br>   } else {<br>       throw DecodingError.dataCorruptedError(in: container, debugDescription: &quot;error&quot;)<br>   }<br>}</pre><p name="a49a" id="a49a" class="graf graf--p graf-after--pre">關鍵在 while 裡的這段程式。 array 的成員型別有可能是 String，也可能是 [Text]，因此我們先以 String 解碼，若不是 String 再以 [Text] 解碼。如果不是 String 也不是 [Text] 則丟出錯誤。</p><h4 name="a267" id="a267" class="graf graf--h4 graf-after--p">測試解碼</h4><pre name="cb40" id="cb40" class="graf graf--pre graf-after--h4">do {<br>    let array = try JSONDecoder().decode(VisArray.self, from: data)<br>    print(array.name)<br>    array.texts.forEach {<br>        print($0.t)<br>    }<br>} catch {<br>    print(error)<br>}</pre><p name="76f7" id="76f7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果</strong></p><p name="09b8" id="09b8" class="graf graf--p graf-after--p">成功解碼包含不同成員型別的 array，印出以下訊息。</p><pre name="9263" id="9263" class="graf graf--pre graf-after--p graf--trailing">vis<br>a {it}complex{/it} system<br>The house&#39;s wiring is {it}complex{/it}.</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/42c6bd8f7a5f"><time class="dt-published" datetime="2021-07-10T03:37:54.945Z">July 10, 2021</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E4%BD%BF%E7%94%A8-jsondecoder-%E8%A7%A3%E7%A2%BC-array-%E8%A3%A1%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%8B%E5%88%A5-42c6bd8f7a5f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>