<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>請 AI 以我們感興趣的主題用比喻 &amp; 實例 table 格式說明程式/演算法/資料結構</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">請 AI 以我們感興趣的主題用比喻 &amp; 實例 table 格式說明程式/演算法/資料結構</h1>
</header>
<section data-field="subtitle" class="p-summary">
學習程式、演算法、資料結構時，我們時常遇到以下兩大問題，害我們學不好。
</section>
<section data-field="body" class="e-content">
<section name="dcd9" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="55d3" id="55d3" class="graf graf--h3 graf--leading graf--title">請 AI 以我們感興趣的主題用比喻 &amp; 實例 table 格式說明程式/演算法/資料結構</h3><p name="9216" id="9216" class="graf graf--p graf-after--h3">學習程式、演算法、資料結構時，我們時常遇到以下兩大問題，害我們學不好。</p><ul class="postList"><li name="31ad" id="31ad" class="graf graf--li graf-after--p">觀念有點抽象、無聊、深奧，因此很難理解。</li><li name="58f9" id="58f9" class="graf graf--li graf-after--li">容易忘記。也因為忘了前面學的，後面自然就跟不上了。(ps: 這也是彼得潘大學有些課翹課的原因。)</li></ul><p name="d1a0" id="d1a0" class="graf graf--p graf-after--li">最近有了 AI 的幫忙，彼得潘發現以上問題都可以改善了。我們可以請 AI 以我們感興趣的主題用比喻 &amp; 實例 table 格式說明程式和演算法，以下我們以 4 個常見的例子說明。</p><ul class="postList"><li name="12af" id="12af" class="graf graf--li graf-after--p">bubble sort。</li><li name="e909" id="e909" class="graf graf--li graf-after--li">swift 的 optional。</li><li name="d11d" id="d11d" class="graf graf--li graf-after--li">quick sort。</li><li name="27e9" id="27e9" class="graf graf--li graf-after--li">資料結構的 stack。</li></ul><h3 name="0341" id="0341" class="graf graf--h3 graf-after--li">bubble sort</h3><ul class="postList"><li name="5633" id="5633" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">我常常忘記 bubble sort，請提供我一個容易記得的說明</strong></li></ul><p name="b78f" id="b78f" class="graf graf--p graf-after--li">當然，我會提供一個比喻來幫助你記得 bubble sort（冒泡排序）。</p><p name="7c45" id="7c45" class="graf graf--p graf-after--p">想像一下你在參加一個舞會，所有的舞者（數字）都在跳舞，你的目標是將他們按照身高（大小）排列。</p><p name="9608" id="9608" class="graf graf--p graf-after--p">冒泡排序就像是你在舞會上一對一地觀察每對舞者。從舞池的一端開始，你會查看兩位舞者，如果他們的身高（大小）順序錯誤（假設我們希望由小到大排序，那麼更矮的人應該在更高的人之前），你就會讓他們調換位置。然後，你會移到下一對舞者，並重複這個過程，直到你走到舞池的另一邊。</p><p name="49e8" id="49e8" class="graf graf--p graf-after--p">在你走到舞池的另一邊時，最高（最大）的舞者就會被”冒泡”到舞池的一端。然後，你再次從舞池的一端開始，重複同樣的過程，直到所有的舞者都按照身高（大小）順序排列好。</p><p name="481a" id="481a" class="graf graf--p graf-after--p">這就是冒泡排序的過程。在每一次從舞池的一端走到另一端的過程中，最大的數字都會像泡泡一樣被”冒”出來，放到正確的位置上。希望這個比喻能夠幫助你記住冒泡排序的原理！</p><ul class="postList"><li name="270e" id="270e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">使用 table format 說明剛剛 bubble sort 舞會例子排序的過程。假設有 4 個舞者，彼得潘，溫蒂，虎克船長，奇幻仙子</strong></li></ul><figure name="79d7" id="79d7" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*ae1_ZP0do042eCOCV5PX_w.png" data-width="1190" data-height="1094" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*ae1_ZP0do042eCOCV5PX_w.png"></figure><figure name="577e" id="577e" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*o-5CHPwhOsHrED7gpNMUtQ.png" data-width="1212" data-height="1112" src="https://cdn-images-1.medium.com/max/800/1*o-5CHPwhOsHrED7gpNMUtQ.png"></figure><figure name="652b" id="652b" class="graf graf--figure graf-after--figure graf--trailing"><img class="graf-image" data-image-id="1*Itt-S-OBTOXmnkjg6FYJGw.png" data-width="1194" data-height="632" src="https://cdn-images-1.medium.com/max/800/1*Itt-S-OBTOXmnkjg6FYJGw.png"></figure></div></div></section><section name="559c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="350d" id="350d" class="graf graf--li graf--leading"><strong class="markup--strong markup--li-strong">我常常忘記 bubble sort，請提供我一個容易記得的說明，我最喜歡的書是小王子</strong></li></ul><p name="d881" id="d881" class="graf graf--p graf-after--li">當然可以。讓我們利用你最喜歡的書《小王子》來解釋冒泡排序（Bubble Sort）。</p><p name="ae50" id="ae50" class="graf graf--p graf-after--p">想像小王子正在他的家星球上照顧他的玫瑰花。他有很多種玫瑰，並且他想將它們按照他們的大小排序。小王子對玫瑰非常小心翼翼，所以他每次只能移動兩朵玫瑰。</p><p name="1730" id="1730" class="graf graf--p graf-after--p">1. 首先，他將第一朵和第二朵玫瑰比較，如果第一朵比第二朵大，他就交換它們的位置。</p><p name="35be" id="35be" class="graf graf--p graf-after--p">2. 然後，他再將第二朵和第三朵玫瑰比較，同樣地，如果第二朵比第三朵大，他就交換它們的位置。</p><p name="c07c" id="c07c" class="graf graf--p graf-after--p">3. 小王子如此進行下去，直到他比較了最後一對玫瑰。在此之後，最大的玫瑰就會被”冒泡”到最後的位置。</p><p name="0485" id="0485" class="graf graf--p graf-after--p">4. 然後他再從頭開始，重複這個過程，直到所有的玫瑰都被整齊地按照大小排序。</p><p name="82d2" id="82d2" class="graf graf--p graf-after--p">這就是冒泡排序的基本原理。你可以想像小王子在他的星球上一對一地比較並移動玫瑰，直到所有的玫瑰都按照大小排列好。希望這個比喻能幫助你記住冒泡排序的過程。</p><ul class="postList"><li name="42b9" id="42b9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">使用 table format 說明剛剛 bubble sort 以玫瑰花大小排序的過程。假設有 4 個不同顏色的玫瑰花</strong></li></ul><figure name="e51e" id="e51e" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*bRhr9SaUrkMtrGWbnYLnFw.png" data-width="1182" data-height="1088" src="https://cdn-images-1.medium.com/max/800/1*bRhr9SaUrkMtrGWbnYLnFw.png"></figure><figure name="788e" id="788e" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*Y1grj_-EkF21mDZI5ZgApA.png" data-width="1250" data-height="1108" src="https://cdn-images-1.medium.com/max/800/1*Y1grj_-EkF21mDZI5ZgApA.png"></figure><figure name="8496" id="8496" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*Mkf9ciR5TC1GUFMs-ScnAg.png" data-width="1214" data-height="672" src="https://cdn-images-1.medium.com/max/800/1*Mkf9ciR5TC1GUFMs-ScnAg.png"></figure><h3 name="2161" id="2161" class="graf graf--h3 graf-after--figure">swift 的 optional</h3><ul class="postList"><li name="ab5b" id="ab5b" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">我常常忘記 swift 的 optional，請提供我一個容易記得的說明</strong></li></ul><p name="c9c4" id="c9c4" class="graf graf--p graf-after--li">Optional 是 Swift 語言中一種特殊的數據類型，它表示一個值可能有值，也可能沒有值（即 nil）。這是 Swift 語言對其他語言中常見的 null 或 nil 問題的解決方案，有助於提高程式碼的安全性和預測性。</p><p name="9146" id="9146" class="graf graf--p graf-after--p">我們可以用一個比喻來幫助你理解和記住 Swift 中的 Optional：</p><p name="c587" id="c587" class="graf graf--p graf-after--p">想像一下，Optional 就像是一個禮物盒。禮物盒裡面可能有一個禮物（有值），也可能是空的（沒有值，即 nil）。當你拿到一個禮物盒時，你無法僅憑外表確定裡面是否有禮物，你需要打開（解包）禮物盒才能確認。</p><p name="bc8b" id="bc8b" class="graf graf--p graf-after--p">在 Swift 語言中，我們使用 `?` 來標識一個變數可能是 Optional 的，這就像是標註這個 “禮物盒” 可能是空的。例如，`var giftBox: String?` 就表示 “giftBox” 這個變數可能有一個字符串，也可能是 nil。</p><p name="1a23" id="1a23" class="graf graf--p graf-after--p">當我們需要使用 Optional 變數中的值時，我們需要先確認這個 “禮物盒” 內是否有禮物（即值是否為 nil）。這個過程就像是打開禮物盒，我們稱之為 “解包”（Unwrapping）。在 Swift 中，我們可以使用 `if let` 或者 `guard let` 來解包。</p><p name="a06d" id="a06d" class="graf graf--p graf-after--p">希望這個比喻能幫助你記住 Swift 中的 Optional。如果你還有其他問題，請隨時提問！</p><ul class="postList"><li name="1945" id="1945" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">我常常忘記 swift 的 optional，請提供我一個容易記得的說明。我喜歡打棒球</strong></li></ul><p name="7803" id="7803" class="graf graf--p graf-after--li">當然，我們可以通過一個與棒球相關的比喻來理解 Swift 的 Optional。</p><p name="ddb5" id="ddb5" class="graf graf--p graf-after--p">想像你正在打棒球，Optional 就像是一個棒球手套。當球員在場上，他們的手套可能會有球（有值），也可能是空的（沒有值，即 nil）。</p><p name="62fb" id="62fb" class="graf graf--p graf-after--p">1. **Optional 的創建（手套的準備）：** 在 Swift 中，我們使用 `?` 來標識一個變數可能是 Optional 的。這就好比告訴隊友，這個手套可能會接到球，也可能不會。例如，`var baseballGlove: Ball?` 表示 “baseballGlove” 這個變數可能有一個球（Ball），也可能沒有（nil）。</p><p name="15f8" id="15f8" class="graf graf--p graf-after--p">2. **Optional 的解包（檢查手套）：** 在 Swift 中，我們需要解包 Optional 變數來使用它的值，這就像檢查手套看是否接到球。我們可以使用 `if let` 或者 `guard let` 來解包。例如，`if let ball = baseballGlove { … }`，這就像是說：「如果手套裡有球，那我就可以拿著球做一些事情（在大括號中）」。</p><p name="465b" id="465b" class="graf graf--p graf-after--p">3. **強制解包（假設手套裡有球）：** 有時候，我們非常確定手套裡一定有球，這時我們可以使用強制解包，即在變數後面加上 `!`。例如，`let ball = baseballGlove!`。但這是風險的，如果手套裡沒有球（即值為 nil），程式會出錯。這就像是球員在不看手套的情況下，直接嘗試拋球，如果手套裡沒有球，他將無法拋出球。</p><p name="cc3a" id="cc3a" class="graf graf--p graf-after--p">希望這個棒球比喻可以幫助你更好地理解和記住 Swift 中的 Optional。如果你還有其他問題，請隨時提問！</p><ul class="postList"><li name="2a1f" id="2a1f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">我常常忘記 quick sort，請提供我一個容易記得的說明</strong></li></ul><p name="6f2f" id="6f2f" class="graf graf--p graf-after--li">快速排序（Quick Sort）是一種有效的排序算法，它的基本思想是使用分治法（Divide and Conquer）。</p><p name="ec33" id="ec33" class="graf graf--p graf-after--p">讓我們通過一個比喻來理解它：假設你是一個教師，需要將你的學生按照身高排序。</p><p name="c456" id="c456" class="graf graf--p graf-after--p">1. **選擇基準點（Pivot）:** 你選擇一個學生，讓我們稱他為 Charlie。Charlie 將成為我們的基準點。</p><p name="ab41" id="ab41" class="graf graf--p graf-after--p">2. **分區（Partition）:** 現在你讓所有身高低於 Charlie 的學生站在他的左邊，身高高於或等於 Charlie 的學生站在他的右邊。現在，Charlie 處於他正確的位置，因為他的左邊沒有比他更高的學生，他的右邊沒有比他更矮的學生。</p><p name="d425" id="d425" class="graf graf--p graf-after--p">3. **遞迴（Recursion）:** 你現在將班級分為兩部分，Charlie 的左邊和右邊。你重複上述過程，為每一部分選擇新的基準點，進行分區，然後繼續分區的分區，直到所有的學生都在他們應該在的位置。</p><p name="36f8" id="36f8" class="graf graf--p graf-after--p">這就是快速排序的基本思想。重要的是要記住，這是一種遞迴的過程，你是在不斷地將大問題分解為小問題，然後解決這些小問題，從而解決大問題。</p><ul class="postList"><li name="abb0" id="abb0" class="graf graf--li graf-after--p">使用 table format 說明剛剛 quick sort 以學生身高排序的過程。假設有 4 個學生，以金庸小說的角色當學生</li></ul><figure name="d82a" id="d82a" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*E0zs6q-SbnOvpp8L3goPOQ.png" data-width="1180" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*E0zs6q-SbnOvpp8L3goPOQ.png"></figure><figure name="a196" id="a196" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*iLFGygy-C_0AfRSvyQ5-VA.png" data-width="1234" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*iLFGygy-C_0AfRSvyQ5-VA.png"></figure><figure name="de7a" id="de7a" class="graf graf--figure graf-after--figure graf--trailing"><img class="graf-image" data-image-id="1*j912AOxvznrYTpgPxGZK_A.png" data-width="1248" data-height="712" src="https://cdn-images-1.medium.com/max/800/1*j912AOxvznrYTpgPxGZK_A.png"></figure></div></div></section><section name="e2ca" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="b8bf" id="b8bf" class="graf graf--li graf--leading"><strong class="markup--strong markup--li-strong">我常常忘記 quick sort，請提供我一個容易記得的說明，我喜歡皮卡丘</strong></li></ul><p name="901e" id="901e" class="graf graf--p graf-after--li">當然，我們可以用一個與皮卡丘相關的比喻來幫助你理解快速排序（Quick Sort）。</p><p name="d88c" id="d88c" class="graf graf--p graf-after--p">想像你在玩寶可夢遊戲，你有一堆皮卡丘卡片，每一張卡片的等級都不同，你的任務是將這些卡片按照等級排序。</p><p name="7629" id="7629" class="graf graf--p graf-after--p">1. **選擇基準點（Pivot）:** 你隨機選擇一張皮卡丘卡片作為基準點。這就像說，”這張皮卡丘卡片是我比較的基準。”</p><p name="0f04" id="0f04" class="graf graf--p graf-after--p">2. **分區（Partition）:** 現在你比較所有其他的皮卡丘卡片。如果它們的等級比基準點低，你將它們放在基準點的左邊；如果它們的等級比基準點高，你將它們放在基準點的右邊。這個過程叫做分區。現在，你的基準點皮卡丘卡片就在正確的位置上了，因為它左邊的卡片等級都比它低，右邊的卡片等級都比它高。</p><p name="ad71" id="ad71" class="graf graf--p graf-after--p">3. **遞迴（Recursion）:** 現在，你有兩堆需要排序的皮卡丘卡片。對於每一堆，你選擇一張新的基準點，再次進行分區，然後對每一堆的分區再進行分區，直到所有的卡片都被排序。</p><p name="bcbf" id="bcbf" class="graf graf--p graf-after--p">這就是快速排序的過程，它是一種高效的排序方法，可以幫助你快速地將皮卡丘卡片按照等級排序。希望這個比喻可以幫助你記住快速排序的方法。如果你還有其他問題，請隨時提問！</p><ul class="postList"><li name="cfb4" id="cfb4" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">使用 table format 說明剛剛 quick sort 以寶可夢卡片等級排序的過程。假設有 4 張卡片，以受歡迎的寶可夢為例</strong></li></ul><figure name="8f63" id="8f63" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*n0i8Ae3q-ZLb30siPdZ6Hg.png" data-width="1192" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*n0i8Ae3q-ZLb30siPdZ6Hg.png"></figure><figure name="b4d0" id="b4d0" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*JkQRVL7NmtJ8Wy8zNRZ4fw.png" data-width="1208" data-height="716" src="https://cdn-images-1.medium.com/max/800/1*JkQRVL7NmtJ8Wy8zNRZ4fw.png"></figure><figure name="389e" id="389e" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*NfVezSZMPxVopWs_ok3HFg.png" data-width="1216" data-height="688" src="https://cdn-images-1.medium.com/max/800/1*NfVezSZMPxVopWs_ok3HFg.png"></figure><ul class="postList"><li name="f03c" id="f03c" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">將說明的例子寫成程式</strong></li></ul><p name="8be2" id="8be2" class="graf graf--p graf-after--li">以剛剛的寶可夢卡片為例。</p><p name="c31a" id="c31a" class="graf graf--p graf-after--p">將剛剛的例子寫成 swift 程式。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7882" id="7882" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: [(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)]) -&gt; [(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] {<br />    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> array }<br />    <br />    <span class="hljs-keyword">let</span> pivot <span class="hljs-operator">=</span> array[array.count <span class="hljs-operator">/</span> <span class="hljs-number">2</span>]<br />    <span class="hljs-keyword">let</span> less <span class="hljs-operator">=</span> array.filter { <span class="hljs-variable">$0</span>.<span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> pivot.<span class="hljs-number">1</span> }<br />    <span class="hljs-keyword">let</span> equal <span class="hljs-operator">=</span> array.filter { <span class="hljs-variable">$0</span>.<span class="hljs-number">1</span> <span class="hljs-operator">==</span> pivot.<span class="hljs-number">1</span> }<br />    <span class="hljs-keyword">let</span> greater <span class="hljs-operator">=</span> array.filter { <span class="hljs-variable">$0</span>.<span class="hljs-number">1</span> <span class="hljs-operator">&gt;</span> pivot.<span class="hljs-number">1</span> }<br />    <br />    <span class="hljs-keyword">return</span> quickSort(less) <span class="hljs-operator">+</span> equal <span class="hljs-operator">+</span> quickSort(greater)<br />}<br /><br /><span class="hljs-comment">// 建立一個包含寶可夢名稱和等級的元組列表</span><br /><span class="hljs-keyword">var</span> pokemonList <span class="hljs-operator">=</span> [(<span class="hljs-string">&quot;傑尼龜&quot;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;皮卡丘&quot;</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">&quot;噴火龍&quot;</span>, <span class="hljs-number">30</span>), (<span class="hljs-string">&quot;快龍&quot;</span>, <span class="hljs-number">25</span>)]<br /><br /><span class="hljs-comment">// 呼叫 quickSort 函數對列表進行排序</span><br /><span class="hljs-keyword">let</span> sortedPokemonList <span class="hljs-operator">=</span> quickSort(pokemonList)<br /><br /><span class="hljs-comment">// 印出排序後的列表</span><br /><span class="hljs-keyword">for</span> pokemon <span class="hljs-keyword">in</span> sortedPokemonList {<br />    <span class="hljs-built_in">print</span>(pokemon)<br />}</span></pre><p name="3fe9" id="3fe9" class="graf graf--p graf-after--pre">將剛剛的例子寫成 python 程式。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="a35b" id="a35b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">pokemon_list</span>):<br />    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pokemon_list) &lt;= <span class="hljs-number">1</span>:<br />        <span class="hljs-keyword">return</span> pokemon_list<br />    <span class="hljs-keyword">else</span>:<br />        pivot = pokemon_list[<span class="hljs-number">0</span>]<br />        less_than_pivot = [pokemon <span class="hljs-keyword">for</span> pokemon <span class="hljs-keyword">in</span> pokemon_list[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> pokemon[<span class="hljs-number">1</span>] &lt; pivot[<span class="hljs-number">1</span>]]<br />        greater_than_pivot = [pokemon <span class="hljs-keyword">for</span> pokemon <span class="hljs-keyword">in</span> pokemon_list[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> pokemon[<span class="hljs-number">1</span>] &gt; pivot[<span class="hljs-number">1</span>]]<br />        <span class="hljs-keyword">return</span> quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)<br /><br /><span class="hljs-comment"># 建立一個包含寶可夢名稱和等級的列表</span><br />pokemon_list = [(<span class="hljs-string">&quot;傑尼龜&quot;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;皮卡丘&quot;</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">&quot;噴火龍&quot;</span>, <span class="hljs-number">30</span>), (<span class="hljs-string">&quot;快龍&quot;</span>, <span class="hljs-number">25</span>)]<br /><br /><span class="hljs-comment"># 呼叫 quick_sort 函數對列表進行排序</span><br />sorted_pokemon_list = quick_sort(pokemon_list)<br /><br /><span class="hljs-comment"># 印出排序後的列表</span><br /><span class="hljs-keyword">for</span> pokemon <span class="hljs-keyword">in</span> sorted_pokemon_list:<br />    <span class="hljs-built_in">print</span>(pokemon)</span></pre><h3 name="cba8" id="cba8" class="graf graf--h3 graf-after--pre">資料結構的 stack</h3><ul class="postList"><li name="0c42" id="0c42" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">我常常忘記資料結構的 stack，請提供我一個容易記得的說明</strong></li></ul><p name="3ade" id="3ade" class="graf graf--p graf-after--li">當然可以。讓我們試著用一個日常生活的比喻來理解「堆疊」（Stack）這個資料結構。</p><p name="cce1" id="cce1" class="graf graf--p graf-after--p">你可以想像 Stack 就像是一疊盤子。當你想要添加（push）一個盤子到這疊盤子時，你會把它放在最上面。這就是 Stack 的「後進先出」（Last-In-First-Out，LIFO）的特性：最後一個被添加到 Stack 的元素會是第一個被移除（pop）的。</p><p name="0c24" id="0c24" class="graf graf--p graf-after--p">同樣地，當你需要取用一個盤子（pop 操作）時，你會從最上面的盤子開始取，而不是從中間或底部取出，這是因為在 Stack 中，你只能操作最上面的元素。</p><p name="5c48" id="5c48" class="graf graf--p graf-after--p">除此之外，你還可以查看最上面的盤子是什麼（peek 或 top 操作），但是並不移除它。在真實世界中，這就像是你看一下最上面的盤子，但是並不拿走它。</p><p name="976f" id="976f" class="graf graf--p graf-after--p">這就是 Stack 資料結構的基本概念。希望這個比喻可以幫助你更容易理解和記住它！</p><ul class="postList"><li name="01c0" id="01c0" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">使用 table format 說明剛剛的例子，假設有 4 個不同顏色的盤子</strong></li></ul><figure name="1449" id="1449" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*EFfArST5Gwaj2Q1JfyN3BA.png" data-width="1186" data-height="1006" src="https://cdn-images-1.medium.com/max/800/1*EFfArST5Gwaj2Q1JfyN3BA.png"></figure><ul class="postList"><li name="abc0" id="abc0" class="graf graf--li graf-after--figure">將剛剛的例子寫成 swift 程式</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="e22c" id="e22c" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span> {<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> elements: [<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> []<br />    <br />    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">element</span>: <span class="hljs-type">String</span>) {<br />        elements.append(element)<br />    }<br />    <br />    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">String</span>? {<br />        <span class="hljs-keyword">return</span> elements.popLast()<br />    }<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">peek</span>() -&gt; <span class="hljs-type">String</span>? {<br />        <span class="hljs-keyword">return</span> elements.last<br />    }<br />}<br /><br /><span class="hljs-keyword">var</span> stack <span class="hljs-operator">=</span> <span class="hljs-type">Stack</span>()<br /><br />stack.push(<span class="hljs-string">&quot;紅色&quot;</span>)<br />stack.push(<span class="hljs-string">&quot;藍色&quot;</span>)<br />stack.push(<span class="hljs-string">&quot;黃色&quot;</span>)<br />stack.push(<span class="hljs-string">&quot;綠色&quot;</span>)<br /><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment">// Prints &quot;綠色&quot;</span><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment">// Prints &quot;黃色&quot;</span><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment">// Prints &quot;藍色&quot;</span><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment">// Prints &quot;紅色&quot;</span></span></pre><ul class="postList"><li name="415c" id="415c" class="graf graf--li graf-after--pre">將剛剛的例子寫成 python 程式</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="22e6" id="22e6" class="graf graf--pre graf-after--li graf--trailing graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br />        self.elements = []<br /><br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, element</span>):<br />        self.elements.append(element)<br /><br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br />        <span class="hljs-keyword">return</span> self.elements.pop() <span class="hljs-keyword">if</span> self.elements <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br /><br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>):<br />        <span class="hljs-keyword">return</span> self.elements[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> self.elements <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br /><br /><br />stack = Stack()<br /><br />stack.push(<span class="hljs-string">&quot;紅色&quot;</span>)<br />stack.push(<span class="hljs-string">&quot;藍色&quot;</span>)<br />stack.push(<span class="hljs-string">&quot;黃色&quot;</span>)<br />stack.push(<span class="hljs-string">&quot;綠色&quot;</span>)<br /><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment"># Prints &quot;綠色&quot;</span><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment"># Prints &quot;黃色&quot;</span><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment"># Prints &quot;藍色&quot;</span><br /><span class="hljs-built_in">print</span>(stack.pop())  <span class="hljs-comment"># Prints &quot;紅色&quot;</span></span></pre></div></div></section><section name="b33b" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ul class="postList"><li name="b79d" id="b79d" class="graf graf--li graf--leading"><strong class="markup--strong markup--li-strong">我常常忘記資料結構的 stack，請提供我一個容易記得的說明，我的興趣是疊疊樂</strong></li></ul><p name="9ced" id="9ced" class="graf graf--p graf-after--li">很好，疊疊樂是一個完美的比喻來理解「堆疊」（Stack）這種資料結構。</p><p name="458a" id="458a" class="graf graf--p graf-after--p">當你玩疊疊樂時，你會一塊一塊地把積木堆疊起來，這就像在 Stack 中進行「推入」（Push）操作。每次你新增一塊積木，你都是把它放在最上面，這就體現了 Stack 的「後進先出」（Last-In-First-Out，LIFO）特性，也就是說，最後被推入的元素會是第一個被取出的。</p><p name="db7c" id="db7c" class="graf graf--p graf-after--p">然後，當你要移除積木時（這就像進行 Stack 中的「彈出」（Pop）操作），你總是會從最上面的積木開始，因為在 Stack 中，你只能操作最上面的元素。</p><p name="981a" id="981a" class="graf graf--p graf-after--p">最後，你也可以「偷看」（Peek）最上面的積木是什麼，但並不移除它。這就像在 Stack 中，你可以查看最上面的元素，但不會將其取出。</p><p name="d207" id="d207" class="graf graf--p graf-after--p">所以，下次你玩疊疊樂時，你就可以想到 Stack 這種資料結構了。希望這個比喻能幫助你更好地記住它！</p><ul class="postList"><li name="2ccc" id="2ccc" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">使用 table format 說明剛剛的例子，假設有 4 個不同顏色的積木</strong></li></ul><figure name="a415" id="a415" class="graf graf--figure graf-after--li graf--trailing"><img class="graf-image" data-image-id="1*4U7idbREdE2vJLVJsCLPcw.png" data-width="1198" data-height="1014" src="https://cdn-images-1.medium.com/max/800/1*4U7idbREdE2vJLVJsCLPcw.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/c40cc9a300f7"><time class="dt-published" datetime="2023-05-13T07:11:20.922Z">May 13, 2023</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E8%AB%8B-ai-%E4%BB%A5%E6%88%91%E5%80%91%E6%84%9F%E8%88%88%E8%B6%A3%E7%9A%84%E4%B8%BB%E9%A1%8C%E7%94%A8%E6%AF%94%E5%96%BB-%E5%AF%A6%E4%BE%8B-table-%E6%A0%BC%E5%BC%8F%E8%AA%AA%E6%98%8E%E7%A8%8B%E5%BC%8F-%E6%BC%94%E7%AE%97%E6%B3%95-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-c40cc9a300f7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>