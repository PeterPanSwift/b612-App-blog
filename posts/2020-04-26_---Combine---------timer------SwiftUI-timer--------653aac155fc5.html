<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>利用 Combine 產生自動停止的 timer &amp; 解決 SwiftUI timer 的記憶體問題</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">利用 Combine 產生自動停止的 timer &amp; 解決 SwiftUI timer 的記憶體問題</h1>
</header>
<section data-field="subtitle" class="p-summary">
開發 iOS App 時我們時常使用定時觸發的 timer &amp; 接收通知的 notification center， 不過它們卻暗藏可怕的陷阱，有可能讓 App 的記憶體愈用愈多，進而引發 App 因記憶體爆掉而閃退。
</section>
<section data-field="body" class="e-content">
<section name="dda2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a0f1" id="a0f1" class="graf graf--h3 graf--leading graf--title">利用 Combine 產生自動停止的 timer</h3><p name="3d75" id="3d75" class="graf graf--p graf-after--h3">開發 iOS App 時我們時常使用定時觸發的 timer &amp; 接收通知的 notification center， 不過它們卻暗藏可怕的陷阱，有可能讓 App 的記憶體愈用愈多，進而引發 App 因記憶體爆掉而閃退。</p><div name="59f8" id="59f8" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 capture list 解決 Timer &amp; NotificationCenter 造成的記憶體問題</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時我們時常使用定時的 timer &amp; 接收通知的 notification center， 不過它們其實暗藏了一個可怕的陷阱，有可能讓 App 的記憶體愈用愈多，進而引發 App 因記憶體爆掉而閃退。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ae37b1814cd1f359154e95448372fb0a" data-thumbnail-img-id="1*2u0slVtEfEtlNisLi1ozvw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*2u0slVtEfEtlNisLi1ozvw.jpeg);"></a></div><p name="8a17" id="8a17" class="graf graf--p graf-after--mixtapeEmbed">接下來讓我們先看看 SwiftUI 的 timer 問題，然後再利用 Combine 產生定時發送 value 的 timer publisher，它不只可以解決記憶體問題，還會在畫面關閉時自動停止。</p><h4 name="950b" id="950b" class="graf graf--h4 graf-after--p">SwiftUI 的 timer 問題</h4></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="2581" id="2581" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--h4" style="width: 50%;"><img class="graf-image" data-image-id="1*z7uw8jktZ6KJ7iliX-wWmQ.jpeg" data-width="818" data-height="1496" src="https://cdn-images-1.medium.com/max/600/1*z7uw8jktZ6KJ7iliX-wWmQ.jpeg"></figure><figure name="423c" id="423c" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 50%;"><img class="graf-image" data-image-id="1*jmq-aQS4IGUsndIcThUtUg.jpeg" data-width="818" data-height="1496" src="https://cdn-images-1.medium.com/max/600/1*jmq-aQS4IGUsndIcThUtUg.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="e21d" id="e21d" class="graf graf--p graf-after--figure">假設第一頁是 ContentView，點選 button somewhere in time 將顯示使用 timer 的 TimerView。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="a80e" id="a80e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {<br />    <br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showTimerView <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />    <br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">Button</span>(action: {<br />            showTimerView.toggle()<br />        }) {<br />            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;somewhere in time&quot;</span>)<br />                .font(.largeTitle)<br />        }<br />        .sheet(isPresented: <span class="hljs-variable">$showTimerView</span>) { <br />            <span class="hljs-type">TimerView</span>()<br />        }<br />    }<br />}</span></pre><p name="80c3" id="80c3" class="graf graf--p graf-after--pre">我們想測試 TimerView 是否因 timer 造成它無法死掉，然而 TimerView 是 struct，因此我們無法在 TimerView 裡定義 deinit 檢查。因此我們另外定義 class TestObject，然後在 TimerView 宣告 property testObject。到時候若 TimerView 能順利死掉，我們將看到 TestObject 的 deinit 印出。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="6c29" id="6c29" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestObject</span> {<br />    <span class="hljs-keyword">deinit</span> {<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;deinit&quot;</span>)<br />    }<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TimerView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> testObject <span class="hljs-operator">=</span> <span class="hljs-type">TestObject</span>()<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br />    <br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">VStack</span> {<br />            <span class="hljs-type">Image</span>(<span class="hljs-string">&quot;pic&quot;</span>)<br />            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(number)</span>&quot;</span>)<br />                .font(.largeTitle)<br />        }<br />        .onAppear {<br />            <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">1</span>, repeats: <span class="hljs-literal">true</span>) { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />                number <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />                <span class="hljs-built_in">print</span>(<span class="hljs-keyword">self</span>.number)<br />                <br />            }<br />        }<br />    }<br />}</span></pre><p name="240a" id="240a" class="graf graf--p graf-after--pre">當我們從 TimerView 回到 ContentView 時，我們發現 TimerView 的 timer 繼續勤勞地列印訊息，而且 TestObject 的 deinit 沒有觸發，因此很明顯地 timer 害 TimerView 無法死掉。</p><p name="af14" id="af14" class="graf graf--p graf-after--p">解決此問題有很多方法，以下我們介紹兩種方法，一種是在離開畫面時停止 timer，一種是利用 Combine。</p><h3 name="a484" id="a484" class="graf graf--h3 graf-after--p">在離開畫面時停止 timer</h3><p name="36f8" id="36f8" class="graf graf--p graf-after--h3">將 timer 儲存在 property timer，在 onDisappear 呼叫停止 timer 的 function invalidate。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="afaa" id="afaa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TimerView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> testObject <span class="hljs-operator">=</span> <span class="hljs-type">TestObject</span>()<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> timer: <span class="hljs-type">Timer</span>?<br /><br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">VStack</span> {<br />            <span class="hljs-type">Image</span>(<span class="hljs-string">&quot;pic&quot;</span>)<br />            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(number)</span>&quot;</span>)<br />                .font(.largeTitle)<br />        }<br />        .onAppear {<br />            timer <span class="hljs-operator">=</span> <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">1</span>, repeats: <span class="hljs-literal">true</span>) { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />                number <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />                <span class="hljs-built_in">print</span>(number)<br />                <br />            }<br />        }<br />        .onDisappear {<br />            timer<span class="hljs-operator">?</span>.invalidate()<br />        }<br />    }<br />}</span></pre><h3 name="c57d" id="c57d" class="graf graf--h3 graf-after--pre">使用 Combine 提供的 timer publisher</h3><p name="52d5" id="52d5" class="graf graf--p graf-after--h3">剛剛的方法需要另外呼叫停止 timer 的 invalidate，很容易不小心忘記。讓我們看看另一個更方便的方法，使用 Combine 提供的 timer publisher 產生能夠自動停止的 timer。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="319a" id="319a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> SwiftUI<br /><span class="hljs-keyword">import</span> Combine<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TimerView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> testObject <span class="hljs-operator">=</span> <span class="hljs-type">TestObject</span>()<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br />    <span class="hljs-keyword">let</span> timer <span class="hljs-operator">=</span> <span class="hljs-type">Timer</span>.publish(every: <span class="hljs-number">1</span>, on: .main, in: .common).autoconnect()<br /><br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">VStack</span> {<br />            <span class="hljs-type">Image</span>(<span class="hljs-string">&quot;pic&quot;</span>)<br />            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(number)</span>&quot;</span>)<br />                .font(.largeTitle)<br />        }<br />        .onReceive(timer, perform: { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />             number <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />             <span class="hljs-built_in">print</span>(number)<br />        })<br />        <br />    }<br />}</span></pre><p name="2328" id="2328" class="graf graf--p graf-after--pre">說明</p><ul class="postList"><li name="6bd7" id="6bd7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">產生 timer 的 publisher</strong></li></ul><p name="b3a5" id="b3a5" class="graf graf--p graf-after--li">combine 擴充了 timer 的功能，我們可以直接產生 timer 的 publisher，讓它定時發送 value。在此我們設定它每秒觸發一次。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="4706" id="4706" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> timer <span class="hljs-operator">=</span> <span class="hljs-type">Timer</span>.publish(every: <span class="hljs-number">1</span>, on: .main, in: .common).autoconnect()</span></pre><div name="660c" id="660c" class="graf graf--mixtapeEmbed graf-after--pre"><a href="https://developer.apple.com/documentation/foundation/timer/timerpublisher" data-href="https://developer.apple.com/documentation/foundation/timer/timerpublisher" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/foundation/timer/timerpublisher"><strong class="markup--strong markup--mixtapeEmbed-strong">Timer.TimerPublisher | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">A publisher that repeatedly emits the current date on a given interval.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/foundation/timer/timerpublisher" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="cd30534483460026d385b01b9a02688e" data-thumbnail-img-id="0*vqiPSR8pFePAE9xq" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*vqiPSR8pFePAE9xq);"></a></div><p name="abcb" id="abcb" class="graf graf--p graf-after--mixtapeEmbed">由於 timer 的 publisher 屬於必須先連接才能發送 value 的 publisher，所以我們呼叫 autoconnect，讓它可以自動連接，方便之後接收 timer 發送的 value。</p><ul class="postList"><li name="4a61" id="4a61" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">呼叫 onReceive(_:perform:) 接收 timer 每秒發送的 value</strong></li></ul><p name="4faa" id="4faa" class="graf graf--p graf-after--li">在 view 上呼叫 onReceive(_:perform:)，傳入 publisher timer，接收 timer 每秒發送的 value，perform 參數傳入 timer 定時觸發的 closure 程式。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9b39" id="9b39" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">.onReceive(timer, perform: { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />    number <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />    <span class="hljs-built_in">print</span>(number)<br />})</span></pre><p name="3df2" id="3df2" class="graf graf--p graf-after--pre">使用 onReceive(_:perform:) 定義 timer 觸發的 closure 將享有特別的好處，當 SwiftUI view 關閉後，timer 也會自動停止，不用另外呼叫 invalidate。</p><p name="7158" id="7158" class="graf graf--p graf-after--p">ps: 若是使用 combine 的 sink 接收 timer 發送的 value 則要處理記憶體的問題。</p><h3 name="5edf" id="5edf" class="graf graf--h3 graf-after--p">timer publisher 發送的 value 是時間</h3><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="a4bd" id="a4bd" class="graf graf--pre graf-after--h3 graf--preV2"><span class="pre--content"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerPublisher</span> : <span class="hljs-title class_">ConnectablePublisher</span> {<br />   <span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">Output</span> <span class="hljs-operator">=</span> <span class="hljs-type">Date</span></span></pre><p name="e92d" id="e92d" class="graf graf--p graf-after--pre">timer publisher 的型別是 TimerPublisher，從它的定義我們發現它發送的 value 型別是 Date，因此以下例子印出的 value 即是 timer 觸發的時間。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c726" id="c726" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">.onReceive(timer, perform: { (value) <span class="hljs-keyword">in</span><br />    <span class="hljs-built_in">print</span>(value)<br />})</span></pre><h3 name="c0c6" id="c0c6" class="graf graf--h3 graf-after--pre">在 UIKit controller 使用 timer publisher</h3><p name="59e9" id="59e9" class="graf graf--p graf-after--h3">在 UIKit controller 使用 timer publisher 也可以讓 timer 的程式更簡單。當 TimerViewController 畫面關閉時，timer 將自動停止，不用再呼叫 invalidate。不過利用 sink 接收 timer 發送的 value 時，記得要加上 capture list 的 [weak self]，否則會有 reference cycle 問題，造成不死的 TimerViewController 和永不停止的 timer。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="deb7" id="deb7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> UIKit<br /><span class="hljs-keyword">import</span> Combine<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <br />    <span class="hljs-keyword">var</span> cancellable: <span class="hljs-type">AnyCancellable</span>?<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br /><br />        cancellable <span class="hljs-operator">=</span> <span class="hljs-type">Timer</span>.publish(every: <span class="hljs-number">1</span>, on: .main, in: .common)<br />            .autoconnect()<br />            .sink {[<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br />                <span class="hljs-keyword">self</span>.view.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>(red: <span class="hljs-type">CGFloat</span>.random(in: <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">1</span>), green: <span class="hljs-number">0</span>, blue: <span class="hljs-number">0</span>, alpha: <span class="hljs-number">1</span>)<br />        }<br />        <br />    }<br />}</span></pre><h3 name="1cfa" id="1cfa" class="graf graf--h3 graf-after--pre">SwiftUI NotificationCenter 的記憶體問題</h3><p name="0440" id="0440" class="graf graf--p graf-after--h3">同樣的，NotificationCenter 也會有類似的問題。比方以下程式加了接收鍵盤出現和消失通知的 closure，在 closure 裡用到 self，因此造成不死的 NotificationView。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="e157" id="e157" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NotificationView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> testObject <span class="hljs-operator">=</span> <span class="hljs-type">TestObject</span>()<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> keyboardShow <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br /><br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">VStack</span> {<br />            <span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;name&quot;</span>, text: <span class="hljs-variable">$name</span>)<br />                .textFieldStyle(.roundedBorder)<br />                .padding()<br />            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;keyboard show <span class="hljs-subst">\(keyboardShow.description)</span>&quot;</span>)<br />                .font(.largeTitle)<br />        }<br />        .onAppear {<br />            <span class="hljs-type">NotificationCenter</span>.default.addObserver(forName: <span class="hljs-type">UIResponder</span>.keyboardDidShowNotification, object: <span class="hljs-literal">nil</span>, queue: .main) { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />                keyboardShow <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br />            }<br />            <span class="hljs-type">NotificationCenter</span>.default.addObserver(forName: <span class="hljs-type">UIResponder</span>.keyboardDidHideNotification, object: <span class="hljs-literal">nil</span>, queue: .main) { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />                keyboardShow <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />            }<br />        }<br />    }<br />}</span></pre></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="6fd2" id="6fd2" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--pre" style="width: 50%;"><img class="graf-image" data-image-id="1*Eb9EcFkFbO3QV6rVNV88yw.jpeg" data-width="818" data-height="1496" src="https://cdn-images-1.medium.com/max/600/1*Eb9EcFkFbO3QV6rVNV88yw.jpeg"></figure><figure name="5172" id="5172" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 50%;"><img class="graf-image" data-image-id="1*GRBe6vDbT-mxEma-vNyGsA.jpeg" data-width="818" data-height="1496" src="https://cdn-images-1.medium.com/max/600/1*GRBe6vDbT-mxEma-vNyGsA.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="be30" id="be30" class="graf graf--h3 graf-after--figure">使用 Combine 提供的 NotificationCenter publisher</h3><p name="bb6c" id="bb6c" class="graf graf--p graf-after--h3">NotificationCenter 跟 timer 一樣可以產生 publisher，因此我們可使用同樣的招式修正記憶體問題。</p><p name="b254" id="b254" class="graf graf--p graf-after--p">NotificationCenter 的 publisher 將在發送通知時傳送 value 給 receiver，我們利用 onReceive 接收 NotificationCenter 發送的 value，在 perform 參數傳入的 closure 定義收到 notification 時觸發的程式。</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="ee83" id="ee83" class="graf graf--pre graf-after--p graf--trailing graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NotificationView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-keyword">let</span> testObject <span class="hljs-operator">=</span> <span class="hljs-type">TestObject</span>()<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> keyboardShow <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br />    <span class="hljs-keyword">let</span> keyboardDidShowNotification <span class="hljs-operator">=</span> <span class="hljs-type">NotificationCenter</span>.default.publisher(for: <span class="hljs-type">UIResponder</span>.keyboardDidShowNotification)<br />    <span class="hljs-keyword">let</span> keyboardDidHideNotification <span class="hljs-operator">=</span> <span class="hljs-type">NotificationCenter</span>.default.publisher(for: <span class="hljs-type">UIResponder</span>.keyboardDidHideNotification)<br />    <br />    <br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">VStack</span> {<br />            <span class="hljs-type">TextField</span>(<span class="hljs-string">&quot;name&quot;</span>, text: <span class="hljs-variable">$name</span>)<br />                .textFieldStyle(.roundedBorder)<br />                .padding()<br />            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;keyboard show <span class="hljs-subst">\(keyboardShow.description)</span>&quot;</span>)<br />                .font(.largeTitle)<br />        }<br />        .onReceive(keyboardDidShowNotification, perform: { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />            keyboardShow <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br />            <br />        })<br />        .onReceive(keyboardDidHideNotification, perform: { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />            keyboardShow <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />                <br />        })<br />    }<br />}</span></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/653aac155fc5"><time class="dt-published" datetime="2020-04-26T04:43:00.636Z">April 26, 2020</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E5%88%A9%E7%94%A8-combine-%E8%A7%A3%E6%B1%BA-swiftui-timer-notificationcenter-%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-653aac155fc5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>