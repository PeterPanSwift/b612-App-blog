<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>JSONDecoder 解析時間的 DateDecodingStrategy</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">JSONDecoder 解析時間的 DateDecodingStrategy</h1>
</header>
<section data-field="subtitle" class="p-summary">
當我們利用 JSONDecoder 串接 API 回傳的 JSON 資料時，通常我們會將時間欄位的資料對應到 Date 型別，方便之後App 使用一些時間運算的 function。不過 API 回傳的時間有許多格式，因此我們須告訴 JSONDecoder…
</section>
<section data-field="body" class="e-content">
<section name="c9dd" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5cfd" id="5cfd" class="graf graf--h3 graf--leading graf--title">JSONDecoder 解析時間的 DateDecodingStrategy</h3><figure name="84d3" id="84d3" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*ReAitj-hKl0IxZ2546Jyeg.jpeg" data-width="1452" data-height="996" src="https://cdn-images-1.medium.com/max/800/1*ReAitj-hKl0IxZ2546Jyeg.jpeg"></figure><p name="7aa0" id="7aa0" class="graf graf--p graf-after--figure">當我們利用 JSONDecoder 串接 API 回傳的 JSON 資料時，通常我們會將時間欄位的資料對應到 Date 型別，方便之後App 使用一些時間運算的 function。不過 API 回傳的時間有許多格式，因此我們須告訴 JSONDecoder 時間的格式，它才能將時間解析後儲存成 Date 型別。</p><figure name="af8d" id="af8d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wPzl-VORzY_cAl8LlkyKKQ.jpeg" data-width="1046" data-height="952" src="https://cdn-images-1.medium.com/max/800/1*wPzl-VORzY_cAl8LlkyKKQ.jpeg"><figcaption class="imageCaption">以上三種 API 分別回傳不同的時間格式</figcaption></figure><h3 name="2dfe" id="2dfe" class="graf graf--h3 graf-after--figure">JSONDecoder 解析時間的 DateDecodingStrategy</h3><p name="f7be" id="f7be" class="graf graf--p graf-after--h3">我們可透過 JSONDecoder 的 dateDecodingStrategy 設定 JSON 的時間格式。</p><div name="6502" id="6502" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/foundation/jsondecoder/2895216-datedecodingstrategy" data-href="https://developer.apple.com/documentation/foundation/jsondecoder/2895216-datedecodingstrategy" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/foundation/jsondecoder/2895216-datedecodingstrategy"><strong class="markup--strong markup--mixtapeEmbed-strong">dateDecodingStrategy | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">The strategy used when decoding dates from part of a JSON object.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/foundation/jsondecoder/2895216-datedecodingstrategy" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="027a54bbc955fd190253adff59fbeefc" data-thumbnail-img-id="0*J5_BFoO5XzXla1U9" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*J5_BFoO5XzXla1U9);"></a></div><p name="6cb9" id="6cb9" class="graf graf--p graf-after--mixtapeEmbed">dateDecodingStrategy 的型別是 DateDecodingStrategy，我們可設定的格式有以下幾種，接下來讓我們以實際的例子介紹幾種常見的時間格式。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f4ce" id="f4ce" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">DateDecodingStrategy</span> {<br />    <span class="hljs-keyword">case</span> deferredToDate<br />    <span class="hljs-keyword">case</span> secondsSince1970<br />    <span class="hljs-keyword">case</span> millisecondsSince1970<br />    <span class="hljs-keyword">case</span> iso8601<br />    <span class="hljs-keyword">case</span> formatted(<span class="hljs-type">DateFormatter</span>)<br />    <span class="hljs-keyword">case</span> custom((<span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Date</span>)<br />}</span></pre><h3 name="0792" id="0792" class="graf graf--h3 graf-after--pre">iso8601</h3><p name="fc7a" id="fc7a" class="graf graf--p graf-after--h3">範例: iTunes API。</p><pre data-code-block-mode="0" spellcheck="false" name="a24b" id="a24b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">https://itunes.apple.com/search?term=beatles&amp;media=music</span></pre><p name="c552" id="c552" class="graf graf--p graf-after--pre">以下 releaseDate 的格式稱為 iso8601，內容為 1970–03–06T12:00:00Z，特點是日期跟時間中間有個 T，結尾有個 Z。</p><figure name="1ac3" id="1ac3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*a50cjwVOOW9-Ix6Jh8BNKQ.jpeg" data-width="986" data-height="264" src="https://cdn-images-1.medium.com/max/800/1*a50cjwVOOW9-Ix6Jh8BNKQ.jpeg"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6a7f" id="6a7f" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SearchResponse</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> results: [<span class="hljs-type">StoreItem</span>]<br />}<br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StoreItem</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> trackName: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> releaseDate: <span class="hljs-type">Date</span><br />}<br /><br /><span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br />decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .iso8601</span></pre><p name="04ac" id="04ac" class="graf graf--p graf-after--pre">將 dateDecodingStrategy 設為 iso8601。</p><h3 name="047d" id="047d" class="graf graf--h3 graf-after--p">secondsSince1970</h3><p name="e64c" id="e64c" class="graf graf--p graf-after--h3">範例: IG 資料。</p><pre data-code-block-mode="0" spellcheck="false" name="d370" id="d370" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">https://raw.githubusercontent.com/AppPeterPan/CutePic/main/rogerfederer.json</span></pre><p name="0791" id="0791" class="graf graf--p graf-after--pre">以下 taken_at_timestamp 的格式稱為 secondsSince1970，內容為 1663949997，它代表距離 1970.1.1 的秒數。</p><figure name="67cd" id="67cd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*W5lek8beJJVLHwps3uZoCw.png" data-width="596" data-height="202" src="https://cdn-images-1.medium.com/max/800/1*W5lek8beJJVLHwps3uZoCw.png"></figure><p name="a553" id="a553" class="graf graf--p graf-after--figure">當後台回傳的時間是一串數字時，有很大的機率是距離 1970.1.1 的秒數。我們也可以先在 Xcode playground 生成 Date，在參數 timeIntervalSince1970 傳入後台回傳的數字測試生成的 Date 是否合理。</p><figure name="d468" id="d468" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zomTZE9AUvmG_ny6LWj1nw.png" data-width="1562" data-height="88" src="https://cdn-images-1.medium.com/max/800/1*zomTZE9AUvmG_ny6LWj1nw.png"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="5768" id="5768" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IGResult</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> graphql: <span class="hljs-type">Graphql</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graphql</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> user: <span class="hljs-type">User</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> edgeOwnerToTimelineMedia: <span class="hljs-type">TimelineMedia</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TimelineMedia</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> edges: [<span class="hljs-type">Edge</span>]<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> node: <span class="hljs-type">Node</span><br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> takenAtTimestamp: <span class="hljs-type">Date</span><br />}<br /><br /><span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br />decoder.keyDecodingStrategy <span class="hljs-operator">=</span> .convertFromSnakeCase<br />decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .secondsSince1970</span></pre><p name="c226" id="c226" class="graf graf--p graf-after--pre">將 dateDecodingStrategy 設為 secondsSince1970。</p><h3 name="9431" id="9431" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">millisecondsSince1970</strong></h3><p name="1b0d" id="1b0d" class="graf graf--p graf-after--h3">範例: covid19uk API。</p><pre data-code-block-mode="0" spellcheck="false" name="e1e2" id="e1e2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">https://api.covid19uk.live/historyfigures</span></pre><p name="ebe6" id="ebe6" class="graf graf--p graf-after--pre">此 API 目前已經失效，不過從下圖可看出之前抓到的 JSON 資料。以下 date 的格式稱為 millisecondsSince1970，內容為 1580428200000，它代表距離 1970.1.1 的毫秒數。一秒等於 1000 毫秒，因此 1580428200000 毫秒等於 1580428200 秒。</p><figure name="6696" id="6696" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tMS5UWeEJJ9JbiXHdDLftw.jpeg" data-width="668" data-height="432" src="https://cdn-images-1.medium.com/max/800/1*tMS5UWeEJJ9JbiXHdDLftw.jpeg"></figure><p name="2ff1" id="2ff1" class="graf graf--p graf-after--figure">前面提過後台回傳的時間是一串數字時，有很大的機率是距離 1970.1.1 的秒數，不過它也可能是距離 1970.1.1 的毫秒數。因此如果以 secondsSince1970 得到數字很大的不正常時間時，記得再用 millisecondsSince1970 試試。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9b64" id="9b64" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CovidData</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> data: [<span class="hljs-type">Record</span>]<br />}<br /><br /><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Record</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> date: <span class="hljs-type">Date</span><br />}<br /><br /><span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br />decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .millisecondsSince1970</span></pre><p name="eaba" id="eaba" class="graf graf--p graf-after--pre">將 dateDecodingStrategy 設為 millisecondsSince1970。</p><h3 name="9ea0" id="9ea0" class="graf graf--h3 graf-after--p">formatted</h3><p name="3533" id="3533" class="graf graf--p graf-after--h3">範例: 口罩 API。</p><pre data-code-block-mode="0" spellcheck="false" name="a43c" id="a43c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">https://quality.data.gov.tw/dq_download_json.php?nid=116285&amp;md5_url=2150b333756e64325bdbc4a5fd45fad1</span></pre><p name="4e5f" id="4e5f" class="graf graf--p graf-after--pre">以下來源資料時間的格式是後台自訂的格式，內容為 2020/04/15 14:54:00。JSONDecoder 沒那麼聰明，無法解析後台自訂的格式，因此我們必須透過 DateFormatter 幫助 JSONDecoder 看懂它的格式。</p><figure name="6417" id="6417" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ECjak1zCNHedP3z0aO1NNw.jpeg" data-width="806" data-height="188" src="https://cdn-images-1.medium.com/max/800/1*ECjak1zCNHedP3z0aO1NNw.jpeg"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0446" id="0446" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mask</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> time: <span class="hljs-type">Date</span><br />    <br />    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CodingKeys</span>: <span class="hljs-title class_">String</span>, <span class="hljs-title class_">CodingKey</span>  {<br />        <span class="hljs-keyword">case</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;醫事機構名稱&quot;</span><br />        <span class="hljs-keyword">case</span> time <span class="hljs-operator">=</span> <span class="hljs-string">&quot;來源資料時間&quot;</span><br />    }<br />}<br /><br /><span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br /><span class="hljs-keyword">let</span> dateFormatter <span class="hljs-operator">=</span> <span class="hljs-type">DateFormatter</span>()<br />dateFormatter.dateFormat <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span><br />decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .formatted(dateFormatter)</span></pre><p name="c16c" id="c16c" class="graf graf--p graf-after--pre">將 dateDecodingStrategy 設為 formatted，傳入自訂的 DateFormatter。</p><p name="1d8a" id="1d8a" class="graf graf--p graf-after--p">其它例子:</p><div name="daea" id="daea" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/dateformatter-dateformat-%E7%9A%84%E9%80%83%E8%84%AB%E5%AD%97%E4%B8%B2-5832fc0551de" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/dateformatter-dateformat-%E7%9A%84%E9%80%83%E8%84%AB%E5%AD%97%E4%B8%B2-5832fc0551de" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/dateformatter-dateformat-%E7%9A%84%E9%80%83%E8%84%AB%E5%AD%97%E4%B8%B2-5832fc0551de"><strong class="markup--strong markup--mixtapeEmbed-strong">DateFormatter dateFormat 的逃脫字串</strong><br><em class="markup--em markup--mixtapeEmbed-em">最近有同學研究可愛的貓咪 API，發現它 JSON 裡的時間格式特別奇怪。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/dateformatter-dateformat-%E7%9A%84%E9%80%83%E8%84%AB%E5%AD%97%E4%B8%B2-5832fc0551de" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="9378308671c8d9737f05b84852c0fce1" data-thumbnail-img-id="1*YUHbWAevCU7joXOCMVax7g.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*YUHbWAevCU7joXOCMVax7g.png);"></a></div><h3 name="5194" id="5194" class="graf graf--h3 graf-after--mixtapeEmbed">custom</h3><p name="40fe" id="40fe" class="graf graf--p graf-after--h3">以下圖為例，createdAt 的格式是帶有小數點秒數的 iso8601，內容為 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">2020–04–15T04:24:20.683Z</strong></code>，但剛剛介紹的 iso8601 只能解析沒有小數點的 iso8601。</p><p name="2758" id="2758" class="graf graf--p graf-after--p">ps: iOS 26 開始，iso8601 可以處理小數點的秒數，舊版的 iOS 則要透過 custom 另外處理。</p><figure name="afd3" id="afd3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*b50FOQyqV_s_z5vK38Iptw.jpeg" data-width="834" data-height="174" src="https://cdn-images-1.medium.com/max/800/1*b50FOQyqV_s_z5vK38Iptw.jpeg"></figure><p name="da96" id="da96" class="graf graf--p graf-after--figure">此時我們有兩種解法。我們可用剛剛介紹的 formatted，在 dateFormat 設定時間格式。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1e3c" id="1e3c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DemoData</span>: <span class="hljs-title class_">Decodable</span> {<br />    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span><br />    <span class="hljs-keyword">let</span> createdAt: <span class="hljs-type">Date</span><br />}<br /><br /><span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br /><span class="hljs-keyword">let</span> dateFormatter <span class="hljs-operator">=</span> <span class="hljs-type">DateFormatter</span>()<br />dateFormatter.dateFormat <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&quot;</span><br />decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .formatted(dateFormatter)</span></pre><p name="f107" id="f107" class="graf graf--p graf-after--pre">我們也可以用另一種方法，使用 custom 搭配 iOS SDK 的 ISO8601DateFormatter 解析帶有小數點的 iso8601。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="a238" id="a238" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> decoder <span class="hljs-operator">=</span> <span class="hljs-type">JSONDecoder</span>()<br /><span class="hljs-keyword">let</span> dateFormatter <span class="hljs-operator">=</span> <span class="hljs-type">ISO8601DateFormatter</span>()<br />dateFormatter.formatOptions <span class="hljs-operator">=</span> [.withInternetDateTime, .withFractionalSeconds]<br />decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .custom({ decoder <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.singleValueContainer()<br />    <span class="hljs-keyword">let</span> dateString <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br />    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> dateFormatter.date(from: dateString) {<br />        <span class="hljs-keyword">return</span> date<br />    } <span class="hljs-keyword">else</span> {<br />        <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;&quot;</span>)<br />    }<br />})</span></pre><p name="a956" id="a956" class="graf graf--p graf-after--pre">說明:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1772" id="1772" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> dateFormatter <span class="hljs-operator">=</span> <span class="hljs-type">ISO8601DateFormatter</span>()<br />dateFormatter.formatOptions <span class="hljs-operator">=</span> [.withInternetDateTime, .withFractionalSeconds]</span></pre><p name="a4ec" id="a4ec" class="graf graf--p graf-after--pre">在 ISO8601DateFormatter 的 formatOptions 裡傳入 withFractionalSeconds，代表 iso8601 有小數點的秒數。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3880" id="3880" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">decoder.dateDecodingStrategy <span class="hljs-operator">=</span> .custom({ decoder <span class="hljs-keyword">in</span><br />    <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.singleValueContainer()<br />    <span class="hljs-keyword">let</span> dateString <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br />    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> date <span class="hljs-operator">=</span> dateFormatter.date(from: dateString) {<br />        <span class="hljs-keyword">return</span> date<br />    } <span class="hljs-keyword">else</span> {<br />        <span class="hljs-keyword">throw</span> <span class="hljs-type">DecodingError</span>.dataCorruptedError(in: container, debugDescription: <span class="hljs-string">&quot;&quot;</span>)<br />    }<br />})</span></pre><p name="c8e8" id="c8e8" class="graf graf--p graf-after--pre">JSONDecoder 解析 JSON 時，當它遇到我們宣告為 Date 型別的欄位，比方例子裡的 createdAt，它會透過我們在 custom 傳入的 closure 解析。<code class="markup--code markup--p-code">decoder.singleValueContainer()</code> 將取得 createdAt 的內容，由於它是字串，所以我們先用 <code class="markup--code markup--p-code">container.decode(String.self)</code> 得到它的字串，然後再透過 <code class="markup--code markup--p-code">dateFormatter.date(from: dateString)</code> 將字串變成 Date。若是失敗則丟出 DecodingError。</p><div name="b5b7" id="b5b7" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-withfractionalseconds-%E8%A7%A3%E6%9E%90-iso-8601-%E5%B8%B6%E6%9C%89%E5%B0%8F%E6%95%B8%E7%9A%84%E7%A7%92-c0fa3e02ee99" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-withfractionalseconds-%E8%A7%A3%E6%9E%90-iso-8601-%E5%B8%B6%E6%9C%89%E5%B0%8F%E6%95%B8%E7%9A%84%E7%A7%92-c0fa3e02ee99" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-withfractionalseconds-%E8%A7%A3%E6%9E%90-iso-8601-%E5%B8%B6%E6%9C%89%E5%B0%8F%E6%95%B8%E7%9A%84%E7%A7%92-c0fa3e02ee99"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 withFractionalSeconds 解析 ISO 8601 帶有小數的秒</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，我們可以用 ISO8601DateFormatter 解析 ISO 8601 格式的字串，然而 ISO 8601 有許多格式，比方以下格式我們可以順利解析</em>medium.co</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-withfractionalseconds-%E8%A7%A3%E6%9E%90-iso-8601-%E5%B8%B6%E6%9C%89%E5%B0%8F%E6%95%B8%E7%9A%84%E7%A7%92-c0fa3e02ee99" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-withfractionalseconds-%E8%A7%A3%E6%9E%90-iso-8601-%E5%B8%B6%E6%9C%89%E5%B0%8F%E6%95%B8%E7%9A%84%E7%A7%92-c0fa3e02ee99" class="markup--anchor markup--mixtapeEmbed-anchor">Sw</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-withfractionalseconds-%E8%A7%A3%E6%9E%90-iso-8601-%E5%B8%B6%E6%9C%89%E5%B0%8F%E6%95%B8%E7%9A%84%E7%A7%92-c0fa3e02ee99" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="62a37e47470a52b0181daf4629d6f6ed" data-thumbnail-img-id="1*Yp0yG2ohlR2WnyfTNjZgdw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*Yp0yG2ohlR2WnyfTNjZgdw.jpeg);"></a></div><h3 name="33fa" id="33fa" class="graf graf--h3 graf-after--mixtapeEmbed">利用 DateDecodingStrategy.custom 處理多種時間格式的 JSON</h3><div name="364a" id="364a" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-datedecodingstrategy-custom-%E8%99%95%E7%90%86%E5%A4%9A%E7%A8%AE%E6%99%82%E9%96%93%E6%A0%BC%E5%BC%8F%E7%9A%84-json-97d50f1df013" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-datedecodingstrategy-custom-%E8%99%95%E7%90%86%E5%A4%9A%E7%A8%AE%E6%99%82%E9%96%93%E6%A0%BC%E5%BC%8F%E7%9A%84-json-97d50f1df013" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-datedecodingstrategy-custom-%E8%99%95%E7%90%86%E5%A4%9A%E7%A8%AE%E6%99%82%E9%96%93%E6%A0%BC%E5%BC%8F%E7%9A%84-json-97d50f1df013"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 DateDecodingStrategy.custom 處理多種時間格式的 JSON</strong><br><em class="markup--em markup--mixtapeEmbed-em">透過 DateDecodingStrategy 提供的各種 case，我們可以處理多種時間格式的 JSON 資料，比方 iso8601 和 secondsSince1970。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-datedecodingstrategy-custom-%E8%99%95%E7%90%86%E5%A4%9A%E7%A8%AE%E6%99%82%E9%96%93%E6%A0%BC%E5%BC%8F%E7%9A%84-json-97d50f1df013" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="133a75994467bea3b12ea945d962958f" data-thumbnail-img-id="1*G9KaJ6pALIfLPuxoLjQpAg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*G9KaJ6pALIfLPuxoLjQpAg.png);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/a4095481f193"><time class="dt-published" datetime="2020-04-16T04:18:38.963Z">April 16, 2020</time></a>.</p><p><a href="https://medium.com/@apppeterpan/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>