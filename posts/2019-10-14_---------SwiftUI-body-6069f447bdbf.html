<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>視情況聰明更新的 SwiftUI body</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">視情況聰明更新的 SwiftUI body</h1>
</header>
<section data-field="subtitle" class="p-summary">
SwiftUI 用狀態決定如何顯示和更新畫面，當我們在 property 前加上 @State 時，SwiftUI 將認為此 property 代表某種影響畫面內容的狀態。當狀態改變時，畫面將馬上更新，重新生成 body 裡受它影響的元件。
</section>
<section data-field="body" class="e-content">
<section name="fe9b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5884" id="5884" class="graf graf--h3 graf--leading graf--title">視情況聰明更新的 SwiftUI body</h3><p name="1527" id="1527" class="graf graf--p graf-after--h3">SwiftUI 用狀態決定如何顯示和更新畫面，當我們在 property 前加上 @State 時，SwiftUI 將認為此 property 代表某種影響畫面內容的狀態。當狀態改變時，畫面將馬上更新，重新生成 body 裡受它影響的元件。</p><p name="9d8a" id="9d8a" class="graf graf--p graf-after--p">也許有人會擔心，當畫面比較複雜時，property body 裡將生成很多 UI 元件，如果常常更新重新執行 body 裡的程式，豈不是會大大影響 App 的效能 ？</p><p name="fd90" id="fd90" class="graf graf--p graf-after--p">其實 SwiftUI 是很聰明的，它會判斷此次更新將影響哪些元件，只會重新產生那些受影響的元件，接下來就讓我們透過一些例子見證 SwiftUI 的小聰明吧。</p><h3 name="e352" id="e352" class="graf graf--h3 graf-after--p">畫面上的元件不受影響，因此不會更新 body</h3><p name="30aa" id="30aa" class="graf graf--p graf-after--h3">以下程式在點擊 button 時利用亂數更新 state property isRain，決定是否下雨。然而我們的畫面卻跟 isRain 無關，不管 isRain 是 true 還是 false，畫面都顯示雨天，因此雖然 state property 改變了，SwiftUI 並不會浪費時間重新生成畫面的元件。就算我們按了 button 100 次，create WeatherView body &amp; create MoonStar body 都只會印出一次。</p><pre name="280d" id="280d" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">struct WeatherView: View {</strong></pre><pre name="17ac" id="17ac" class="graf graf--pre graf-after--pre"> <strong class="markup--strong markup--pre-strong">  @State private var isRain = true</strong></pre><pre name="5208" id="5208" class="graf graf--pre graf-after--pre">   var body: some View {</pre><pre name="1cc0" id="1cc0" class="graf graf--pre graf-after--pre">     <strong class="markup--strong markup--pre-strong"> print(&quot;create WeatherView body&quot;)</strong></pre><pre name="f2bc" id="f2bc" class="graf graf--pre graf-after--pre">      return VStack {</pre><pre name="b532" id="b532" class="graf graf--pre graf-after--pre">         Image(systemName: &quot;cloud.rain.fill&quot;)</pre><pre name="ddd5" id="ddd5" class="graf graf--pre graf-after--pre">            .resizable()</pre><pre name="8f3f" id="8f3f" class="graf graf--pre graf-after--pre">            .frame(width: 100, height: 100)</pre><pre name="deac" id="deac" class="graf graf--pre graf-after--pre">         Text(&quot;我們淋著大雨不知何時才能放晴&quot;)</pre><pre name="9722" id="9722" class="graf graf--pre graf-after--pre">         Button(&quot;今天天氣如何 ?&quot;) {</pre><pre name="a21d" id="a21d" class="graf graf--pre graf-after--pre">         <strong class="markup--strong markup--pre-strong">   self.isRain = Bool.random()</strong></pre><pre name="80f3" id="80f3" class="graf graf--pre graf-after--pre">         }</pre><pre name="3247" id="3247" class="graf graf--pre graf-after--pre">         MoonStar()</pre><pre name="fac0" id="fac0" class="graf graf--pre graf-after--pre">      }</pre><pre name="02df" id="02df" class="graf graf--pre graf-after--pre">   }</pre><pre name="4d16" id="4d16" class="graf graf--pre graf-after--pre">}<br><br></pre><pre name="c694" id="c694" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">struct MoonStar: View {</strong></pre><pre name="bb1a" id="bb1a" class="graf graf--pre graf-after--pre">    var body: some View {</pre><pre name="a4e1" id="a4e1" class="graf graf--pre graf-after--pre">     <strong class="markup--strong markup--pre-strong">  print(&quot;create MoonStar body&quot;)</strong></pre><pre name="2412" id="2412" class="graf graf--pre graf-after--pre">       return Image(systemName: &quot;moon.stars.fill&quot;)</pre><pre name="0d88" id="0d88" class="graf graf--pre graf-after--pre">           .resizable()</pre><pre name="9916" id="9916" class="graf graf--pre graf-after--pre">           .frame(width: 100, height: 100)</pre><pre name="2adb" id="2adb" class="graf graf--pre graf-after--pre">           .foregroundColor(.yellow)</pre><pre name="9054" id="9054" class="graf graf--pre graf-after--pre">           .padding()</pre><pre name="779c" id="779c" class="graf graf--pre graf-after--pre">           .background(Color.black)</pre><pre name="3905" id="3905" class="graf graf--pre graf-after--pre">           .clipShape(Circle())</pre><pre name="7ed9" id="7ed9" class="graf graf--pre graf-after--pre">    }</pre><pre name="e518" id="e518" class="graf graf--pre graf-after--pre">}</pre><p name="148e" id="148e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">App 執行</strong></p><figure name="8cef" id="8cef" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3Ruq2v0aL2nEmmKaEUybqA.jpeg" data-width="548" data-height="162" src="https://cdn-images-1.medium.com/max/800/1*3Ruq2v0aL2nEmmKaEUybqA.jpeg"></figure><figure name="7908" id="7908" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*TaZ5Tdr9SUvMRc0bfIh__w.jpeg" data-width="834" data-height="1432" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*TaZ5Tdr9SUvMRc0bfIh__w.jpeg"></figure><h3 name="e1d9" id="e1d9" class="graf graf--h3 graf-after--figure">畫面元件受影響而更新的 WeatherView body</h3><p name="380b" id="380b" class="graf graf--p graf-after--h3">我們希望 isRain true 時顯示晴天的圖文，isRain false 時顯示雨天的圖文，因此每當天氣改變時 ，WeatherView body 將重新生成需要更新的元件，比方 <code class="markup--code markup--p-code">Image(systemName: &quot;cloud.rain.fill&quot;)</code> &amp; <code class="markup--code markup--p-code">Text(&quot;我們淋著大雨不知何時才能放晴&quot;)</code>。</p><pre name="4368" id="4368" class="graf graf--pre graf-after--p">struct WeatherView: View {</pre><pre name="37e5" id="37e5" class="graf graf--pre graf-after--pre">   @State private var isRain = true</pre><pre name="4d34" id="4d34" class="graf graf--pre graf-after--pre">   var body: some View {</pre><pre name="3a6a" id="3a6a" class="graf graf--pre graf-after--pre">     <strong class="markup--strong markup--pre-strong"> print(&quot;create WeatherView body，下雨嗎 \(self.isRain)&quot;)</strong></pre><pre name="0b1e" id="0b1e" class="graf graf--pre graf-after--pre">      return VStack {</pre><pre name="43cb" id="43cb" class="graf graf--pre graf-after--pre">       <strong class="markup--strong markup--pre-strong">  if isRain {</strong></pre><pre name="5e72" id="5e72" class="graf graf--pre graf-after--pre">            Image(systemName: &quot;cloud.rain.fill&quot;)</pre><pre name="d0f7" id="d0f7" class="graf graf--pre graf-after--pre">               .resizable()</pre><pre name="475b" id="475b" class="graf graf--pre graf-after--pre">               .frame(width: 100, height: 100)</pre><pre name="b813" id="b813" class="graf graf--pre graf-after--pre">            Text(&quot;我們淋著大雨不知何時才能放晴&quot;)</pre><pre name="8b3c" id="8b3c" class="graf graf--pre graf-after--pre">         } else {</pre><pre name="b7ed" id="b7ed" class="graf graf--pre graf-after--pre">            Image(systemName: &quot;sun.max.fill&quot;)</pre><pre name="a4ac" id="a4ac" class="graf graf--pre graf-after--pre">               .resizable()</pre><pre name="eada" id="eada" class="graf graf--pre graf-after--pre">               .frame(width: 100, height: 100)</pre><pre name="245d" id="245d" class="graf graf--pre graf-after--pre">            Text(&quot;太陽公公出來了，他對我呀笑呀笑&quot;)</pre><pre name="28ac" id="28ac" class="graf graf--pre graf-after--pre">         }</pre><pre name="5556" id="5556" class="graf graf--pre graf-after--pre">         Button(&quot;今天天氣如何 ?&quot;) {</pre><pre name="4779" id="4779" class="graf graf--pre graf-after--pre">            self.isRain = Bool.random()</pre><pre name="f718" id="f718" class="graf graf--pre graf-after--pre">          <strong class="markup--strong markup--pre-strong">  print(&quot;今天天氣如何，下雨嗎 \(self.isRain)&quot;)</strong></pre><pre name="e0f1" id="e0f1" class="graf graf--pre graf-after--pre">         }</pre><pre name="d40b" id="d40b" class="graf graf--pre graf-after--pre">         MoonStar()</pre><pre name="b6f5" id="b6f5" class="graf graf--pre graf-after--pre">      }</pre><pre name="e107" id="e107" class="graf graf--pre graf-after--pre">   }</pre><pre name="0b21" id="0b21" class="graf graf--pre graf-after--pre">}</pre><p name="6806" id="6806" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">App 執行</strong></p><p name="3742" id="3742" class="graf graf--p graf-after--p">當我們點選 button 多次後，Console 印出的內容如下。我們可看出 SwiftUI 十分聰明，當 isRain 沒變，比方連續好幾次都亂數到 false 時，畫面不需要更新，所以 create WeatherView body 不會印出。</p><p name="b200" id="b200" class="graf graf--p graf-after--p">此外最下方顯示的月亮星星不受天氣影響，所以 MoonStar 只在一開始生成，create MoonStar body 只印出一次。</p><figure name="c747" id="c747" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BqNpaNt5CXKLmMczp1yFog.jpeg" data-width="836" data-height="488" src="https://cdn-images-1.medium.com/max/800/1*BqNpaNt5CXKLmMczp1yFog.jpeg"></figure></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="9cc5" id="9cc5" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--figure" style="width: 50%;"><img class="graf-image" data-image-id="1*KXsxwEOQDXLYGPxf__6UAA.jpeg" data-width="834" data-height="1432" src="https://cdn-images-1.medium.com/max/600/1*KXsxwEOQDXLYGPxf__6UAA.jpeg"></figure><figure name="c72a" id="c72a" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 50%;"><img class="graf-image" data-image-id="1*tZEgiNDMjUmtquTE4wjakw.jpeg" data-width="834" data-height="1432" src="https://cdn-images-1.medium.com/max/600/1*tZEgiNDMjUmtquTE4wjakw.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="36cc" id="36cc" class="graf graf--h3 graf-after--figure">視情況同時更新 WeatherView &amp; MoonStar 的 body</h3><p name="2d92" id="2d92" class="graf graf--p graf-after--h3">剛剛的例子 MoonStar 完全不受天氣影響，所以畫面更新時完全沒它的事。不過我們也可以依天氣情況顯示不同的圖片。</p></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="2cc9" id="2cc9" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--p" style="width: 54.138%;"><img class="graf-image" data-image-id="1*iZT-GtQY_SXT8lgAQgxgkQ.jpeg" data-width="262" data-height="252" src="https://cdn-images-1.medium.com/max/800/1*iZT-GtQY_SXT8lgAQgxgkQ.jpeg"></figure><figure name="09b0" id="09b0" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 45.862%;"><img class="graf-image" data-image-id="1*v_sOzLBxHudG4dthvIRvwg.jpeg" data-width="238" data-height="270" src="https://cdn-images-1.medium.com/max/600/1*v_sOzLBxHudG4dthvIRvwg.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="c152" id="c152" class="graf graf--p graf-after--figure">MoonStar 裡多了判斷是否下雨的 property isRain，Image 將依據是否下雨顯示不同圖片。</p><pre name="dbc6" id="dbc6" class="graf graf--pre graf-after--p">struct MoonStar: View {<br>    var isRain: Bool<br>    var body: some View {<br>        <strong class="markup--strong markup--pre-strong">print(&quot;create MoonStar body，下雨嗎 \(isRain)&quot;)<br>        return Image(systemName: isRain ? &quot;cloud.moon.rain.fill&quot; : &quot;moon.stars.fill&quot;)</strong><br>            .resizable()<br>            .frame(width: 100, height: 100)<br>            .foregroundColor(.yellow)<br>            .padding()<br>            .background(Color.black)<br>            .clipShape(Circle())<br>    }<br>}</pre><p name="dba4" id="dba4" class="graf graf--p graf-after--pre">WeatherView 的 body 在生成 MoonStar 時傳入 isRain，告訴它是否下雨。</p><figure name="d9a9" id="d9a9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jLnsB1k1CGLGKRg5GEPwfg.jpeg" data-width="1364" data-height="716" src="https://cdn-images-1.medium.com/max/800/1*jLnsB1k1CGLGKRg5GEPwfg.jpeg"></figure><p name="a34c" id="a34c" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">App 執行</strong></p><p name="0b40" id="0b40" class="graf graf--p graf-after--p">當我們點選 button 多次後，Console 印出的內容如下。我們可看出當天氣改變，isRain 有變化時，MoonStar 也會更新它 body 的內容。</p><figure name="22fa" id="22fa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Ypp5VdaVwY_K6eUUxeDSEg.jpeg" data-width="828" data-height="602" src="https://cdn-images-1.medium.com/max/800/1*Ypp5VdaVwY_K6eUUxeDSEg.jpeg"></figure></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="f586" id="f586" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--figure" style="width: 50%;"><img class="graf-image" data-image-id="1*LDfAtP9_UnWBb2xSWq47pw.jpeg" data-width="834" data-height="1432" src="https://cdn-images-1.medium.com/max/600/1*LDfAtP9_UnWBb2xSWq47pw.jpeg"></figure><figure name="1587" id="1587" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure graf--trailing" style="width: 50%;"><img class="graf-image" data-image-id="1*CXFmvauREDu7tfvHM67o1g.jpeg" data-width="834" data-height="1432" src="https://cdn-images-1.medium.com/max/600/1*CXFmvauREDu7tfvHM67o1g.jpeg"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/6069f447bdbf"><time class="dt-published" datetime="2019-10-14T07:02:21.660Z">October 14, 2019</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E8%A6%96%E6%83%85%E6%B3%81%E8%81%B0%E6%98%8E%E6%9B%B4%E6%96%B0%E7%9A%84-swiftui-body-6069f447bdbf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>