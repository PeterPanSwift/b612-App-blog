<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>使用 async/await 或 DispatchQueue.global 呈現演算法和迴圈動畫</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">使用 async/await 或 DispatchQueue.global 呈現演算法和迴圈動畫</h1>
</header>
<section data-field="subtitle" class="p-summary">
學習演算法和多層迴圈時，若能將程式執行的過程以動畫呈現，往往能幫助我們更容易理解背後的原理。因此之前有一本演算法圖鑑大受歡迎，它除了有精彩的圖片解說，還搭配 App 呈現生動的動畫。
</section>
<section data-field="body" class="e-content">
<section name="bf2a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1c98" id="1c98" class="graf graf--h3 graf--leading graf--title">使用 async/await 或 DispatchQueue.global 呈現演算法和迴圈動畫</h3><p name="660d" id="660d" class="graf graf--p graf-after--h3">學習演算法和多層迴圈時，若能將程式執行的過程以動畫呈現，往往能幫助我們更容易理解背後的原理。因此之前有一本演算法圖鑑大受歡迎，它除了有精彩的圖片解說，還搭配 App 呈現生動的動畫。</p><div name="edad" id="edad" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.books.com.tw/products/0010771263" data-href="https://www.books.com.tw/products/0010771263" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.books.com.tw/products/0010771263"><strong class="markup--strong markup--mixtapeEmbed-strong">演算法圖鑑：26種演算法 + 7種資料結構，人工智慧、數據分析、邏輯思考的原理和應用全圖解</strong><br><em class="markup--em markup--mixtapeEmbed-em">書名：演算法圖鑑：26種演算法 + 7種資料結構，人工智慧、數據分析、邏輯思考的原理和應用全圖解，原文名稱：アルゴリズム図鑑：絵で見てわかる…</em>www.books.com.tw</a><a href="https://www.books.com.tw/products/0010771263" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="33d821eac4ba52b1737996a4e7b7b75a" data-thumbnail-img-id="0*SxUYZspb9B0ewpHC" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*SxUYZspb9B0ewpHC);"></a></div><div name="d924" id="d924" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://apps.apple.com/tw/app/algorithms-explained-animated/id1047532631" data-href="https://apps.apple.com/tw/app/algorithms-explained-animated/id1047532631" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://apps.apple.com/tw/app/algorithms-explained-animated/id1047532631"><strong class="markup--strong markup--mixtapeEmbed-strong">‎Algorithms: Explained&amp;Animated</strong><br><em class="markup--em markup--mixtapeEmbed-em">‎Enjoy watching, trying, and learning with this guide to algorithms. The wide-ranging field of algorithms is explained…</em>apps.apple.com</a><a href="https://apps.apple.com/tw/app/algorithms-explained-animated/id1047532631" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="077edbd87a2406e49d2235e1d03fb2e4" data-thumbnail-img-id="0*9xJE9l5MMpWARXRi" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*9xJE9l5MMpWARXRi);"></a></div><figure name="d535" id="d535" class="graf graf--figure graf-after--mixtapeEmbed"><img class="graf-image" data-image-id="1*ZyMFOXum30Fe6HPeGH41cQ.png" data-width="1125" data-height="2436" src="https://cdn-images-1.medium.com/max/800/1*ZyMFOXum30Fe6HPeGH41cQ.png"></figure><p name="de49" id="de49" class="graf graf--p graf-after--figure">最近研究了一下，從 Swift 將程式執行的過程變成動畫有許多方法，比方以下三種。</p><ul class="postList"><li name="38a9" id="38a9" class="graf graf--li graf-after--p">使用 async/await &amp; Task.sleep。</li><li name="0dd3" id="0dd3" class="graf graf--li graf-after--li">使用 DispatchQueue.global().async &amp; Thread.sleep。</li><li name="3592" id="3592" class="graf graf--li graf-after--li">使用 Timer。</li></ul><p name="a8e6" id="a8e6" class="graf graf--p graf-after--li">以下彼得潘以 bubbleSort 為例，說明如何實現類似演算法圖鑑的排序過程動畫。我們將實現以下的 App 畫面，排序過程中天平圖片將移動到它比較的數字下，當天平左邊數字大於右邊時則進行數字的交換。</p><figure name="ed72" id="ed72" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zAlTpZjJmYln3mGujpQJvw.png" data-width="1230" data-height="1208" src="https://cdn-images-1.medium.com/max/800/1*zAlTpZjJmYln3mGujpQJvw.png"></figure><h3 name="cdd0" id="cdd0" class="graf graf--h3 graf-after--figure">定義資料型別 Number</h3><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1a14" id="1a14" class="graf graf--pre graf-after--h3 graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span>: <span class="hljs-title class_">Identifiable</span> {<br />    <span class="hljs-keyword">let</span> id <span class="hljs-operator">=</span> <span class="hljs-type">UUID</span>()<br />    <span class="hljs-keyword">let</span> value: <span class="hljs-type">Int</span><br />}</span></pre><h3 name="91d2" id="91d2" class="graf graf--h3 graf-after--pre">定義呈現演算法動畫的 ContentView</h3><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7d14" id="7d14" class="graf graf--pre graf-after--h3 graf--preV2"><span class="pre--content"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> numbers <span class="hljs-operator">=</span> [<br />        <span class="hljs-type">Number</span>(value: <span class="hljs-number">3</span>),<br />        <span class="hljs-type">Number</span>(value: <span class="hljs-number">2</span>),<br />        <span class="hljs-type">Number</span>(value: <span class="hljs-number">5</span>),<br />        <span class="hljs-type">Number</span>(value: <span class="hljs-number">1</span>)<br />    ]<br />    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> checkIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br /><br />    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {<br />        <span class="hljs-type">Grid</span> {<br />            <span class="hljs-type">GridRow</span> {<br />                <span class="hljs-type">ForEach</span>(numbers) { number <span class="hljs-keyword">in</span><br />                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(number.value)</span>&quot;</span>)<br />                        .frame(width: <span class="hljs-number">50</span>, height: <span class="hljs-number">50</span>)<br />                        .background(.gray)<br />                }<br />            }<br />            <br />            <span class="hljs-type">GridRow</span> {<br />                <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>checkIndex, id: \.<span class="hljs-keyword">self</span>) { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br />                    <span class="hljs-type">Color</span>.clear<br />                        .frame(width: <span class="hljs-number">50</span>, height: <span class="hljs-number">50</span>)<br />                }<br />                <span class="hljs-type">Image</span>(<span class="hljs-string">&quot;balance&quot;</span>)<br />                    .resizable()<br />                    .scaledToFit()<br />                    .frame(width: <span class="hljs-number">100</span>)<br />                    .gridCellColumns(<span class="hljs-number">2</span>)<br />            }<br />            <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Run&quot;</span>) {<br />                <span class="hljs-type">Task</span> {<br />                    <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> bubbleSort()<br />                }<br />            }<br />        }<br />    }</span></pre><p name="28ee" id="28ee" class="graf graf--p graf-after--pre">為了讓天平出現在比較的兩個數字下方，我們以 Grid &amp; GridRow 排版畫面，並將天平的 gridCellColumns 設為 2。</p><h3 name="3a77" id="3a77" class="graf graf--h3 graf-after--p">定義排序的演算法 bubbleSort</h3><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="e137" id="e137" class="graf graf--pre graf-after--h3 graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">bubbleSort</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> {<br />    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span>numbers.count<span class="hljs-operator">-</span><span class="hljs-number">1</span> {<br />        <span class="hljs-keyword">var</span> isSwap <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numbers.count<span class="hljs-operator">-</span>i {<br />            withAnimation {<br />                checkIndex <span class="hljs-operator">=</span> j<br />            }<br />            <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(for: .seconds(<span class="hljs-number">0.5</span>))<br />            <span class="hljs-keyword">if</span> numbers[j].value <span class="hljs-operator">&gt;</span> numbers[j<span class="hljs-operator">+</span><span class="hljs-number">1</span>].value {<br />                isSwap <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br />                withAnimation {<br />                    numbers.swapAt(j, j<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br />                }<br />            }<br />            <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(for: .seconds(<span class="hljs-number">1</span>))<br />         }<br />         <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>isSwap {<br />            <span class="hljs-keyword">return</span><br />         }<br />    }<br />}</span></pre><p name="2513" id="2513" class="graf graf--p graf-after--pre">為了將排序的過程一步步顯示到畫面上，我們利用 <code class="markup--code markup--p-code">await Task.sleep</code> 暫停程式。在第二層的 for 裡，我們先更新 checkIndex，讓天平移動到比較的兩個數字下方，然後暫停 0.5 秒。接著進行數字的比較，當前面的數字大於後面的數字時，進行數字的交換，然後再暫停 1 秒，之後才繼續 for 的下一輪運算。</p><h3 name="e004" id="e004" class="graf graf--h3 graf-after--p">執行 App</h3><figure name="8eff" id="8eff" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*S41WcwuBIHuJa3Hl_bBSNQ.gif" data-width="295" data-height="640" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*S41WcwuBIHuJa3Hl_bBSNQ.gif"></figure><h3 name="a981" id="a981" class="graf graf--h3 graf-after--figure">另一種寫法: 使用 DispatchQueue.global().async &amp; Thread.sleep</h3><p name="0f44" id="0f44" class="graf graf--p graf-after--h3">在背景執行 bubbleSort。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f03c" id="f03c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Run&quot;</span>) {<br />    <span class="hljs-type">DispatchQueue</span>.global().async {<br />        bubbleSort()<br />    }                <br />}</span></pre><p name="5a64" id="5a64" class="graf graf--p graf-after--pre">bubbleSort 暫停的程式改成呼叫 Thread.sleep。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="720d" id="720d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">bubbleSort</span>() {<br />    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span>numbers.count<span class="hljs-operator">-</span><span class="hljs-number">1</span> {<br />        <span class="hljs-keyword">var</span> isSwap <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br />        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>numbers.count<span class="hljs-operator">-</span>i {<br />            withAnimation {<br />                checkIndex <span class="hljs-operator">=</span> j<br />            }<br />            <span class="hljs-type">Thread</span>.sleep(forTimeInterval: <span class="hljs-number">0.5</span>)<br />            <span class="hljs-keyword">if</span> numbers[j].value <span class="hljs-operator">&gt;</span> numbers[j<span class="hljs-operator">+</span><span class="hljs-number">1</span>].value {<br />                isSwap <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br />                withAnimation {<br />                    numbers.swapAt(j, j<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br />                }<br />            }<br />            <span class="hljs-type">Thread</span>.sleep(forTimeInterval: <span class="hljs-number">1</span>)<br />        }<br />        <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>isSwap {<br />            <span class="hljs-keyword">return</span><br />        }<br />    }<br />}</span></pre><h3 name="f042" id="f042" class="graf graf--h3 graf-after--pre">其它範例: nested loop 畫星星的動畫</h3><div name="8a3f" id="8a3f" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E-swiftui-%E5%8D%B3%E6%99%82%E9%A0%90%E8%A6%BD%E8%BF%B4%E5%9C%88%E5%9F%B7%E8%A1%8C%E9%81%8E%E7%A8%8B-%E4%BD%BF%E7%94%A8-task-sleep-2a3073dc933e" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E-swiftui-%E5%8D%B3%E6%99%82%E9%A0%90%E8%A6%BD%E8%BF%B4%E5%9C%88%E5%9F%B7%E8%A1%8C%E9%81%8E%E7%A8%8B-%E4%BD%BF%E7%94%A8-task-sleep-2a3073dc933e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E-swiftui-%E5%8D%B3%E6%99%82%E9%A0%90%E8%A6%BD%E8%BF%B4%E5%9C%88%E5%9F%B7%E8%A1%8C%E9%81%8E%E7%A8%8B-%E4%BD%BF%E7%94%A8-task-sleep-2a3073dc933e"><strong class="markup--strong markup--mixtapeEmbed-strong">從 SwiftUI 即時預覽迴圈執行的過程 — 使用 Task.sleep</strong><br><em class="markup--em markup--mixtapeEmbed-em">彼得潘之前在教學時，發現 nested loop 對初學者是個滿大的難題，因為比較不容易觀看每一步執行的過程。而 SwiftUI 剛好有方便的即時預覽功能，因此接下來我們將介紹如何利用 SwiftUI 幫助初學者更了解 nested…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E-swiftui-%E5%8D%B3%E6%99%82%E9%A0%90%E8%A6%BD%E8%BF%B4%E5%9C%88%E5%9F%B7%E8%A1%8C%E9%81%8E%E7%A8%8B-%E4%BD%BF%E7%94%A8-task-sleep-2a3073dc933e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a3ccb94168dab327333d0880473cc8fb" data-thumbnail-img-id="1*6ISKTKWeZJFo4kLnCsOC8Q.gif" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*6ISKTKWeZJFo4kLnCsOC8Q.gif);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/a8032365c5b9"><time class="dt-published" datetime="2023-01-23T16:01:45.194Z">January 23, 2023</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E4%BD%BF%E7%94%A8-async-await-task-sleep-%E5%91%88%E7%8F%BE%E6%BC%94%E7%AE%97%E6%B3%95%E5%92%8C%E8%BF%B4%E5%9C%88%E5%8B%95%E7%95%AB-a8032365c5b9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>