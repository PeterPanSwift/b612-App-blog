<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>讓 closure 在 function 外繼續使用的 @escaping &amp; self 副作用</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">讓 closure 在 function 外繼續使用的 @escaping &amp; self 副作用</h1>
</header>
<section data-field="subtitle" class="p-summary">
@escaping 是個讓 closure 在 function 外繼續使用的特別語法。它有點難懂，但你卻不能忽略，因為 iOS SDK 裡不少 function 的參數都加了 @escaping。在了解它的神奇功能前，先讓我們看看以下例子，認識它幫我們解決的問題。
</section>
<section data-field="body" class="e-content">
<section name="d1f1" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f57a" id="f57a" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">讓 closure 在 function 外繼續使用的 @escaping &amp; self </strong>副作用</h3><p name="7787" id="7787" class="graf graf--p graf-after--h3">@escaping 是個讓 closure 在 function 外繼續使用的特別語法。它有點難懂，但你卻不能忽略，因為 iOS SDK 裡不少 function 的參數都加了 @escaping。在了解它的神奇功能前，先讓我們看看以下例子，認識它幫我們解決的問題。</p><h3 name="6d0a" id="6d0a" class="graf graf--h3 graf-after--p">認識 @escaping</h3><figure name="c70f" id="c70f" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*UvV_gpJJGHh1zvldvHW1CQ.png" data-width="1768" data-height="862" src="https://cdn-images-1.medium.com/max/800/1*UvV_gpJJGHh1zvldvHW1CQ.png"></figure><p name="c3c8" id="c3c8" class="graf graf--p graf-after--figure">如圖所示，將 activity 儲存到 favoriteActivity 會產生紅色錯誤，這是因為 Swift 認為傳入 function 的 function 型別參數，比方例子裡印出打桌球的 closure，只是為了在 function 裡執行，function 執行完後就沒有利用價值，應該甩了它，不該在 function 執行完後繼續使用，所以它不讓我們將 activity 儲存到 favoriteActivity。若能儲存，即代表剛剛例子裡的 cuteBaby 在執行完 outsideActivity 後可以呼叫 favoriteActivity，執行當初 closure 的程式，印出打桌球。</p><p name="69fd" id="69fd" class="graf graf--p graf-after--p">想讓 Swift 知道我們對傳入 function 的 closure 動了真感情，想在 function 執行完後繼續使用，很簡單，只要在參數宣告前加上 @escaping 即可。英文 escape 的意思是逃脫，所以就像它名字表達的，@escaping 可讓 closure 從 function 逃脫，function 執行完後仍可繼續使用。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2386" id="2386" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;peter&quot;</span><br />    <span class="hljs-keyword">var</span> favoriteActivity: (() -&gt; <span class="hljs-type">Void</span>)<span class="hljs-operator">!</span><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">outsideActivity</span>(<span class="hljs-params">activity</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-type">Void</span>) {<br />        activity()<br />        favoriteActivity <span class="hljs-operator">=</span> activity<br />    }<br />}<br /><br /><span class="hljs-keyword">var</span> cuteBaby <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br />cuteBaby.outsideActivity {<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打桌球&quot;</span>)<br />}<br />cuteBaby.favoriteActivity()<br />cuteBaby.favoriteActivity()<br />cuteBaby.favoriteActivity()</span></pre><p name="3e78" id="3e78" class="graf graf--p graf-after--pre">function outsideActivity 的參數 activity 加了 escaping，因此當 outsideActivity 執行完後，activity 的程式仍然可以使用。我們將 activity 存到 favoriteActivity，因此當 function outsideActivity 執行完後，我們可以繼續呼叫 favoriteActivity 打很多次桌球，總共會印出 4 次打桌球。</p><pre name="5e31" id="5e31" class="graf graf--pre graf-after--p">打桌球<br>打桌球<br>打桌球<br>打桌球</pre><h3 name="8ec0" id="8ec0" class="graf graf--h3 graf-after--pre">@escaping 的副作用: 存取自己的屬性或方法時須加 self</h3><p name="794e" id="794e" class="graf graf--p graf-after--h3">@escaping 幫我們解決問題，但也帶來一些副作用，就像止痛藥一樣。例如以下例子，當你想在 closure 的 { } 裡存取物件自己的屬性或方法時，必須額外加上 self，否則會產生紅色錯誤，出現以下錯誤訊息</p><pre name="b4ba" id="b4ba" class="graf graf--pre graf-after--p">Reference to property xxx in closure requires explicit use of self to make capture semantics explicit</pre><figure name="62ba" id="62ba" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*nID53ynb3OZ7P_gNiGR45w.png" data-width="1786" data-height="960" src="https://cdn-images-1.medium.com/max/800/1*nID53ynb3OZ7P_gNiGR45w.png"></figure><p name="cc3f" id="cc3f" class="graf graf--p graf-after--figure">加 self 跟 ARC 有關，因為加了 @escaping，closure 的程式之後還會執行，所以要加 self 提醒 ARC 增加 self 的 reference count，如此才不會在 closure 程式執行時 self 已經死掉，無法存取 self 的 property 或 method。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="7629" id="7629" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;peter&quot;</span><br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">outsideActivity</span>(<span class="hljs-params">activity</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-type">Void</span>) {<br />        activity()<br />    }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wendy&quot;</span><br />    <span class="hljs-keyword">var</span> child <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />        child.outsideActivity {<br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span>和小孩<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.child.name)</span>打桌球&quot;</span>)<br />        }<br />    }<br />}</span></pre><h3 name="b1aa" id="b1aa" class="graf graf--h3 graf-after--pre">iOS SDK 的 escaping 參數例子</h3><p name="8f73" id="8f73" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">URLSession 抓取網路資料的 function dataTask</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="85db" id="85db" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">dataTask</span>(<span class="hljs-params">with</span> <span class="hljs-params">url</span>: <span class="hljs-type">URL</span>, <br /><span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Data</span>?, <span class="hljs-type">URLResponse</span>?, <span class="hljs-type">Error</span>?) -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">URLSessionDataTask</span></span></pre><p name="0d69" id="0d69" class="graf graf--p graf-after--pre">參數 completionHandler 有 escaping， 為什麼呢 ?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="aedc" id="aedc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> urlString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://wakelandtheatre.files.wordpress.com/2013/11/final-poster.jpg&quot;</span><br /><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) {<br />    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;get data&quot;</span>)<br />        <br />    }.resume()<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after dataTask&quot;</span>)<br />}</span></pre><p name="e0ba" id="e0ba" class="graf graf--p graf-after--pre">以上程式會先印出 after dataTask，再印出 get data，因為 function dataTask 執行完會先回傳 task，然後我們呼叫 task 的 resume 啟動它，等資料抓到時才會執行 completionHandler。</p><p name="0003" id="0003" class="graf graf--p graf-after--p">因此參數 completionHandler 將在 function dataTask 執行完後過一段時間才執行，所以它要加上 escaping，如此才能在 function dataTask 執行完後執行 completionHandler。</p><p name="bb6b" id="bb6b" class="graf graf--p graf-after--p">也因為加了 escaping，我們在 closure 裡存取自己的 property imageView 時要加上 self，例如以下例子。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f157" id="f157" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <br />    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> imageView: <span class="hljs-type">UIImageView</span>!<br />    <br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        <span class="hljs-keyword">let</span> urlString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://wakelandtheatre.files.wordpress.com/2013/11/final-poster.jpg&quot;</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) {<br />           <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />              <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data,<br />                 <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) {<br />                  <span class="hljs-type">DispatchQueue</span>.main.async {<br />                     <span class="hljs-keyword">self</span>.imageView.image <span class="hljs-operator">=</span> image<br />                  }<br />              }<br />           }.resume()<br />        }<br />    }<br />}</span></pre><p name="48ad" id="48ad" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Timer 的動畫 function scheduledTimer</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8274" id="8274" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">scheduledTimer</span>(<span class="hljs-title class_">withTimeInterval</span> <span class="hljs-title class_">interval</span>: <span class="hljs-title class_">TimeInterval</span>, <span class="hljs-title class_">repeats</span>: <span class="hljs-title class_">Bool</span>, <span class="hljs-title class_">block</span>: @<span class="hljs-title class_">escaping</span> (<span class="hljs-title class_">Timer</span>) -&gt; <span class="hljs-title class_">Void</span>) -&gt; <span class="hljs-title class_">Timer</span></span></pre><p name="1a19" id="1a19" class="graf graf--p graf-after--pre">參數 block 有 escaping，為什麼呢 ?</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3b46" id="3b46" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">1</span>, repeats: <span class="hljs-literal">true</span>) { timer <span class="hljs-keyword">in</span><br />    <span class="hljs-built_in">print</span>(timer.fireDate)<br />}<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after scheduledTimer&quot;</span>)</span></pre><p name="1ea4" id="1ea4" class="graf graf--p graf-after--pre">以上程式的 scheduledTimer 會先執行完，然後先印出 after scheduledTimer，之後再每隔 1 秒執行 closure 的程式，印出 timer 觸發的時間。</p><p name="815c" id="815c" class="graf graf--p graf-after--p">因此參數 block 將在 function scheduledTimer 執行完每隔 1 秒執行，所以它要加上 escaping，如此才能在 function scheduledTimer 執行完後執行 block。</p><p name="2ced" id="2ced" class="graf graf--p graf-after--p">也因為加了 escaping，我們在 closure 裡存取自己的 property label 時要加上 self，例如以下例子。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f54e" id="f54e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />        <br />    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> label: <span class="hljs-type">UILabel</span>!<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        <br />        <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">1</span>, repeats: <span class="hljs-literal">true</span>) { timer <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">self</span>.label.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(timer.fireDate)</span>&quot;</span><br />        }<br />    }<br />}</span></pre><h3 name="533e" id="533e" class="graf graf--h3 graf-after--pre">沒有 escaping，存取自己的屬性或方法不須加 self</h3><p name="3c96" id="3c96" class="graf graf--p graf-after--h3">相反的，當參數沒有 @escaping 時，傳入的 closure 在存取自己的屬性時，你愛加不加 self 都可以。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="900c" id="900c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;peter&quot;</span><br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">outsideActivity</span>(<span class="hljs-params">activity</span>: () -&gt; <span class="hljs-type">Void</span>) {<br />        activity()<br />    }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wendy&quot;</span><br />    <span class="hljs-keyword">var</span> child <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />        child.outsideActivity {<br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span>和小孩<span class="hljs-subst">\(child.name)</span>打桌球&quot;</span>)<br />        }<br />    }<br />}</span></pre><h3 name="5ad2" id="5ad2" class="graf graf--h3 graf-after--pre">optional 的 function 型別參數預設是 @escaping</h3><p name="988e" id="988e" class="graf graf--p graf-after--h3">以上應該就是 @escaping 的故事吧。等等，當參數是 optional 時，故事又有了轉折。當參數是 optional 時，Swift 將認定此參數是 @escaping，所以在 closure 的 { } 裡存取物件自己的屬性時，一樣要加上 self。</p><figure name="a354" id="a354" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*S9HJ3tGApFzJypYMvy1oRg.png" data-width="1774" data-height="1000" src="https://cdn-images-1.medium.com/max/800/1*S9HJ3tGApFzJypYMvy1oRg.png"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="ffb1" id="ffb1" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baby</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;peter&quot;</span><br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">outsideActivity</span>(<span class="hljs-params">activity</span>: (() -&gt; <span class="hljs-type">Void</span>)<span class="hljs-operator">?</span>) {<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> activity {<br />            activity()<br />        }<br />    }<br />}<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span> {<br />    <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wendy&quot;</span><br />    <span class="hljs-keyword">var</span> child <span class="hljs-operator">=</span> <span class="hljs-type">Baby</span>()<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />        child.outsideActivity {<br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span>和小孩<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.child.name)</span>打桌球&quot;</span>)<br />        }<br />    }<br />}</span></pre><p name="3a6b" id="3a6b" class="graf graf--p graf-after--pre">iOS SDK 例子:</p><p name="caa7" id="caa7" class="graf graf--p graf-after--p">function present 的參數 completion 是 optional，因此預設是 escaping。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="17f0" id="17f0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">present</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">viewControllerToPresent</span>: <span class="hljs-type">UIViewController</span>, <br />    <span class="hljs-params">animated</span> <span class="hljs-params">flag</span>: <span class="hljs-type">Bool</span>, <span class="hljs-params">completion</span>: (() -&gt; <span class="hljs-type">Void</span>)<span class="hljs-operator">?</span> <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>)</span></pre><p name="bfa6" id="bfa6" class="graf graf--p graf-after--pre">以下程式的 number 要加上 self，因為 completion 是 escaping。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b195" id="b195" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br /><br />    <span class="hljs-keyword">@IBAction</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">tap</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sender</span>: <span class="hljs-keyword">Any</span>) {<br />        <br />        <span class="hljs-keyword">let</span> controller <span class="hljs-operator">=</span> <span class="hljs-type">UIViewController</span>()<br />        present(controller, animated: <span class="hljs-literal">true</span>) {<br />            <span class="hljs-keyword">self</span>.number <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />        }<br />    }<br />    <br />}</span></pre><p name="91b3" id="91b3" class="graf graf--p graf-after--pre">值得注意的，當 function 型別的參數是 optional 時，它預設就是 escaping。如果我們畫蛇添足，另外再加上 @escaping， 將會出現可怕的紅色錯誤，顯示 <code class="markup--code markup--p-code">Closure is already escaping in optional type argument</code>。</p><figure name="2c80" id="2c80" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lcXGiMPC5Yyinpw4uGhUKA.png" data-width="1442" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*lcXGiMPC5Yyinpw4uGhUKA.png"></figure><h3 name="91e2" id="91e2" class="graf graf--h3 graf-after--figure">Allow implicit self for weak self captures, after self is unwrapped</h3><div name="b7ea" id="b7ea" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c" data-href="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c"><strong class="markup--strong markup--mixtapeEmbed-strong">Allow implicit self for weak self captures, after self is unwrapped — SE-0365</strong><br><em class="markup--em markup--mixtapeEmbed-em">從 Xcode 14.3 的 Swift 5.8 開始，Apple 在 SE-0365 推出了貼心的新功能，當 weak self 已經被 unwrapped 後，我們可以在接下來的程式省略 self。</em>apppeterpan.medium.com</a><a href="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a53a1f13fc42e32ad0a34a56e09a41b2" data-thumbnail-img-id="1*JM8B9xczlN9xhiyxTmVt_A.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*JM8B9xczlN9xhiyxTmVt_A.png);"></a></div><h3 name="ca70" id="ca70" class="graf graf--h3 graf-after--mixtapeEmbed">在 @escaping closures 加上 implicit self 的 Swift 5.3</h3><div name="b1f3" id="b1f3" class="graf graf--mixtapeEmbed graf-after--h3 graf--trailing"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade"><strong class="markup--strong markup--mixtapeEmbed-strong">在 @escaping closures 加上 implicit self 的 Swift 5.3</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，當我們遇到 @escaping closures 時，往往需要輸入煩人的 self，例如以下骰子亂數的例子:</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="05b4a6ff88f35de06527d53f5b565bb1" data-thumbnail-img-id="1*UC6ijPjaH0pyAEOV6bg7sA.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*UC6ijPjaH0pyAEOV6bg7sA.jpeg);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/40d50b17f75b"><time class="dt-published" datetime="2017-10-17T14:08:56.334Z">October 17, 2017</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E8%AE%93-closure-%E5%9C%A8-function-%E5%A4%96%E7%B9%BC%E7%BA%8C%E4%BD%BF%E7%94%A8%E7%9A%84-escaping-40d50b17f75b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>