<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>利用 capture list 解決 closure 可能產生的記憶體問題</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">利用 capture list 解決 closure 可能產生的記憶體問題</h1>
</header>
<section data-field="subtitle" class="p-summary">
開發 iOS App 時，我們時常使用強大的 closure 語法。然而就像 spider man，能力愈大，責任愈大，強大的 closure 有時會產生麻煩的記憶體問題。
</section>
<section data-field="body" class="e-content">
<section name="023d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="869d" id="869d" class="graf graf--h3 graf--leading graf--title">利用 capture list 解決 closure 可能產生的記憶體問題</h3><p name="cadb" id="cadb" class="graf graf--p graf-after--h3">開發 iOS App 時，我們時常使用強大的 closure 語法。然而就像 spider man，能力愈大，責任愈大，強大的 closure 有時會產生麻煩的記憶體問題。</p><p name="4361" id="4361" class="graf graf--p graf-after--p">接下來就讓我們瞧瞧 closure 如何產生記憶體問題吧。</p><h3 name="e0a0" id="e0a0" class="graf graf--h3 graf-after--p">增加物件 reference count 的 closure</h3><ul class="postList"><li name="1354" id="1354" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">Dog 類別</strong></li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="16c8" id="16c8" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> Foundation<br /><span class="hljs-keyword">import</span> os<br /><span class="hljs-keyword">let</span> logger <span class="hljs-operator">=</span> <span class="hljs-type">Logger</span>()<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {<br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>() {<br />        logger.log(<span class="hljs-string">&quot;追追追&quot;</span>)<br />    }<br />    <span class="hljs-keyword">deinit</span> {<br />        logger.log(<span class="hljs-string">&quot;主人，我即將死去，謝謝你愛過我&quot;</span>)<br />    }<br />}</span></pre><p name="1c00" id="1c00" class="graf graf--p graf-after--pre">為了顯示訊息列印的時間，我們利用 Logger 列印訊息。</p><div name="288d" id="288d" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-logger-%E5%8D%B0%E5%87%BA%E5%8C%85%E5%90%AB%E6%99%82%E9%96%93%E7%9A%84-debug-%E8%A8%8A%E6%81%AF-f5018134d61f" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-logger-%E5%8D%B0%E5%87%BA%E5%8C%85%E5%90%AB%E6%99%82%E9%96%93%E7%9A%84-debug-%E8%A8%8A%E6%81%AF-f5018134d61f" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-logger-%E5%8D%B0%E5%87%BA%E5%8C%85%E5%90%AB%E6%99%82%E9%96%93%E7%9A%84-debug-%E8%A8%8A%E6%81%AF-f5018134d61f"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 Logger 印出包含時間的 debug 訊息</strong><br><em class="markup--em markup--mixtapeEmbed-em">Apple 在 iOS 14 推出更方便列印訊息的 Logger 物件，它有許多比 print 厲害的地方，有興趣的可參考以下 Apple 官方的連結。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-logger-%E5%8D%B0%E5%87%BA%E5%8C%85%E5%90%AB%E6%99%82%E9%96%93%E7%9A%84-debug-%E8%A8%8A%E6%81%AF-f5018134d61f" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b1b19da4cb7fe4d6518f2d5721fadac8" data-thumbnail-img-id="1*ogQWMleBe-2jgOL7RoHNgw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*ogQWMleBe-2jgOL7RoHNgw.png);"></a></div><ul class="postList"><li name="4f8b" id="4f8b" class="graf graf--li graf-after--mixtapeEmbed"><strong class="markup--strong markup--li-strong">ViewController 類別</strong></li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2513" id="2513" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> UIKit<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br /><br />   <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />        <span class="hljs-keyword">let</span> cuteDog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br />        logger.log(<span class="hljs-string">&quot;小狗出生&quot;</span>)<br />        <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) { timer <span class="hljs-keyword">in</span><br />            cuteDog.run()<br />        }<br />        logger.log(<span class="hljs-string">&quot;function play 結束&quot;</span>)<br />    }<br />    <br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        play()<br />    }<br />}</span></pre><p name="ba74" id="ba74" class="graf graf--p graf-after--pre">呼叫 play，在 play 裡產生 Dog，然後設定 timer 5 秒後觸發。</p><p name="b6de" id="b6de" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">結果。</strong></p><p name="1df1" id="1df1" class="graf graf--p graf-after--p">記得要勾選 Timestamp 才能看到時間。</p><figure name="f139" id="f139" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9gEEXx7I1r3eZsCzfuBRZw.png" data-width="570" data-height="245" src="https://cdn-images-1.medium.com/max/800/1*9gEEXx7I1r3eZsCzfuBRZw.png"></figure><figure name="4fd8" id="4fd8" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*r1ms53xeS0mqRjdc4Pwzdg.png" data-width="527" data-height="269" src="https://cdn-images-1.medium.com/max/800/1*r1ms53xeS0mqRjdc4Pwzdg.png"></figure><p name="f665" id="f665" class="graf graf--p graf-after--figure">從印出的結果，我們發現 viewDidLoad 執行完時是 22:11:24，然而小狗死亡的訊息卻在 5 秒後(22:11:29)，timer 的 closure 程式執行完，小狗跑步印出”追追追”後才出現。看來小狗會等到 closure 執行完才死去，這和我們的直覺相反。照理說指到小狗的 cuteDog 在 function play 裡宣告，在 play 執行完 cuteDog 被清掉時，小狗就該死去呀。</p><p name="74b6" id="74b6" class="graf graf--p graf-after--p">小狗，為什麼你還不死呢 ~</p><p name="c3ed" id="c3ed" class="graf graf--p graf-after--p">小狗能繼續活著的救命恩人正是 closure，因為我們在 closure 裡使用 cuteDog，所以它的 reference count 將被增加，確保到時 closure 執行時，cuteDog 還活著，等到 timer 的 closure 5 秒後跑完時小狗才會死。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="936d" id="936d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) { timer <span class="hljs-keyword">in</span><br />    cuteDog.run()<br />}</span></pre><p name="8ebb" id="8ebb" class="graf graf--p graf-after--pre">因此當我們在 closure 裡使用物件時，它將對物件產生兩個重要的影響:</p><ul class="postList"><li name="325f" id="325f" class="graf graf--li graf-after--p">增加物件的 reference count。</li><li name="44f4" id="44f4" class="graf graf--li graf-after--li">當 closure 的程式執行完，不會再執行時，物件的 reference count 才會減少。</li></ul><p name="c9fe" id="c9fe" class="graf graf--p graf-after--li">相反的，若是 timer 的 closure 裡沒有使用 cuteDog，將不會增加小狗的 reference count，因此小狗將在 play 執行完時死去。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b1dd" id="b1dd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />    <span class="hljs-keyword">let</span> cuteDog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br />    logger.log(<span class="hljs-string">&quot;小狗出生&quot;</span>)<br />    <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) { timer <span class="hljs-keyword">in</span><br />        logger.log(<span class="hljs-string">&quot;timer 結束&quot;</span>)<br />    }<br />    logger.log(<span class="hljs-string">&quot;function play 結束&quot;</span>)<br />}</span></pre><p name="095d" id="095d" class="graf graf--p graf-after--pre">結果</p><pre name="05e9" id="05e9" class="graf graf--pre graf-after--p">2021-01-08 02:14:00.163748+0800 Demo2[12009:715842] 小狗出生<br>2021-01-08 02:14:00.163984+0800 Demo2[12009:715842] function play 結束<br>2021-01-08 02:14:00.164083+0800 Demo2[12009:715842] 主人，我即將死去，謝謝你愛過我<br>2021-01-08 02:14:05.165119+0800 Demo2[12009:715842] timer 結束</pre><p name="69b5" id="69b5" class="graf graf--p graf-after--pre">Swift 如此貼心的舉動，我們很感激。但這不一定是我們要的，如果你希望 closure 不要增加 cuteDog 的 reference count，capture list 將是你的救星。利用 capture list，我們可以告訴 closure，某某變數(常數)不關心(在乎)物件，請不要增加物件的 reference count。</p><h3 name="68dd" id="68dd" class="graf graf--h3 graf-after--p">利用 capture list 阻止 closure 增加物件的 reference count</h3><p name="a734" id="a734" class="graf graf--p graf-after--h3">capture list 的表達方式很簡單，在 closure 的 { } 裡，一開頭加上 [ ]，在其中指定不關心物件的變數(常數)，並搭配 unowned 或 weak，若有多個變數(常數)，只要以逗號分隔即可。</p><p name="2920" id="2920" class="graf graf--p graf-after--p">因此剛剛的例子，只要加上 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">[weak cuteDog]</strong></code>，closure 將不再增加 cuteDog 的 reference count。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="38b4" id="38b4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />    <span class="hljs-keyword">let</span> cuteDog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br />    logger.log(<span class="hljs-string">&quot;小狗出生&quot;</span>)<br />    <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) {[<span class="hljs-keyword">weak</span> cuteDog] timer <span class="hljs-keyword">in</span><br />        cuteDog<span class="hljs-operator">?</span>.run()<br />    }<br />    logger.log(<span class="hljs-string">&quot;function play 結束&quot;</span>)<br />}</span></pre><p name="aaab" id="aaab" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">結果:</strong></p><pre name="d70a" id="d70a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">2021-01-07 23:40:10.226145+0800 Demo2[10909:559761] 小狗出生</strong></pre><pre name="4bd5" id="4bd5" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-07 23:40:10.226305+0800 Demo2[10909:559761] function play 結束</strong></pre><pre name="d170" id="d170" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-07 23:40:10.226394+0800 Demo2[10909:559761] 主人，我即將死去，謝謝你愛過我</strong></pre><p name="1ad0" id="1ad0" class="graf graf--p graf-after--pre">加了 capture list <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">[weak cuteDog]</strong></code><strong class="markup--strong markup--p-strong"> </strong>後，function play 執行結束時，小狗也跟著死去，因此 closure 5 秒後執行時，cuteDog 已變成 nil(因為 weak 的關係)，不會執行 function run，<code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">追追追</strong></code>也不會印出。</p><h3 name="8a1e" id="8a1e" class="graf graf--h3 graf-after--p">搭配 guard let</h3><p name="01bd" id="01bd" class="graf graf--p graf-after--h3">當我們在 capture list 使用 weak 時，closure 執行時物件可能已經死去，因此以下例子的 run，eat &amp; sleep 可能都不會執行，而且呼叫時還要搭配 optional chaining。(因為 weak 將讓 cuteDog 變成 optional)</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="3c2a" id="3c2a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />    <span class="hljs-keyword">let</span> cuteDog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br />    logger.log(<span class="hljs-string">&quot;小狗出生&quot;</span>)<br />    <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) {[<span class="hljs-keyword">weak</span> cuteDog] timer <span class="hljs-keyword">in</span><br />        cuteDog<span class="hljs-operator">?</span>.run()<br />        cuteDog<span class="hljs-operator">?</span>.eat()<br />        cuteDog<span class="hljs-operator">?</span>.sleep()<br />    }<br />    logger.log(<span class="hljs-string">&quot;function play 結束&quot;</span>)<br />}</span></pre><p name="5d56" id="5d56" class="graf graf--p graf-after--pre">如果想在發現物件死掉時提早離開 closure，我們也可以搭配 guard let，例如以下例子:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="856e" id="856e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>() {<br />    <span class="hljs-keyword">let</span> cuteDog <span class="hljs-operator">=</span> <span class="hljs-type">Dog</span>()<br />    logger.log(<span class="hljs-string">&quot;小狗出生&quot;</span>)<br />    <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) {[<span class="hljs-keyword">weak</span> cuteDog] timer <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> cuteDog <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br />        cuteDog.run()<br />        cuteDog.eat()<br />        cuteDog.sleep()<br />    }<br />    logger.log(<span class="hljs-string">&quot;function play 結束&quot;</span>)<br />}</span></pre><h3 name="e3f4" id="e3f4" class="graf graf--h3 graf-after--pre">closure 不一定會產生 strong reference cycle &amp; memory leak</h3><p name="c0d5" id="c0d5" class="graf graf--p graf-after--h3">在剛剛的例子，我們見證了沒有 capture list 時，closure 會增加物件的 reference count。不過這不代表 closure 一定會產生 strong reference cycle &amp; memory leak。</p><p name="2b9b" id="2b9b" class="graf graf--p graf-after--p">就像世上有壞人，的確有產生 reference cycle 的 closure。不過這個世界還是好人較多，所以大部分的 closure 並不會產生 strong reference cycle &amp; memory leak，讓我們看看以下 view controller 的例子。</p><p name="70dc" id="70dc" class="graf graf--p graf-after--p">假設 storyboard 畫面的設計如下，第二頁是 ChangeColorViewController。</p><figure name="f1d3" id="f1d3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Vfjp-SmuZMsxT8--MGQrAA.png" data-width="914" data-height="850" src="https://cdn-images-1.medium.com/max/800/1*Vfjp-SmuZMsxT8--MGQrAA.png"></figure><p name="991b" id="991b" class="graf graf--p graf-after--figure">ChangeColorViewController 的程式如下，它將在出現後 5 秒左右改變顏色。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9ed9" id="9ed9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> UIKit<br /><span class="hljs-keyword">import</span> os<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeColorViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <br />    <span class="hljs-keyword">let</span> logger <span class="hljs-operator">=</span> <span class="hljs-type">Logger</span>()<br /><br />    <span class="hljs-keyword">deinit</span> {<br />        logger.log(<span class="hljs-string">&quot;deinit&quot;</span>)<br />    }<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) { timer <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">self</span>.changeColor()<br />        }<br />        logger.log(<span class="hljs-string">&quot;viewDidLoad 結束&quot;</span>)<br />    }<br />    <br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidDisappear</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">animated</span>: <span class="hljs-type">Bool</span>) {<br />        <span class="hljs-keyword">super</span>.viewDidDisappear(animated)<br />        logger.log(<span class="hljs-string">&quot;viewDidDisappear 結束&quot;</span>)<br />    }<br /><br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">changeColor</span>() {<br />        view.backgroundColor <span class="hljs-operator">=</span> .blue<br />        logger.log(<span class="hljs-string">&quot;changeColor&quot;</span>)<br />    }<br />}</span></pre><p name="f76f" id="f76f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">實驗1:</strong></p><p name="83f5" id="83f5" class="graf graf--p graf-after--p">進入第二頁的 ChangeColorViewController，看到它變色後再欣賞幾秒才返回第一頁。</p><figure name="27c0" id="27c0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BobdCMKngMUfIAhwW8P9wQ.png" data-width="1684" data-height="844" src="https://cdn-images-1.medium.com/max/800/1*BobdCMKngMUfIAhwW8P9wQ.png"></figure><pre name="ee9e" id="ee9e" class="graf graf--pre graf-after--figure"><strong class="markup--strong markup--pre-strong">2021-01-08 00:20:53.541904+0800 Demo2[11221:596157] viewDidLoad 結束</strong></pre><pre name="6766" id="6766" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 00:20:58.541254+0800 Demo2[11221:596157] changeColor</strong></pre><pre name="1777" id="1777" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 00:21:03.227026+0800 Demo2[11221:596157] viewDidDisappear 結束</strong></pre><pre name="cc1f" id="cc1f" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 00:21:03.227557+0800 Demo2[11221:596157] deinit</strong></pre><p name="7c48" id="7c48" class="graf graf--p graf-after--pre">返回第一頁時 ChangeColorViewController 順利死去，在印出 viewDidDisappear 後印出 deinit。</p><p name="fc3b" id="fc3b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">實驗2:</strong></p><p name="c06e" id="c06e" class="graf graf--p graf-after--p">進入第二頁的 ChangeColorViewController，還沒看到它變色就返回第一頁。</p><pre name="0286" id="0286" class="graf graf--pre graf-after--p">2021-01-08 00:28:38.189568+0800 Demo2[11430:614019] viewDidLoad 結束<br>2021-01-08 00:28:39.818943+0800 Demo2[11430:614019] viewDidDisappear 結束<br>2021-01-08 00:28:43.190050+0800 Demo2[11430:614019] changeColor<br>2021-01-08 00:28:43.190391+0800 Demo2[11430:614019] deinit</pre><p name="205b" id="205b" class="graf graf--p graf-after--pre">當我們返回第一頁時(viewDidDisappear 觸發)，ChangeColorViewController 還沒死去，因為我們在 timer 的 closure 裡使用 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">self</strong></code>，也就是 ChangeColorViewController，增加了它的 reference count。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="e7d6" id="e7d6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />    <span class="hljs-keyword">super</span>.viewDidLoad()<br />    <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) { timer <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">self</span>.changeColor()<br />    }<br />    logger.log(<span class="hljs-string">&quot;viewDidLoad 結束&quot;</span>)<br />}</span></pre><p name="b4ac" id="b4ac" class="graf graf--p graf-after--pre">當 timer 在 5 秒後觸發時，ChangeColorViewController 的畫面已看不到，但 ChangeColorViewController 還活得好好的，所以它會盡責地呼叫 changeColor，完成 timer closure 的程式後才安心地死去。</p><p name="1809" id="1809" class="graf graf--p graf-after--p">從以上的實驗，我們發現 closure 雖然會增加 controller 的 reference count，但它並沒有產生 reference cycle &amp; memory leak，因此沒有加上 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">[weak self]</strong></code> 也是 ok 的。</p><p name="9953" id="9953" class="graf graf--p graf-after--p">若要雞蛋裡挑骨頭，剛剛的程式的確有缺點，closure 延長了 ChangeColorViewController 存活的時間。若是覺得返回第一頁時，ChangeColorViewController 已經沒有利用價值，反正都看不到了，不需要改變顏色。那麼我們可以加上 [weak self]，在返回第一頁時 ChangeColorViewController 將馬上死去。當 timer 在 5 秒後觸發 closure 時，self 將變成 nil，不會執行 changeColor。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d901" id="d901" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />    <span class="hljs-keyword">super</span>.viewDidLoad()<br />    <span class="hljs-type">Timer</span>.scheduledTimer(withTimeInterval: <span class="hljs-number">5</span>, repeats: <span class="hljs-literal">false</span>) {[<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] timer <span class="hljs-keyword">in</span><br />        <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.changeColor()<br />    }<br />    logger.log(<span class="hljs-string">&quot;viewDidLoad 結束&quot;</span>)<br /> }</span></pre><p name="5d30" id="5d30" class="graf graf--p graf-after--pre">結果</p><pre name="50ce" id="50ce" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">2021-01-08 01:00:56.581679+0800 Demo2[11635:647801] viewDidLoad 結束</strong></pre><pre name="a5c5" id="a5c5" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 01:00:58.056172+0800 Demo2[11635:647801] viewDidDisappear 結束</strong></pre><pre name="3ec4" id="3ec4" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 01:00:58.056705+0800 Demo2[11635:647801] deinit</strong></pre><p name="f84b" id="f84b" class="graf graf--p graf-after--pre">網路抓資料是另一個常見的 closure 搭配<code class="markup--code markup--p-code"> [weak self]</code> 的例子，接下來就讓我們實驗看看吧。</p><h3 name="6a3e" id="6a3e" class="graf graf--h3 graf-after--p">URLSession 網路抓資料延長了物件的生命，沒抓到前不準死</h3><p name="1ebb" id="1ebb" class="graf graf--p graf-after--h3">storyboard 的畫面如下，第二頁的 PhotoViewController 將抓取網路上的圖片。</p><figure name="71ce" id="71ce" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rtz9vA1mbnELANruj6VEFw.png" data-width="764" data-height="686" src="https://cdn-images-1.medium.com/max/800/1*rtz9vA1mbnELANruj6VEFw.png"></figure><p name="13e5" id="13e5" class="graf graf--p graf-after--figure">為了容易看出實驗的效果，我們特別抓取 size 6.7 MB 的極光美圖，增加抓圖所需的時間。</p><figure name="a09b" id="a09b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BQPmCuZ9OqkU7ZElV2LOJw.png" data-width="2008" data-height="1314" src="https://cdn-images-1.medium.com/max/800/1*BQPmCuZ9OqkU7ZElV2LOJw.png"></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="fe71" id="fe71" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> UIKit<br /><span class="hljs-keyword">import</span> os<br /><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoViewController</span>: <span class="hljs-title class_">UIViewController</span> {<br />    <br />    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> imageView: <span class="hljs-type">UIImageView</span>!<br />    <span class="hljs-keyword">let</span> logger <span class="hljs-operator">=</span> <span class="hljs-type">Logger</span>()<br /><br />    <span class="hljs-keyword">deinit</span> {<br />        logger.log(<span class="hljs-string">&quot;deinit&quot;</span>)<br />    }<br /><br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />        <span class="hljs-keyword">super</span>.viewDidLoad()<br />        <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://images.pexels.com/photos/3617500/pexels-photo-3617500.jpeg?crop=entropy&amp;cs=srgb&amp;dl=pexels-benjamin-suter-3617500.jpg&amp;fit=crop&amp;fm=jpg&amp;h=6583&amp;w=5266&quot;</span>)<span class="hljs-operator">!</span><br />        <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data,<br />               <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) {<br />                <span class="hljs-type">DispatchQueue</span>.main.async {<br />                    <span class="hljs-keyword">self</span>.imageView.image <span class="hljs-operator">=</span> image<br />                    <span class="hljs-keyword">self</span>.logger.log(<span class="hljs-string">&quot;抓到圖後顯示&quot;</span>)<br />                }<br />            }<br />        }.resume()<br />        logger.log(<span class="hljs-string">&quot;viewDidLoad 結束&quot;</span>)<br />    }<br />    <br />    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidDisappear</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">animated</span>: <span class="hljs-type">Bool</span>) {<br />        <span class="hljs-keyword">super</span>.viewDidDisappear(animated)<br />        logger.log(<span class="hljs-string">&quot;viewDidDisappear 結束&quot;</span>)<br />    }<br />}</span></pre><p name="258e" id="258e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">實驗:</strong></p><p name="0833" id="0833" class="graf graf--p graf-after--p">進入第二頁 PhotoViewController 時，我們沒有耐心等待，圖還沒抓到就返回前一頁。</p><pre name="f8fc" id="f8fc" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">2021-01-08 01:13:34.671160+0800 Demo2[11713:662517] viewDidLoad 結束</strong></pre><pre name="50e5" id="50e5" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 01:13:34.839266+0800 Demo2[11713:662638] [] nw_protocol_get_quic_image_block_invoke dlopen libquic failed</strong></pre><pre name="49a4" id="49a4" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 01:13:36.471529+0800 Demo2[11713:662517] viewDidDisappear 結束</strong></pre><pre name="1db1" id="1db1" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 01:13:49.697862+0800 Demo2[11713:662517] 抓到圖後顯示</strong></pre><pre name="f1e2" id="f1e2" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">2021-01-08 01:13:49.698021+0800 Demo2[11713:662517] deinit</strong></pre><p name="f87a" id="f87a" class="graf graf--p graf-after--pre">我們在 1:13:36 返回第一頁，然而 PhotoViewController 要等到圖片抓到後的 01:13:49 才死去，因為 function dataTask 的 closure 裡使用了 self，增加了 PhotoViewController 的 reference count。</p><h3 name="d40c" id="d40c" class="graf graf--h3 graf-after--p">加上 [weak self] 讓 controller 提早死去</h3><p name="d5a0" id="d5a0" class="graf graf--p graf-after--h3">當圖片抓到或抓取失敗，closure 執行完時，PhotoViewController 終會死去。不過由於 controller 時常佔據許多記憶體，若想早點回收它的記憶體，而且覺得它都已經看不到了，繼續等待抓到圖後更新 image view 毫無意義，也可以加上<code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong"> [weak self]</strong></code>，如此返回第一頁時 PhotoViewController 將立即死去。若在抓到圖前返回第一頁，PhotoViewController 將立即死去，因此 closure 執行時將發現 self 為 nil，在 guard else 提早離開 closure。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="1d84" id="1d84" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {<br />   <span class="hljs-keyword">super</span>.viewDidLoad()<br />   <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: <span class="hljs-string">&quot;https://images.pexels.com/photos/3617500/pexels-photo-3617500.jpeg?crop=entropy&amp;cs=srgb&amp;dl=pexels-benjamin-suter-3617500.jpg&amp;fit=crop&amp;fm=jpg&amp;h=6583&amp;w=5266&quot;</span>)<span class="hljs-operator">!</span><br />   <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) {[<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] data, response, error <span class="hljs-keyword">in</span><br />      <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }<br />      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data,<br />         <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) {<br />         <span class="hljs-type">DispatchQueue</span>.main.async {<br />            imageView.image <span class="hljs-operator">=</span> image<br />            logger.log(<span class="hljs-string">&quot;抓到圖後顯示&quot;</span>)<br />         }<br />       }<br />    }.resume()<br />    logger.log(<span class="hljs-string">&quot;viewDidLoad 結束&quot;</span>)<br />}</span></pre><p name="a83a" id="a83a" class="graf graf--p graf-after--pre">ps: 當 weak self 已經被 unwrapped 後，我們可以在接下來的程式省略 self。相關說明可參考以下連結。</p><div name="a74e" id="a74e" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c" data-href="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c"><strong class="markup--strong markup--mixtapeEmbed-strong">Allow implicit self for weak self captures, after self is unwrapped — SE-0365</strong><br><em class="markup--em markup--mixtapeEmbed-em">從 Xcode 14.3 的 Swift 5.8 開始，Apple 在 SE-0365 推出了貼心的新功能，當 weak self 已經被 unwrapped 後，我們可以在接下來的程式省略 self。</em>apppeterpan.medium.com</a><a href="https://apppeterpan.medium.com/allow-implicit-self-for-weak-self-captures-after-self-is-unwrapped-se-0365-e562eea9a9c" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a53a1f13fc42e32ad0a34a56e09a41b2" data-thumbnail-img-id="1*JM8B9xczlN9xhiyxTmVt_A.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*JM8B9xczlN9xhiyxTmVt_A.png);"></a></div><p name="a85c" id="a85c" class="graf graf--p graf-after--mixtapeEmbed">結果</p><pre name="009a" id="009a" class="graf graf--pre graf-after--p">2021-01-08 01:22:37.242643+0800 Demo2[11755:671780] viewDidLoad 結束<br>2021-01-08 01:22:37.370116+0800 Demo2[11755:671875] [] nw_protocol_get_quic_image_block_invoke dlopen libquic failed<br>2021-01-08 01:22:38.891981+0800 Demo2[11755:671780] viewDidDisappear 結束<br>2021-01-08 01:22:38.892531+0800 Demo2[11755:671780] deinit</pre><h3 name="6598" id="6598" class="graf graf--h3 graf-after--pre">解決 Timer 重覆執行造成的記憶體問題</h3><p name="6c61" id="6c61" class="graf graf--p graf-after--h3">剛剛我們看到的 timer 例子並不會產生記憶體問題，因為它的參數 repeat repeats 為 false，只會執行一次。然而當 repeats 為 true，timer 會重覆執行時，將可能產生記憶體問題，甚至讓 controller 永遠不死。</p><p name="dcd7" id="dcd7" class="graf graf--p graf-after--p">此問題的解法關鍵在於 timer 的 invalidate，詳情可參考以下連結。</p><div name="31cd" id="31cd" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 capture list 解決 Timer &amp; NotificationCenter 造成的記憶體問題</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時我們時常使用定時的 timer &amp; 接收通知的 notification center， 不過它們其實暗藏了一個可怕的陷阱，有可能讓 App 的記憶體愈用愈多，進而引發 App 因記憶體爆掉而閃退。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-timer-notificationcenter-%E9%80%A0%E6%88%90%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-40aeb1319b19" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ae37b1814cd1f359154e95448372fb0a" data-thumbnail-img-id="1*PZ-fm60DnbcJ2v_xJurxOw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*PZ-fm60DnbcJ2v_xJurxOw.jpeg);"></a></div><h3 name="ffcc" id="ffcc" class="graf graf--h3 graf-after--mixtapeEmbed">在 @escaping closures 加上 implicit self 的 Swift 5.3</h3><div name="e6fe" id="e6fe" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade"><strong class="markup--strong markup--mixtapeEmbed-strong">在 @escaping closures 加上 implicit self 的 Swift 5.3</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，當我們遇到 @escaping closures 時，往往需要輸入煩人的 self，例如以下骰子亂數的例子:</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%9C%A8-escaping-closures-%E5%8A%A0%E4%B8%8A-implicit-self-%E7%9A%84-swift-5-3-68ed73a50ade" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="05b4a6ff88f35de06527d53f5b565bb1" data-thumbnail-img-id="1*UC6ijPjaH0pyAEOV6bg7sA.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*UC6ijPjaH0pyAEOV6bg7sA.jpeg);"></a></div><figure name="7a6a" id="7a6a" class="graf graf--figure graf--iframe graf-after--mixtapeEmbed graf--trailing"><iframe src="https://www.youtube.com/embed/0CBNC8h0EMA?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/a7672fab1d1f"><time class="dt-published" datetime="2021-01-07T18:08:24.809Z">January 7, 2021</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E5%88%A9%E7%94%A8-capture-list-%E8%A7%A3%E6%B1%BA-closure-%E5%8F%AF%E8%83%BD%E7%94%A2%E7%94%9F%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E5%95%8F%E9%A1%8C-a7672fab1d1f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>