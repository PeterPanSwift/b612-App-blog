<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>模仿 Apple 官方範例串接 API，使用 generic，protocol &amp; associatedtype 定義 APIRequest &amp; APIService</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">模仿 Apple 官方範例串接 API，使用 generic，protocol &amp; associatedtype 定義 APIRequest &amp; APIService</h1>
</header>
<section data-field="subtitle" class="p-summary">
Apple 官方的教科書由淺入深地介紹了三種網路 API 串接的寫法，依序是
</section>
<section data-field="body" class="e-content">
<section name="6659" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="889a" id="889a" class="graf graf--h3 graf--leading graf--title">模仿 Apple 官方範例串接 API，使用 generic，protocol &amp; <strong class="markup--strong markup--h3-strong">associatedtype </strong>定義 APIRequest &amp; APIService</h3><figure name="45bc" id="45bc" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*MxAZlgm7rBPl93hBeDLCrg.png" data-width="1426" data-height="1344" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*MxAZlgm7rBPl93hBeDLCrg.png"></figure><p name="e8a2" id="e8a2" class="graf graf--p graf-after--figure">Apple 官方的教科書由淺入深介紹了 5 種網路 API 串接的寫法，依序是</p><ul class="postList"><li name="b4cc" id="b4cc" class="graf graf--li graf-after--p">在串接 API 的 function 裡定義 function 型別的 completion 參數。</li><li name="0cd5" id="0cd5" class="graf graf--li graf-after--li">在串接 API 的 function 裡定義 function 型別的 completion 參數 &amp; 使用 Result type。</li><li name="d457" id="d457" class="graf graf--li graf-after--li">使用 generic，protocol &amp; associatedtype 定義 APIRequest &amp; APIService。</li><li name="6038" id="6038" class="graf graf--li graf-after--li">使用 async &amp; await。</li><li name="6352" id="6352" class="graf graf--li graf-after--li">使用 generic，protocol &amp; associatedtype 定義 APIRequest &amp; APIService，搭配 async &amp; await。</li></ul><div name="b7c7" id="b7c7" class="graf graf--mixtapeEmbed graf-after--li"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-84139d10a7c9" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-84139d10a7c9" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-84139d10a7c9"><strong class="markup--strong markup--mixtapeEmbed-strong">模仿 Apple 官方範例串接 JSON API，定義 function 型別的 completion 參數</strong><br><em class="markup--em markup--mixtapeEmbed-em">Apple 的 App Development with Swift 第五章 Guided Project: Restaurant Menu 介紹了適合初學者參考的 JSON API 串接寫法，接下來就讓我們一步步介紹如何模仿抄襲…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-84139d10a7c9" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="d37b05819581f02280107734d1bd23f4" data-thumbnail-img-id="1*QnlDhz8phaDG3yjDfdOS7A.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*QnlDhz8phaDG3yjDfdOS7A.jpeg);"></a></div><div name="fd61" id="fd61" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-%E5%AE%9A%E7%BE%A9-function-%E5%9E%8B%E5%88%A5%E7%9A%84-completion-%E5%8F%83%E6%95%B8-%E4%BD%BF%E7%94%A8-result-type-9b058c77df5d" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-%E5%AE%9A%E7%BE%A9-function-%E5%9E%8B%E5%88%A5%E7%9A%84-completion-%E5%8F%83%E6%95%B8-%E4%BD%BF%E7%94%A8-result-type-9b058c77df5d" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-%E5%AE%9A%E7%BE%A9-function-%E5%9E%8B%E5%88%A5%E7%9A%84-completion-%E5%8F%83%E6%95%B8-%E4%BD%BF%E7%94%A8-result-type-9b058c77df5d"><strong class="markup--strong markup--mixtapeEmbed-strong">模仿 Apple 官方範例串接 JSON API，定義 function 型別的 completion 參數 &amp; 使用 Result type</strong><br><em class="markup--em markup--mixtapeEmbed-em">Apple 的 Develop in Swift Data Collections 第二章 Guided Project: Restaurant 介紹適合初學者參考的 JSON API 串接寫法，接下來就讓我們一步步介紹如何模仿抄襲…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-json-api-%E5%AE%9A%E7%BE%A9-function-%E5%9E%8B%E5%88%A5%E7%9A%84-completion-%E5%8F%83%E6%95%B8-%E4%BD%BF%E7%94%A8-result-type-9b058c77df5d" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4402a63fe7c2782581dca6659ebbd8dd" data-thumbnail-img-id="1*qxVQW2O7aMXcjSs5mE9iHg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*qxVQW2O7aMXcjSs5mE9iHg.png);"></a></div><p name="c21a" id="c21a" class="graf graf--p graf-after--mixtapeEmbed">從以上連結我們認識了前兩種做法，它們都是不錯的方法，不過當串接的 API 很多時，我們需要撰寫大量重覆的程式碼，比方我們參考 Apple 在 Develop in Swift Data Collections 的 Lesson 3.2 Swift Generics 的範例，fetchPhotoInfo &amp; fetchImage 裡有許多重覆的程式，像是建立 URLComponents &amp; URLSessionDataTask。</p><pre name="9ece" id="9ece" class="graf graf--pre graf-after--p">func fetchPhotoInfo(completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Result&lt;PhotoInfo,<br>   Error&gt;) -&gt; Void) {<br>    var urlComponents = URLComponents(string:<br>       &quot;<a href="https://api.nasa.gov/planetary/apod" data-href="https://api.nasa.gov/planetary/apod" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener" target="_blank">https://api.nasa.gov/planetary/apod</a>&quot;)!<br>    urlComponents.queryItems = [URLQueryItem(name:<br>       &quot;api_key&quot;, value: &quot;DEMO_KEY&quot;)]<br>    let task = URLSession.shared.dataTask(with:<br>       urlComponents.url!) { data, response, error in<br>        let jsonDecoder = JSONDecoder()<br>        if let data = data {<br>            do {<br>                let photoInfo = try<br>                   jsonDecoder.decode(PhotoInfo.self, from: data)<br>                completion(.success(photoInfo))<br>            } catch {<br>                completion(.failure(error))<br>            }<br>        } else if let error = error {<br>            completion(.failure(error))<br>        }<br>    }<br>    task.resume()<br>}</pre><pre name="cc52" id="cc52" class="graf graf--pre graf-after--pre">enum PhotoInfoError: Error, LocalizedError {<br>    case imageDataMissing<br>}<br>func fetchImage(from url: URL, completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a><br>   (Result&lt;UIImage, Error&gt;) -&gt; Void) {<br>    var urlComponents = URLComponents(url: url,<br>       resolvingAgainstBaseURL: true)</pre><pre name="ff57" id="ff57" class="graf graf--pre graf-after--pre">　　let task = URLSession.shared.dataTask(with:<br>       urlComponents!.url!) { data, response, error in<br>        if let data = data, <br>           let image = UIImage(data: data) {<br>            completion(.success(image))<br>        } else if let error = error {<br>            completion(.failure(error))<br>        } else {<br>                     completion(.failure(PhotoInfoError.imageDataMissing))<br>        }<br>    }<br>    task.resume()<br>}</pre><div name="1297" id="1297" class="graf graf--mixtapeEmbed graf-after--pre"><a href="https://books.apple.com/bj/book/develop-in-swift-data-collections/id1511183970" data-href="https://books.apple.com/bj/book/develop-in-swift-data-collections/id1511183970" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://books.apple.com/bj/book/develop-in-swift-data-collections/id1511183970"><strong class="markup--strong markup--mixtapeEmbed-strong">‎Develop in Swift Data Collections</strong><br><em class="markup--em markup--mixtapeEmbed-em">‎Students expand on the knowledge and skills they developed in Fundamentals by extending their work in iOS app…</em>books.apple.com</a><a href="https://books.apple.com/bj/book/develop-in-swift-data-collections/id1511183970" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bc952bfd8d8c40feb495749066590836" data-thumbnail-img-id="0*sH8XTgTA1aJixR4C" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*sH8XTgTA1aJixR4C);"></a></div><figure name="db65" id="db65" class="graf graf--figure graf-after--mixtapeEmbed"><img class="graf-image" data-image-id="1*U5_N-wiqnRVQcjMD79qdyA.png" data-width="1602" data-height="1464" src="https://cdn-images-1.medium.com/max/800/1*U5_N-wiqnRVQcjMD79qdyA.png"></figure><p name="38ee" id="38ee" class="graf graf--p graf-after--figure">因此接下來我們將從剛剛提到的 Lesson 3.2 Swift Generics 認識更進階的第三種寫法，使用 generic，protocol &amp; associatedtype 串接網路 API。</p><h4 name="d3cf" id="d3cf" class="graf graf--h4 graf-after--p">範例: 串接 NASA API</h4><div name="ee04" id="ee04" class="graf graf--mixtapeEmbed graf-after--h4"><a href="https://api.nasa.gov" data-href="https://api.nasa.gov" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://api.nasa.gov"><strong class="markup--strong markup--mixtapeEmbed-strong">NASA Open APIs</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>api.nasa.gov</a><a href="https://api.nasa.gov" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="8a56d852b09c0e96ced2a5a4c4d92f0f" data-thumbnail-img-id="0*Y442bnsw1QBav37A" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Y442bnsw1QBav37A);"></a></div><ul class="postList"><li name="c86d" id="c86d" class="graf graf--li graf-after--mixtapeEmbed"><strong class="markup--strong markup--li-strong">定義 protocol APIRequest。</strong></li></ul><p name="07d2" id="07d2" class="graf graf--p graf-after--li">串接 API 時，我們需要用到 request &amp; 將抓到的 Data 轉成需要的型別，因此我們定義 protocol APIRequest，描述網路 API 串接的共同行為，到時候我們將為每個串接網路的 API 定義遵從 APIRequest 的型別。Response 代表到時候 API 抓到資料時，資料要轉換成的型別，比方 UIImage 或自訂的 Codable 型別。</p><pre name="105f" id="105f" class="graf graf--pre graf-after--p">protocol APIRequest {<br>    associatedtype Response</pre><pre name="b7cc" id="b7cc" class="graf graf--pre graf-after--pre">　　 var urlRequest: URLRequest { get }<br>    func decodeResponse(data: Data) throws -&gt; Response<br>}</pre><p name="888e" id="888e" class="graf graf--p graf-after--pre">對 associatedtype 不熟的朋友可參考以下連結的說明。</p><div name="feef" id="feef" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://apppeterpan.medium.com/%E5%B9%AB%E5%8A%A9-protocol-%E5%AF%A6%E7%8F%BE%E5%9E%8B%E5%88%A5%E4%BB%A3%E8%99%9F%E7%9A%84-associated-type-44cb2d25952e" data-href="https://apppeterpan.medium.com/%E5%B9%AB%E5%8A%A9-protocol-%E5%AF%A6%E7%8F%BE%E5%9E%8B%E5%88%A5%E4%BB%A3%E8%99%9F%E7%9A%84-associated-type-44cb2d25952e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://apppeterpan.medium.com/%E5%B9%AB%E5%8A%A9-protocol-%E5%AF%A6%E7%8F%BE%E5%9E%8B%E5%88%A5%E4%BB%A3%E8%99%9F%E7%9A%84-associated-type-44cb2d25952e"><strong class="markup--strong markup--mixtapeEmbed-strong">幫助 protocol 實現型別代號的 Associated Type</strong><br><em class="markup--em markup--mixtapeEmbed-em">protocol 可以透過 Associated Type 宣告類似 generic 的型別代號，代號的真正型別則由到時候遵從 protocol 的型別決定。如此我們將能寫出更彈性的程式碼，不用一開始就將 protocol 裡…</em>apppeterpan.medium.com</a><a href="https://apppeterpan.medium.com/%E5%B9%AB%E5%8A%A9-protocol-%E5%AF%A6%E7%8F%BE%E5%9E%8B%E5%88%A5%E4%BB%A3%E8%99%9F%E7%9A%84-associated-type-44cb2d25952e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4e3ddfe6e97fe0844aa00fd30c0de593" data-thumbnail-img-id="1*8L-Xiabac7igoveyBfztDg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*8L-Xiabac7igoveyBfztDg.jpeg);"></a></div><ul class="postList"><li name="69e9" id="69e9" class="graf graf--li graf-after--mixtapeEmbed"><strong class="markup--strong markup--li-strong">定義發送 request 的 function sendRequest</strong></li></ul><p name="f036" id="f036" class="graf graf--p graf-after--li">之後我們將呼叫 sendRequest 發送 request，然後從參數 completion 取得抓到的資料。</p><pre name="02eb" id="02eb" class="graf graf--pre graf-after--p">func sendRequest&lt;Request: APIRequest&gt;(_ request: Request, completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Result&lt;Request.Response, Error&gt;) -&gt; Void) {<br>    let task = URLSession.shared.dataTask(with: request.urlRequest) { data, response, error in<br>        if let data = data {<br>            do {<br>                let decodedResponse = try request.decodeResponse(data: data)<br>                completion(.success(decodedResponse))<br>            } catch {<br>                completion(.failure(error))<br>            }<br>        } else if let error = error {<br>            completion(.failure(error))<br>        }<br>    }</pre><pre name="5ca6" id="5ca6" class="graf graf--pre graf-after--pre">    task.resume()<br>}</pre><p name="4634" id="4634" class="graf graf--p graf-after--pre">sendRequest 的 Request 必須遵從 APIRequest，除了寫成 &lt;Request: APIRequest&gt;，也可以寫成搭配 where 的寫法。</p><pre name="97fd" id="97fd" class="graf graf--pre graf-after--p">func sendRequest&lt;Request&gt;(_ request: Request, completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Result&lt;Request.Response, Error&gt;) -&gt; Void) where Request: APIRequest</pre><ul class="postList"><li name="7f41" id="7f41" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 NASA API 資料對應的型別 PhotoInfo。</strong></li></ul><pre name="f1d4" id="f1d4" class="graf graf--pre graf-after--li">struct PhotoInfo: Codable {<br>    var title: String<br>    var description: String<br>    var url: URL<br>    var copyright: String?<br>    var thumbnailUrl: URL?<br>    <br>    enum CodingKeys: String, CodingKey {<br>        case title<br>        case description = &quot;explanation&quot;<br>        case url<br>        case copyright<br>        case thumbnailUrl = &quot;thumbnail_url&quot;<br>    }<br>}</pre><p name="acfe" id="acfe" class="graf graf--p graf-after--pre">NASA API 回傳的資料內容如下。</p><pre name="3e81" id="3e81" class="graf graf--pre graf-after--p">{&quot;date&quot;:&quot;2021-04-16&quot;,&quot;explanation&quot;:&quot;Light rays from accretion disks around a pair of orbiting supermassive black holes make their way through the warped space-time produced by extreme gravity in this stunning computer visualization. The simulated accretion disks have been given different false color schemes, red for the disk surrounding a 200-million-solar-mass black hole, and blue for the disk surrounding a 100-million-solar-mass black hole. That makes it easier to track the light sources, but the choice also reflects reality. Hotter gas gives off light closer to the blue end of the spectrum and material orbiting smaller black holes experiences stronger gravitational effects that produce higher temperatures. For these masses, both accretion disks would actually emit most of their light in the ultraviolet though. In the video, distorted secondary images of the blue black hole, which show the red black hole’s view of its partner, can be found within the tangled skein of the red disk warped by the gravity of the blue black hole in the foreground. Because we’re seeing red’s view of blue while also seeing blue directly, the images allow us to see both sides of blue at the same time. Red and blue light originating from both black holes can be seen in the innermost ring of light, called the photon ring, near their event horizons. Astronomers expect that in the not-too-distant future they\u2019ll be able to detect gravitational waves, ripples in space-time, produced when two supermassive black holes in a system much like the one simulated here spiral together and merge.&quot;,&quot;media_type&quot;:&quot;video&quot;,&quot;service_version&quot;:&quot;v1&quot;,&quot;thumbnail_url&quot;:&quot;<a href="https://img.youtube.com/vi/rQcKIN9vj3U/0.jpg" data-href="https://img.youtube.com/vi/rQcKIN9vj3U/0.jpg" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://img.youtube.com/vi/rQcKIN9vj3U/0.jpg</a>&quot;,&quot;title&quot;:&quot;The Doubly Warped World of Binary Black Holes&quot;,&quot;url&quot;:&quot;<a href="https://www.youtube.com/embed/rQcKIN9vj3U?rel=0" data-href="https://www.youtube.com/embed/rQcKIN9vj3U?rel=0" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://www.youtube.com/embed/rQcKIN9vj3U?rel=0</a>&quot;}</pre><p name="2707" id="2707" class="graf graf--p graf-after--pre">接下來我們將為每個串接網路的 API 定義遵從 APIRequest 的型別。</p><ul class="postList"><li name="4ba6" id="4ba6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">定義抓取 NASA 資料的 request PhotoInfoAPIRequest。</strong></li></ul><p name="13d4" id="13d4" class="graf graf--p graf-after--li">遵從 protocol APIRequest，定義 urlRequest &amp; decodeResponse。</p><pre name="7b3c" id="7b3c" class="graf graf--pre graf-after--p">struct PhotoInfoAPIRequest: APIRequest {<br>    var apiKey: String</pre><pre name="184b" id="184b" class="graf graf--pre graf-after--pre">　　 var urlRequest: URLRequest {<br>        var urlComponents = URLComponents(string: &quot;<a href="https://api.nasa.gov/planetary/apod" data-href="https://api.nasa.gov/planetary/apod" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://api.nasa.gov/planetary/apod</a>&quot;)!<br>        urlComponents.queryItems = [<br>            URLQueryItem(name: &quot;api_key&quot;, value: apiKey),<br>            URLQueryItem(name: &quot;thumbs&quot;, value: &quot;true&quot;),<br>        ]</pre><pre name="c3e7" id="c3e7" class="graf graf--pre graf-after--pre">        return URLRequest(url: urlComponents.url!)<br>    }</pre><pre name="81c5" id="81c5" class="graf graf--pre graf-after--pre">    func decodeResponse(data: Data) throws -&gt; PhotoInfo {<br>        let photoInfo = try JSONDecoder().decode(PhotoInfo.self, from: data)<br>        return photoInfo<br>    }<br>}</pre><ul class="postList"><li name="8425" id="8425" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義抓取照片的 request ImageAPIRequest。</strong></li></ul><p name="b5cc" id="b5cc" class="graf graf--p graf-after--li">遵從 protocol APIRequest，定義 urlRequest &amp; decodeResponse。</p><pre name="30af" id="30af" class="graf graf--pre graf-after--p">struct ImageAPIRequest: APIRequest {<br>    enum ResponseError: Error {<br>        case invalidImageData<br>    }<br>    <br>    let url: URL<br>    <br>    var urlRequest: URLRequest {<br>        return URLRequest(url: url)<br>    }<br>    <br>    func decodeResponse(data: Data) throws -&gt; UIImage {<br>        guard let image = UIImage(data: data) else {<br>            throw ResponseError.invalidImageData<br>        }<br>        <br>        return image<br>    }<br>}</pre><ul class="postList"><li name="6485" id="6485" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">測試 API 串接</strong></li></ul><p name="f220" id="f220" class="graf graf--p graf-after--li">呼叫 sendRequest，先利用 PhotoInfoAPIRequest 取得 NASA API 資料，得到 JSON 裡的圖片網址，然後再用 ImageAPIRequest 抓圖。(ps: nasa 回傳的資料有圖片和影片兩種，當它是影片時，我們必須另外從 thumbnailUrl 取得影片的截圖。)</p><pre name="3a6d" id="3a6d" class="graf graf--pre graf-after--p">let photoInfoRequest = PhotoInfoAPIRequest(apiKey: &quot;DEMO_KEY&quot;)<br>sendRequest(photoInfoRequest) { result in<br>    switch result {<br>    case .success(let photoInfo):<br>        print(photoInfo)<br>        let imageURL = photoInfo.thumbnailUrl ?? photoInfo.url<br>        let imageRequest = ImageAPIRequest(url: imageURL)<br>        sendRequest(imageRequest) { imageResult in<br>            switch imageResult {<br>            case .success(let image):<br>                image<br>            case .failure(let error):<br>                print(error)<br>            }<br>        }<br>    case .failure(let error):<br>        print(error)<br>    }<br>}</pre><p name="0607" id="0607" class="graf graf--p graf-after--pre">Cool，成功抓到美麗的 NASA 太空圖片。</p><figure name="c72e" id="c72e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6eUY_z8njbjugsknvSwKUQ.png" data-width="1072" data-height="788" src="https://cdn-images-1.medium.com/max/800/1*6eUY_z8njbjugsknvSwKUQ.png"></figure><h3 name="2a27" id="2a27" class="graf graf--h3 graf-after--figure">使用 generic，protocol &amp; associatedtype 定義 APIRequest &amp; APIService</h3><p name="4d51" id="4d51" class="graf graf--p graf-after--h3">Apple 在 Develop in Swift Data Collections 的 Unit 3 Guided Project: Habits 提供更完整的 API 串接範例，運用剛剛的方法定義了 APIRequest &amp; APIService。</p><figure name="6f82" id="6f82" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IR_FSwWtNqcOECB7oM5low.png" data-width="1186" data-height="1560" src="https://cdn-images-1.medium.com/max/800/1*IR_FSwWtNqcOECB7oM5low.png"></figure><h4 name="7b48" id="7b48" class="graf graf--h4 graf-after--figure">APIRequest.swift</h4><p name="cdf0" id="cdf0" class="graf graf--p graf-after--h4">定義 protocol APIRequest，描述網路 API 串接的共同行為，到時候我們將為每個串接網路的 API 定義遵從 APIRequest 的型別。</p><ul class="postList"><li name="8a4f" id="8a4f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">定義 protocol APIRequest。</strong></li></ul><pre name="06ba" id="06ba" class="graf graf--pre graf-after--li">protocol APIRequest {<br>    associatedtype Response<br>    <br>    var path: String { get }<br>    var queryItems: [URLQueryItem]? { get }<br>    var request: URLRequest { get }<br>    var postData: Data? { get }<br>}</pre><p name="4e04" id="4e04" class="graf graf--p graf-after--pre">URLQueryItem 的相關說明。</p><div name="4157" id="4157" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-baseurl-urlcomponents-urlqueryitem-%E7%94%A2%E7%94%9F-url-1e4539a33a89" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-baseurl-urlcomponents-urlqueryitem-%E7%94%A2%E7%94%9F-url-1e4539a33a89" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-baseurl-urlcomponents-urlqueryitem-%E7%94%A2%E7%94%9F-url-1e4539a33a89"><strong class="markup--strong markup--mixtapeEmbed-strong">使用 baseURL，URLComponents &amp; URLQueryItem 產生 URL</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，我們時常串接後台的 API。通常 API 前面的網址是固定的，只有後面的 path 跟 query 參數會變動，比方以下 iTunes API 的例子:</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-baseurl-urlcomponents-urlqueryitem-%E7%94%A2%E7%94%9F-url-1e4539a33a89" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="04704c889d06333ce25e878df77f2bb3" data-thumbnail-img-id="1*MKgXFUnTKLcu5TUVfiAPhg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*MKgXFUnTKLcu5TUVfiAPhg.jpeg);"></a></div><ul class="postList"><li name="0128" id="0128" class="graf graf--li graf-after--mixtapeEmbed"><strong class="markup--strong markup--li-strong">利用 extension 定義 host &amp; port 的預設值。</strong></li></ul><pre name="17c8" id="17c8" class="graf graf--pre graf-after--li">extension APIRequest {<br>    var host: String { &quot;localhost&quot; }<br>    var port: Int { 8080 }<br>}</pre><ul class="postList"><li name="1eab" id="1eab" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 定義 queryItems &amp; postData 的預設值。</strong></li></ul><pre name="fdc2" id="fdc2" class="graf graf--pre graf-after--li">extension APIRequest {<br>    var queryItems: [URLQueryItem]? { nil }<br>    var postData: Data? { nil }<br>}</pre><ul class="postList"><li name="b638" id="b638" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 定義 request 的預設值。</strong></li></ul><pre name="cfec" id="cfec" class="graf graf--pre graf-after--li">extension APIRequest {<br>    var request: URLRequest {<br>        var components = URLComponents()</pre><pre name="fd32" id="fd32" class="graf graf--pre graf-after--pre">        components.scheme = &quot;http&quot;<br>        components.host = host<br>        components.port = port<br>        components.path = path<br>        components.queryItems = queryItems</pre><pre name="6816" id="6816" class="graf graf--pre graf-after--pre">        var request = URLRequest(url: components.url!)</pre><pre name="5991" id="5991" class="graf graf--pre graf-after--pre">        if let data = postData {<br>            request.httpBody = data<br>            request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)<br>            request.httpMethod = &quot;POST&quot;<br>        }</pre><pre name="494e" id="494e" class="graf graf--pre graf-after--pre">        return request<br>    }<br>}</pre><ul class="postList"><li name="bc4f" id="bc4f" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 在 APIRequest 裡定義串接 JSON API 的 function send。</strong></li></ul><p name="d3e3" id="d3e3" class="graf graf--p graf-after--li">由於 function 裡使用 JSONDecoder 解碼，所以型別 Response 一定要遵從 Decodable，因此我們加上 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">where Response: Decodable</strong></code>，只有當 Response 遵從 Decodable 時才能呼叫此 function。</p><pre name="a25d" id="a25d" class="graf graf--pre graf-after--p">extension APIRequest <strong class="markup--strong markup--pre-strong">where Response: Decodable</strong> {<br>    func <strong class="markup--strong markup--pre-strong">send</strong>(completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Result&lt;Response, Error&gt;) -&gt; Void) {<br>        URLSession.shared.dataTask(with: request) { data, _, error in<br>            do {<br>                if let data = data {<br>                    let decoded = try JSONDecoder().decode(Response.self, from: data)<br>                    completion(.success(decoded))<br>                } else if let error = error {<br>                    completion(.failure(error))<br>                }<br>            } catch {</pre><pre name="a628" id="a628" class="graf graf--pre graf-after--pre">                completion(.failure(error))</pre><pre name="9cdf" id="9cdf" class="graf graf--pre graf-after--pre">            }<br>        }.resume()<br>    }<br>}</pre><ul class="postList"><li name="d6a1" id="d6a1" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 在 APIRequest 裡定義串接 API 的 function send，此 function 只會在 completion 裡傳入 error，通知是否有錯誤。</strong></li></ul><pre name="bab6" id="bab6" class="graf graf--pre graf-after--li">extension APIRequest {<br>    func send(completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Error?) -&gt; Void) {<br>        URLSession.shared.dataTask(with: request) { _, _, error in<br>            completion(error)<br>        }.resume()<br>    }<br>}</pre><ul class="postList"><li name="2b77" id="2b77" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 在 APIRequest 裡定義抓取圖片的 function send。</strong></li></ul><p name="81fe" id="81fe" class="graf graf--p graf-after--li">加上 <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">where Response == UIImage</strong></code>，因此只有當 Response 是 UIImage 時能呼叫此 function。</p><pre name="1f8a" id="1f8a" class="graf graf--pre graf-after--p">enum ImageRequestError: Error {<br>    case couldNotInitializeFromData<br>}</pre><pre name="51b8" id="51b8" class="graf graf--pre graf-after--pre">extension APIRequest <strong class="markup--strong markup--pre-strong">where Response == UIImage</strong> {<br>    func send(completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Result&lt;Response, Error&gt;) -&gt; Void) {<br>        URLSession.shared.dataTask(with: request) { data, _, error in<br>            if let data = data,<br>                let image = UIImage(data: data) {<br>                completion(.success(image))<br>            } else if let error = error {<br>                completion(.failure(error))<br>            } else {<br>                completion(.failure(ImageRequestError.couldNotInitializeFromData))<br>            }<br>        }.resume()<br>    }<br>}</pre><h4 name="b6da" id="b6da" class="graf graf--h4 graf-after--pre">JSON 資料對應的 Codable 型別</h4><p name="4e60" id="4e60" class="graf graf--p graf-after--h4">Habit</p><pre name="8326" id="8326" class="graf graf--pre graf-after--p">struct Habit {<br>    let name: String<br>    let category: Category<br>    let info: String<br>}</pre><pre name="895f" id="895f" class="graf graf--pre graf-after--pre">extension Habit: Codable { }</pre><p name="9b18" id="9b18" class="graf graf--p graf-after--pre">Category</p><pre name="ca16" id="ca16" class="graf graf--pre graf-after--p">struct Category {<br>    let name: String<br>    let color: Color<br>}</pre><pre name="7361" id="7361" class="graf graf--pre graf-after--pre">extension Category: Codable { }</pre><p name="f489" id="f489" class="graf graf--p graf-after--pre">Color</p><pre name="08f7" id="08f7" class="graf graf--pre graf-after--p">struct Color {<br>    let hue: Double<br>    let saturation: Double<br>    let brightness: Double<br>}</pre><pre name="c7aa" id="c7aa" class="graf graf--pre graf-after--pre">extension Color: Codable {<br>    enum CodingKeys: String, CodingKey {<br>        case hue = &quot;h&quot;<br>        case saturation = &quot;s&quot;<br>        case brightness = &quot;b&quot;<br>    }<br>}</pre><p name="8d27" id="8d27" class="graf graf--p graf-after--pre">HabitStatistics</p><pre name="9ba8" id="9ba8" class="graf graf--pre graf-after--p">struct HabitStatistics {<br>    let habit: Habit<br>    let userCounts: [UserCount]<br>}</pre><pre name="86ab" id="86ab" class="graf graf--pre graf-after--pre">extension HabitStatistics: Codable { }</pre><p name="a300" id="a300" class="graf graf--p graf-after--pre">UserCount</p><pre name="0765" id="0765" class="graf graf--pre graf-after--p">struct UserCount {<br>    let user: User<br>    let count: Int<br>}</pre><pre name="688a" id="688a" class="graf graf--pre graf-after--pre">extension UserCount: Codable { }</pre><p name="ee64" id="ee64" class="graf graf--p graf-after--pre">User</p><pre name="4e89" id="4e89" class="graf graf--pre graf-after--p">struct User {<br>    let id: String<br>    let name: String<br>    let color: Color?<br>    let bio: String?<br>}</pre><pre name="85bb" id="85bb" class="graf graf--pre graf-after--pre">extension User: Codable { }</pre><p name="7b1d" id="7b1d" class="graf graf--p graf-after--pre">LoggedHabit</p><pre name="a33e" id="a33e" class="graf graf--pre graf-after--p">struct LoggedHabit {<br>    let userID: String<br>    let habitName: String<br>    let timestamp: Date<br>}</pre><pre name="4370" id="4370" class="graf graf--pre graf-after--pre">extension LoggedHabit: Codable { }</pre><h4 name="5fbb" id="5fbb" class="graf graf--h4 graf-after--pre">APIService.swift</h4><p name="700f" id="700f" class="graf graf--p graf-after--h4">在 APIService.swift 裡為每個串接網路的 API 定義遵從 APIRequest 的型別。</p><ul class="postList"><li name="4514" id="4514" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">定義抓取 Habit 的 HabitRequest(HTTP GET)。</strong></li></ul><pre name="2394" id="2394" class="graf graf--pre graf-after--li">struct HabitRequest: APIRequest {<br>    typealias Response = [String: Habit]</pre><pre name="9e0e" id="9e0e" class="graf graf--pre graf-after--pre">    var path: String { &quot;/habits&quot; }<br>}</pre><ul class="postList"><li name="1aa3" id="1aa3" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義抓取 Habit Statistics 的 HabitStatisticsRequest(HTTP GET)。</strong></li></ul><pre name="e388" id="e388" class="graf graf--pre graf-after--li">struct HabitStatisticsRequest: APIRequest {<br>    typealias Response = [HabitStatistics]</pre><pre name="27ef" id="27ef" class="graf graf--pre graf-after--pre">    var habitNames: [String]?</pre><pre name="9310" id="9310" class="graf graf--pre graf-after--pre">    var path: String { &quot;/habitStats&quot; }<br>    var queryItems: [URLQueryItem]? {<br>        if let habitNames = habitNames {<br>            return [URLQueryItem(name: &quot;names&quot;, value: habitNames.joined(separator: &quot;,&quot;))]<br>        } else {<br>            return nil<br>        }<br>    }<br>}</pre><ul class="postList"><li name="17de" id="17de" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 LogHabitRequest(HTTP POST)。</strong></li></ul><pre name="f67c" id="f67c" class="graf graf--pre graf-after--li">struct LogHabitRequest: APIRequest {<br>    typealias Response = Void<br>    <br>    var loggedHabit: LoggedHabit</pre><pre name="7131" id="7131" class="graf graf--pre graf-after--pre">    var path: String { &quot;/loggedHabit&quot; }<br>    var postData: Data? {<br>        let encoder = JSONEncoder()<br>        encoder.dateEncodingStrategy = .iso8601<br>        return try? encoder.encode(loggedHabit)<br>    }<br>}</pre><ul class="postList"><li name="f35d" id="f35d" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義抓取圖片的 ImageRequest。</strong></li></ul><pre name="210e" id="210e" class="graf graf--pre graf-after--li">struct ImageRequest: APIRequest {<br>    typealias Response = UIImage</pre><pre name="371c" id="371c" class="graf graf--pre graf-after--pre">    var imageID: String</pre><pre name="d4f6" id="d4f6" class="graf graf--pre graf-after--pre">    var path: String { &quot;/images/&quot; + imageID }<br>}</pre><p name="0aaa" id="0aaa" class="graf graf--p graf-after--pre">從以上幾個 request 的例子，我們可發現網路串接的程式精簡很多，以後有新的 API，我們只要為它定義遵從 APIRequest 的型別，在其中設定相關資訊即可。</p><h4 name="8581" id="8581" class="graf graf--h4 graf-after--p">串接 API</h4><ul class="postList"><li name="8500" id="8500" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">產生 HabitRequest，呼叫 send 串接 GET API 抓資料。</strong></li></ul><pre name="6a20" id="6a20" class="graf graf--pre graf-after--li">HabitRequest().send { result in<br>            switch result {<br>            case .success(let habits):<br>                self.model.habitsByName = habits<strong class="markup--strong markup--pre-strong"><br></strong>            case .failure:<br>                break<br>            }<br>            <br>            DispatchQueue.main.async {<br>                // update UI<br>            }<br>}</pre><ul class="postList"><li name="c64f" id="c64f" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">產生 HabitStatisticsRequest，呼叫 send 串接 GET API 抓資料。</strong></li></ul><pre name="4555" id="4555" class="graf graf--pre graf-after--li">HabitStatisticsRequest(habitNames: [habit.name]).send { result in<br>       if case .success(let statistics) = result,  <br>          statistics.count &gt; 0 {<br>           self.model.habitStatistics = statistics[0]<br>       } else {<br>           self.model.habitStatistics = nil<br>       }</pre><pre name="83aa" id="83aa" class="graf graf--pre graf-after--pre">　　　　DispatchQueue.main.async {<br>            // update UI<br>       }<br>}</pre><ul class="postList"><li name="8c79" id="8c79" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">產生 LogHabitRequest，傳入上傳的資料，呼叫 send 串接 POST API。</strong></li></ul><pre name="e75c" id="e75c" class="graf graf--pre graf-after--li">let loggedHabit = LoggedHabit(userID: Settings.shared.currentUser.id, habitName: item.habit.name, timestamp: Date())</pre><pre name="8301" id="8301" class="graf graf--pre graf-after--pre">LogHabitRequest(loggedHabit: loggedHabit).send { error in</pre><pre name="f136" id="f136" class="graf graf--pre graf-after--pre">}</pre><ul class="postList"><li name="508a" id="508a" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">產生 ImageRequest，呼叫 send 抓取圖片。</strong></li></ul><pre name="5514" id="5514" class="graf graf--pre graf-after--li">ImageRequest(imageID: user.id).send { result in<br>            switch result {<br>            case .success(let image):<br>                DispatchQueue.main.async {<br>                    self.profileImageView.image = image<br>                }<br>            default: break<br>            }<br>}</pre><h3 name="38b3" id="38b3" class="graf graf--h3 graf-after--pre">串接 REST API，練習 http get，post，delete，put，以 Reqres API 為例</h3><p name="0065" id="0065" class="graf graf--p graf-after--h3">剛剛 Apple 的範例已經很完整，不過常見的 REST API 通常包含了 HTTP get，post，delete &amp; put，因此接下來讓我們以 Reqres API 為例，試試以 APIRequest &amp; APIService 的寫法串接 REST API。</p><div name="9efd" id="9efd" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-urlsession-%E4%B8%B2%E6%8E%A5-http-get-post-delete-put-api-%E4%BB%A5-reqres-api-%E7%82%BA%E4%BE%8B-f977ec876c33" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-urlsession-%E4%B8%B2%E6%8E%A5-http-get-post-delete-put-api-%E4%BB%A5-reqres-api-%E7%82%BA%E4%BE%8B-f977ec876c33" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-urlsession-%E4%B8%B2%E6%8E%A5-http-get-post-delete-put-api-%E4%BB%A5-reqres-api-%E7%82%BA%E4%BE%8B-f977ec876c33"><strong class="markup--strong markup--mixtapeEmbed-strong">使用 URLSession 串接 REST API，練習 http get，post，delete，put，以 Reqres API 為例</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，我們時常需要跟網路上的後台(server) 溝通。如下圖所示，我們的 App 是 client，它會發送 request 給 server，然後 server 再回傳 response，比方將 JSON…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E4%BD%BF%E7%94%A8-urlsession-%E4%B8%B2%E6%8E%A5-http-get-post-delete-put-api-%E4%BB%A5-reqres-api-%E7%82%BA%E4%BE%8B-f977ec876c33" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c08866f764f6d1421d0b51ece79be944" data-thumbnail-img-id="1*EgbnqUQogcCH136xyvdbbQ.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*EgbnqUQogcCH136xyvdbbQ.png);"></a></div><h4 name="c8ee" id="c8ee" class="graf graf--h4 graf-after--mixtapeEmbed">APIRequest.swift</h4><p name="2432" id="2432" class="graf graf--p graf-after--h4">定義 protocol APIRequest，描述網路 API 串接的共同行為，到時候我們將為每個串接網路的 API 定義遵從 APIRequest 的型別。</p><ul class="postList"><li name="88f4" id="88f4" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">定義 HTTP method 的 enum</strong></li></ul><pre name="9271" id="9271" class="graf graf--pre graf-after--li">enum HTTPMethod: String {<br>    case get<br>    case post<br>    case put<br>    case delete<br>}</pre><ul class="postList"><li name="b013" id="b013" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 protocol APIRequest</strong></li></ul><p name="c431" id="c431" class="graf graf--p graf-after--li">在此我們增加了 httpMethod，方便之後建立每個 API 的 request 時指定 http method。</p><pre name="b23c" id="b23c" class="graf graf--pre graf-after--p">protocol APIRequest {<br>    associatedtype Response<br>    <br>    var path: String { get }<br>    var queryItems: [URLQueryItem]? { get }<br>    var request: URLRequest { get }<br>    <strong class="markup--strong markup--pre-strong">var httpBody: Data? { get }<br>    var httpMethod: HTTPMethod { get }</strong><br>}</pre><ul class="postList"><li name="f80c" id="f80c" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 定義 host 預設值。</strong></li></ul><pre name="2559" id="2559" class="graf graf--pre graf-after--li">extension APIRequest {<br>    var host: String { &quot;reqres.in&quot; }<br>}</pre><ul class="postList"><li name="f4fc" id="f4fc" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 httpMethod 預設為 get，因為它最常用到。</strong></li></ul><pre name="5ddf" id="5ddf" class="graf graf--pre graf-after--li">extension APIRequest {<br>    var queryItems: [URLQueryItem]? { nil }<br>    var httpBody: Data? { nil }<br>    var httpMethod: HTTPMethod { .get }<br>}</pre><ul class="postList"><li name="5041" id="5041" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 定義 request 的預設值。</strong></li></ul><p name="7fc5" id="7fc5" class="graf graf--p graf-after--li">components.path 的預設值是 <code class="markup--code markup--p-code">&quot;/api&quot; + path</code>，因為 Reqres API 的網址都包含了 /api。</p><pre name="2cfe" id="2cfe" class="graf graf--pre graf-after--p">extension APIRequest {<br>    var request: URLRequest {<br>        var components = URLComponents()<br>        components.scheme = &quot;https&quot;<br>        components.host = host<br><strong class="markup--strong markup--pre-strong">        components.path = &quot;/api&quot; + path<br></strong>        components.queryItems = queryItems<br>        var request = URLRequest(url: components.url!)<br><strong class="markup--strong markup--pre-strong">        request.httpMethod = httpMethod.rawValue<br></strong>        if let httpBody = httpBody {<br>            request.httpBody = httpBody<br>            request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)<br>        }<br>        return request<br>    }<br>}</pre><ul class="postList"><li name="8b41" id="8b41" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 在 APIRequest 裡定義串接 JSON API 的 function send。</strong></li></ul><pre name="a503" id="a503" class="graf graf--pre graf-after--li">extension APIRequest where Response: Decodable {<br>    func send(completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Result&lt;Response, Error&gt;) -&gt; Void) {<br>        URLSession.shared.dataTask(with: request) { data, _, error in<br>            do {<br>                if let data = data {<br>                    let decoder = JSONDecoder()<br>                    decoder.keyDecodingStrategy = .convertFromSnakeCase<br>                    let decoded = try decoder.decode(Response.self, from: data)<br>                    completion(.success(decoded))<br>                } else if let error = error {<br>                    completion(.failure(error))<br>                }<br>            } catch {<br>                completion(.failure(error))<br>            }<br>        }.resume()<br>    }<br>}</pre><ul class="postList"><li name="5f9f" id="5f9f" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">利用 extension 在 APIRequest 裡定義串接 delete API 的 function sendForDelete。</strong></li></ul><p name="968f" id="968f" class="graf graf--p graf-after--li">由於 Reqres API 的 delete API 利用 HTTP status code 204 判斷是否成功，所以我們為它另外定義了 function sendForDelete。</p><pre name="f91f" id="f91f" class="graf graf--pre graf-after--p">enum DeleteRequestError: Error {<br>    case statusCodeInvalid<br>}</pre><pre name="02c7" id="02c7" class="graf graf--pre graf-after--pre">extension APIRequest {<br>    func sendForDelete(completion: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Error?) -&gt; Void) {<br>        URLSession.shared.dataTask(with: request) { _, response, error in<br>            if let httpResponse = response as? HTTPURLResponse,<br>               httpResponse.statusCode == 204 {<br>                completion(nil)<br>            } else if let error = error {<br>                completion(error)<br>            } else {<br>                completion(DeleteRequestError.statusCodeInvalid)<br>            }<br>        }.resume()<br>    }<br>}</pre><h4 name="ee71" id="ee71" class="graf graf--h4 graf-after--pre">APIService.swift</h4><p name="74ea" id="74ea" class="graf graf--p graf-after--h4">在 APIService.swift 裡為每個串接網路的 API 定義遵從 APIRequest 的型別。</p><ul class="postList"><li name="477b" id="477b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">定義 GetUsersRequest(HTTP GET)。</strong></li></ul><pre name="47b9" id="47b9" class="graf graf--pre graf-after--li">struct GetUsersRequest: APIRequest {    <br>    <br>    typealias Response = UsersResponse</pre><pre name="2315" id="2315" class="graf graf--pre graf-after--pre">    var path: String { &quot;/users&quot; }<br>}</pre><ul class="postList"><li name="d0a4" id="d0a4" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 CreateUserRequest(HTTP POST)。</strong></li></ul><pre name="5a2b" id="5a2b" class="graf graf--pre graf-after--li">struct CreateUserRequest: APIRequest {<br>    <br>    typealias Response = CreateUserResponse</pre><pre name="a8a3" id="a8a3" class="graf graf--pre graf-after--pre">    var path: String { &quot;/users&quot; }<br>    var httpMethod: HTTPMethod { .post }<br>    var createUserBody: CreateUserBody<br>    <br>    var httpBody: Data? {<br>        let encoder = JSONEncoder()<br>        return try? encoder.encode(createUserBody)<br>    }<br>}</pre><ul class="postList"><li name="d4ec" id="d4ec" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 UpdateUserRequest(HTTP PUT)。</strong></li></ul><p name="fde2" id="fde2" class="graf graf--p graf-after--li">userId 設定要更新的 user。</p><pre name="83b6" id="83b6" class="graf graf--pre graf-after--p">struct UpdateUserRequest: APIRequest {<br> <br>    typealias Response = UpdateUserResponse</pre><pre name="cf5e" id="cf5e" class="graf graf--pre graf-after--pre">    var userId: Int<br>    var path: String { &quot;/users/\(userId)&quot; }<br>    var httpMethod: HTTPMethod { .put }<br>    var updateUserBody: UpdateUserBody<br>    <br>    var httpBody: Data? {<br>        let encoder = JSONEncoder()<br>        return try? encoder.encode(updateUserBody)<br>    }<br>}</pre><ul class="postList"><li name="e02b" id="e02b" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">定義 DeleteUserRequest(HTTP DELETE)。</strong></li></ul><p name="dfc4" id="dfc4" class="graf graf--p graf-after--li">userId 設定要刪除的 user。</p><pre name="c236" id="c236" class="graf graf--pre graf-after--p">struct DeleteUserRequest: APIRequest {<br> <br>    typealias Response = Void</pre><pre name="1cf3" id="1cf3" class="graf graf--pre graf-after--pre">    var userId: Int<br>    var path: String { &quot;/users/\(userId)&quot; }<br>    var httpMethod: HTTPMethod { .delete }<br>        <br>}</pre><h4 name="2a4c" id="2a4c" class="graf graf--h4 graf-after--pre">串接 API</h4><ul class="postList"><li name="3f96" id="3f96" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">產生 GetUsersRequest，呼叫 send 串接 GET API。</strong></li></ul><pre name="29b5" id="29b5" class="graf graf--pre graf-after--li">GetUsersRequest().send { result in<br>     switch result {<br>     case .success(let usersResponse):<br>          print(usersResponse)<br>     case .failure(let error):<br>          print(error)<br>     }<br>}</pre><ul class="postList"><li name="6e68" id="6e68" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">產生 CreateUserRequest，傳入上傳的資料，呼叫 send 串接 POST API。</strong></li></ul><pre name="09e6" id="09e6" class="graf graf--pre graf-after--li">let user = CreateUserBody(name: &quot;Peter&quot;, job: &quot;情歌王子&quot;)<br>CreateUserRequest(createUserBody: user).send { result in<br>    switch result {                 <br>    case .success(let createUserResponse):<br>         print(createUserResponse)<br>    case .failure(let error):<br>         print(error)<br>    }<br>}</pre><ul class="postList"><li name="1dc6" id="1dc6" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">產生 UpdateUserRequest，傳入修改的 id &amp; 上傳的資料，呼叫 send 串接 PUT API。</strong></li></ul><pre name="e6a1" id="e6a1" class="graf graf--pre graf-after--li">let user = UpdateUserBody(name: &quot;peter&quot;, job: &quot;作家&quot;)<br>UpdateUserRequest(userId: 1, updateUserBody: user).send { result in<br>   switch result {             <br>   case .success(let updateUserResponse):<br>       print(updateUserResponse)<br>   case .failure(let error):<br>       print(error)<br>   }<br>}</pre><ul class="postList"><li name="a250" id="a250" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">產生 DeleteUserRequest，傳入刪除的 id，呼叫 sendForDelete 串接 DELETE API。</strong></li></ul><pre name="808a" id="808a" class="graf graf--pre graf-after--li">DeleteUserRequest(userId: 1).sendForDelete { error in<br>    if error == nil {<br>        print(&quot;delete ok&quot;)<br>    }<br>}</pre><h4 name="7d71" id="7d71" class="graf graf--h4 graf-after--pre">客製 JSONDecoder</h4><p name="9af6" id="9af6" class="graf graf--p graf-after--h4">剛剛的範例使用了標準的 JSONDecoder 進行解碼，不過有些時候不同的 API 有不同的 JSON 格式，所以我們需要做一些調整，比方針對不同的時間格式設定 JSONDecoder 的 DateDecodingStrategy，有興趣的朋友可進一步參考以下文章的說明。</p><div name="99d0" id="99d0" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193"><strong class="markup--strong markup--mixtapeEmbed-strong">JSONDecoder 解析時間的 DateDecodingStrategy</strong><br><em class="markup--em markup--mixtapeEmbed-em">當我們利用 JSONDecoder 串接 API 回傳的 JSON 資料時，通常我們會將時間欄位的資料對應到 Date 型別，方便之後App 使用一些時間運算的 function。不過 API 回傳的時間有許多格式，因此我們須告訴…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/jsondecoder-%E8%A7%A3%E6%9E%90%E6%99%82%E9%96%93%E7%9A%84-datedecodingstrategy-a4095481f193" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fad371785dbafdf71cb84bb33b2027f6" data-thumbnail-img-id="1*ReAitj-hKl0IxZ2546Jyeg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*ReAitj-hKl0IxZ2546Jyeg.jpeg);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/f010cd5ce7ac"><time class="dt-published" datetime="2021-04-19T04:12:40.745Z">April 19, 2021</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E6%A8%A1%E4%BB%BF-apple-%E5%AE%98%E6%96%B9%E7%AF%84%E4%BE%8B%E4%B8%B2%E6%8E%A5-api-%E4%BD%BF%E7%94%A8-generic-protocol-associatedtype-%E5%AE%9A%E7%BE%A9-apirequest-apiservice-f010cd5ce7ac" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 17, 2025.</p></footer></article></body></html>