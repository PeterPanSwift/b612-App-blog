<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>利用 NSCache 暫存網路圖片</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">利用 NSCache 暫存網路圖片</h1>
</header>
<section data-field="subtitle" class="p-summary">
開發 iOS App 時，我們時常從網路上抓圖，定義類似以下的抓圖 function。
</section>
<section data-field="body" class="e-content">
<section name="acb3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0ff4" id="0ff4" class="graf graf--h3 graf--leading graf--title">利用 NSCache 暫存網路圖片</h3><p name="4617" id="4617" class="graf graf--p graf-after--h3">開發 iOS App 時，我們時常從網路上抓圖，定義類似以下的抓圖 function。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f892" id="f892" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchImage</span>(<span class="hljs-params">url</span>: <span class="hljs-type">URL</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">UIImage</span>?) -&gt; <span class="hljs-type">Void</span>) {<br />        <br />        <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data, <br />               <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) {<br />                completionHandler(image)<br />            } <span class="hljs-keyword">else</span> {<br />                completionHandler(<span class="hljs-literal">nil</span>)<br />            }<br />        }.resume()<br />}</span></pre><p name="e4ff" id="e4ff" class="graf graf--p graf-after--pre">不過在遇到類似表格這樣顯示大量圖片的畫面時，卻可能遇到小小的問題。如下圖所示，當我們捲動表格時，它會從網路抓取圖片，不管之前是否抓過圖片。雖然 iOS 本身會幫我們做 cache，有可能不用重抓，但還是可能因為重新抓圖造成先顯示預設圖片，過一會才顯示抓到的圖片。</p></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="fd84" id="fd84" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--p" style="width: 50.523%;"><img class="graf-image" data-image-id="1*cKbq8UQav4vr8voEFP0MIA.jpeg" data-width="510" data-height="1056" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*cKbq8UQav4vr8voEFP0MIA.jpeg"></figure><figure name="5b52" id="5b52" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 49.477%;"><img class="graf-image" data-image-id="1*ujVFGRXr7DukCMoKZMsK8g.jpeg" data-width="504" data-height="1066" src="https://cdn-images-1.medium.com/max/600/1*ujVFGRXr7DukCMoKZMsK8g.jpeg"></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="b557" id="b557" class="graf graf--p graf-after--figure">若想讓使用者有最好的體驗，希望抓過的圖片能夠立即顯示，不要重抓，可以考慮使用 NSCache 儲存抓過的圖片。</p><div name="3a3c" id="3a3c" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/foundation/nscache" data-href="https://developer.apple.com/documentation/foundation/nscache" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/foundation/nscache"><strong class="markup--strong markup--mixtapeEmbed-strong">NSCache | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">A mutable collection you use to temporarily store transient key-value pairs that are subject to eviction when resources…</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/foundation/nscache" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="0c8d0aff8b90f3d9f8c6d6f42c38d0e4" data-thumbnail-img-id="0*P8RNgOfP4xxY7ZSX" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*P8RNgOfP4xxY7ZSX);"></a></div><p name="79ff" id="79ff" class="graf graf--p graf-after--mixtapeEmbed">接下來我們就以 NetworkController 為例，在裡面加上 NSCache 儲存抓過的圖片吧。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8402" id="8402" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkController</span> {<br />    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">NetworkController</span>()<br />    <br />    <span class="hljs-keyword">let</span> imageCache <span class="hljs-operator">=</span> <span class="hljs-type">NSCache</span>&lt;<span class="hljs-type">NSURL</span>, <span class="hljs-type">UIImage</span>&gt;()<br />    <br />    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchImage</span>(<span class="hljs-params">url</span>: <span class="hljs-type">URL</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">UIImage</span>?) -&gt; <span class="hljs-type">Void</span>) {<br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> imageCache.object(forKey: url <span class="hljs-keyword">as</span> <span class="hljs-type">NSURL</span>) {<br />            completionHandler(image)<br />            <span class="hljs-keyword">return</span><br />        }<br />        <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data, <br />               <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) {<br />                <span class="hljs-keyword">self</span>.imageCache.setObject(image, forKey: url <span class="hljs-keyword">as</span> <span class="hljs-type">NSURL</span>)<br />                completionHandler(image)<br />            } <span class="hljs-keyword">else</span> {<br />                completionHandler(<span class="hljs-literal">nil</span>)<br />            }<br />        }.resume()<br />    }<br />}</span></pre><p name="90f6" id="90f6" class="graf graf--p graf-after--pre">說明</p><ul class="postList"><li name="9777" id="9777" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">產生 NSCache 物件。</strong></li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="389d" id="389d" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> imageCache <span class="hljs-operator">=</span> <span class="hljs-type">NSCache</span>&lt;<span class="hljs-type">NSURL</span>, <span class="hljs-type">UIImage</span>&gt;()</span></pre><p name="4242" id="4242" class="graf graf--p graf-after--pre">NSCache 的用法跟 dictionary 類似，都是以 key 來找對應的 value。因此我們產生 NSCache 時，&lt;&gt; 裡須傳入 key &amp; value 的型別，在此我們以 NSURL 當 key 的型別，UIImage 當 value 的型別。</p><p name="f533" id="f533" class="graf graf--p graf-after--p">也許有人好奇，為何 key 的型別不用我們熟悉的 URL，而是用 NSURL 呢 ? 如下圖所示，使用 URL 時將產生錯誤。</p><figure name="084e" id="084e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hKIiPdb7BsgLksktniAttg.jpeg" data-width="1614" data-height="230" src="https://cdn-images-1.medium.com/max/800/1*hKIiPdb7BsgLksktniAttg.jpeg"></figure><p name="0bb5" id="0bb5" class="graf graf--p graf-after--figure">因為 NSCache 要求它的 key &amp; value 的型別都必須是物件，因此我們只能傳入 class 定義的型別，而 URL 是 struct，因此會產生錯誤。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="bbf1" id="bbf1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NSCache</span>&lt;<span class="hljs-title class_">KeyType</span>, <span class="hljs-title class_">ObjectType</span>&gt; : <span class="hljs-title class_">NSObject</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">KeyType</span> : <span class="hljs-title class_">AnyObject</span>, <span class="hljs-title class_">ObjectType</span> : <span class="hljs-title class_">AnyObject</span></span></pre><p name="d3c7" id="d3c7" class="graf graf--p graf-after--pre">那為什麼要用 NSCache，不用 dictionary 呢? 以 dictionary 儲存圖片不也可以實現類似的效果嗎 ?</p><p name="73a5" id="73a5" class="graf graf--p graf-after--p">的確 dictionary 也可以存圖，但當我們儲存大量圖片時，它也會有可怕的副作用，它會造成 App 使用大量的記憶體，可能讓 App 閃退。</p><p name="f754" id="f754" class="graf graf--p graf-after--p">相反的，NSCache 比較不會造成記憶體的問題，因為當系統記憶體不夠時，它會自動將東西從 cache 裡移除，而且我們也可以限制它可以儲存的東西數量，比方設定它的 countLimit。</p><div name="5092" id="5092" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/foundation/nscache/1416355-countlimit" data-href="https://developer.apple.com/documentation/foundation/nscache/1416355-countlimit" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/foundation/nscache/1416355-countlimit"><strong class="markup--strong markup--mixtapeEmbed-strong">countLimit | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">The maximum number of objects the cache should hold.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/foundation/nscache/1416355-countlimit" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="183f9740991281014c8ce8b22c0fd136" data-thumbnail-img-id="0*AgOiNq7THT0yDURG" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*AgOiNq7THT0yDURG);"></a></div><ul class="postList"><li name="c1bd" id="c1bd" class="graf graf--li graf-after--mixtapeEmbed"><strong class="markup--strong markup--li-strong">當 cache 有圖時，直接讀取 cache 裡的圖片。</strong></li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="f123" id="f123" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchImage</span>(<span class="hljs-params">url</span>: <span class="hljs-type">URL</span>, <span class="hljs-params">completionHandler</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">UIImage</span>?) -&gt; <span class="hljs-type">Void</span>) {<br />    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> imageCache.object(forKey: url <span class="hljs-keyword">as</span> <span class="hljs-type">NSURL</span>) {<br />        completionHandler(image)<br />        <span class="hljs-keyword">return</span><br />    }</span></pre><p name="4060" id="4060" class="graf graf--p graf-after--pre">由於我們通常將 JSON 解析後的網址存成 URL 型別，因此我們將 function fetchImage 的參數 url 宣告為 URL 型別，不過 NSCache 讀取內容的 function object(forKey:) 的參數型別卻是我們產生 imageCache 設定的 NSURL，所以在此我們要做型別的轉換，利用 as 轉成 NSURL。</p><ul class="postList"><li name="3c8b" id="3c8b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">從網路抓圖後，將圖片存入 cache。</strong></li></ul><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="2fd4" id="2fd4" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content"><span class="hljs-type">URLSession</span>.shared.dataTask(with: url) { data, response, error <span class="hljs-keyword">in</span><br />     <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data, <br />        <span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">UIImage</span>(data: data) {<br />          <span class="hljs-keyword">self</span>.imageCache.setObject(image, forKey: url <span class="hljs-keyword">as</span> <span class="hljs-type">NSURL</span>)<br />          completionHandler(image)<br />     } <span class="hljs-keyword">else</span> {<br />          completionHandler(<span class="hljs-literal">nil</span>)<br />     }<br />}.resume()</span></pre><p name="8392" id="8392" class="graf graf--p graf-after--pre">呼叫 NSCache 的 setObject(_:forKey:)，將圖片存入 cache。一樣的，我們要用 as 將型別轉成 NSURL。</p><h3 name="68a8" id="68a8" class="graf graf--h3 graf-after--p">當 App 進入背景 &amp; 重新啟動</h3><p name="207a" id="207a" class="graf graf--p graf-after--h3">當 App 進入背景或重新啟動時，圖片將需要重新抓取。因為當 App 進入背景時，NSCache 裡的內容會被移除。 而當 App 重新啟動時， NSCache 也會重新產生，不會有之前儲存的資料。</p><h3 name="eeb3" id="eeb3" class="graf graf--h3 graf-after--p">完整程式範例</h3><p name="b767" id="b767" class="graf graf--p graf-after--h3">有興趣的朋友可參考以下電影 App 的範例，搭配 NSCache 後，顯示過的電影圖片都能立即顯示，不會再重新抓圖。</p><figure name="b2ff" id="b2ff" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IDdZJiXBGF8fUuO4aBPb_w.jpeg" data-width="890" data-height="1546" src="https://cdn-images-1.medium.com/max/800/1*IDdZJiXBGF8fUuO4aBPb_w.jpeg"></figure><div name="6f83" id="6f83" class="graf graf--mixtapeEmbed graf-after--figure graf--trailing"><a href="https://github.com/AppPeterPan/CacheDemo" data-href="https://github.com/AppPeterPan/CacheDemo" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/AppPeterPan/CacheDemo"><strong class="markup--strong markup--mixtapeEmbed-strong">AppPeterPan/CacheDemo</strong><br><em class="markup--em markup--mixtapeEmbed-em">You can&#39;t perform that action at this time. You signed in with another tab or window. You signed out in another tab or…</em>github.com</a><a href="https://github.com/AppPeterPan/CacheDemo" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="e46b2da4acf810b806b2e8680d2547b2" data-thumbnail-img-id="0*HkFydpmC2PU5uWEY" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*HkFydpmC2PU5uWEY);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/70983260ceff"><time class="dt-published" datetime="2020-01-24T16:41:00.500Z">January 24, 2020</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E5%88%A9%E7%94%A8-nscache-%E6%9A%AB%E5%AD%98%E7%B6%B2%E8%B7%AF%E5%9C%96%E7%89%87-70983260ceff" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>