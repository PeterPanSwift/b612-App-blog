<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>運用 UIBezierPath 繪製各種形狀</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">運用 UIBezierPath 繪製各種形狀</h1>
</header>
<section data-field="subtitle" class="p-summary">
開發 iOS App 時，我們可以利用 UIBezierPath 繪製路徑，然後搭配 CAShapeLayer 做出任意形狀的 view。接下來我們先從基本的三角形開始，然後再一步步挑戰像是上弦月之類較為複雜的圖形吧。
</section>
<section data-field="body" class="e-content">
<section name="fa29" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a5dc" id="a5dc" class="graf graf--h3 graf--leading graf--title">運用 UIBezierPath 繪製各種形狀</h3><p name="d7a2" id="d7a2" class="graf graf--p graf-after--h3">開發 iOS App 時，我們可以利用 UIBezierPath 繪製路徑，然後搭配 CAShapeLayer 做出任意形狀的 view。接下來我們先從基本的三角形開始，然後再一步步挑戰像是上弦月之類較為複雜的圖形吧。</p><blockquote name="410c" id="410c" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">三角形</strong></blockquote><figure name="0572" id="0572" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*EDz2os3UMoqd3rYNoRRIqg.jpeg" data-width="386" data-height="218" src="https://cdn-images-1.medium.com/max/800/1*EDz2os3UMoqd3rYNoRRIqg.jpeg"></figure><p name="5aa8" id="5aa8" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">1 利用 UIBezierPath 繪製三角形的路徑。</strong></p><div name="ae97" id="ae97" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-uibezierpath-%E7%B9%AA%E8%A3%BD%E8%B7%AF%E7%B6%93%E7%9A%84%E5%8E%9F%E7%90%86-68a59908df56" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-uibezierpath-%E7%B9%AA%E8%A3%BD%E8%B7%AF%E7%B6%93%E7%9A%84%E5%8E%9F%E7%90%86-68a59908df56" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-uibezierpath-%E7%B9%AA%E8%A3%BD%E8%B7%AF%E7%B6%93%E7%9A%84%E5%8E%9F%E7%90%86-68a59908df56"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 UIBezierPath 繪製路經的原理</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 iOS App 時，我們可以利用 UIBezierPath 繪製路徑，然後搭配 CAShapeLayer 做出任意形狀的 view。接下來我們就以繪製三角形為例，一步步說明利用 UIBezierPath 繪製路經的原理。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-uibezierpath-%E7%B9%AA%E8%A3%BD%E8%B7%AF%E7%B6%93%E7%9A%84%E5%8E%9F%E7%90%86-68a59908df56" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bfce4af1407fe69f1a3122a7acfbf96b" data-thumbnail-img-id="1*gD0VJY2WMimNUky_XVO3Lg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*gD0VJY2WMimNUky_XVO3Lg.jpeg);"></a></div><p name="5516" id="5516" class="graf graf--p graf-after--mixtapeEmbed"><strong class="markup--strong markup--p-strong">2 生成三角形的 CAShapeLayer 。</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="36de" id="36de" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> triangleLayer <span class="hljs-operator">=</span> <span class="hljs-type">CAShapeLayer</span>()<br />triangleLayer.path <span class="hljs-operator">=</span> path.cgPath</span></pre><p name="58ca" id="58ca" class="graf graf--p graf-after--pre">CAShapeLayer 可繪製特定的形狀，我們透過它的 path 設定形狀。然而 triangleLayer.path 的型別是 CGPath，所以我們無法指定剛剛生成的 UIBezierPath ，而須利用 path.cgPath 讀取 CGPath 型別的三角形路徑後再存入 triangleLayer.path。</p><figure name="ba0f" id="ba0f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bYvpmdJ-HzgR5fFHMB9bqA.jpeg" data-width="1060" data-height="274" src="https://cdn-images-1.medium.com/max/800/1*bYvpmdJ-HzgR5fFHMB9bqA.jpeg"></figure><div name="360c" id="360c" class="graf graf--mixtapeEmbed graf-after--figure"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E%E5%9E%8B%E5%88%A5-a-%E7%9A%84%E6%9D%B1%E8%A5%BF%E5%BE%97%E5%88%B0%E5%9E%8B%E5%88%A5-b-%E7%9A%84%E6%9D%B1%E8%A5%BF-dc411f3844bf" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E%E5%9E%8B%E5%88%A5-a-%E7%9A%84%E6%9D%B1%E8%A5%BF%E5%BE%97%E5%88%B0%E5%9E%8B%E5%88%A5-b-%E7%9A%84%E6%9D%B1%E8%A5%BF-dc411f3844bf" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E%E5%9E%8B%E5%88%A5-a-%E7%9A%84%E6%9D%B1%E8%A5%BF%E5%BE%97%E5%88%B0%E5%9E%8B%E5%88%A5-b-%E7%9A%84%E6%9D%B1%E8%A5%BF-dc411f3844bf"><strong class="markup--strong markup--mixtapeEmbed-strong">從型別 A 的東西得到型別 B 的東西</strong><br><em class="markup--em markup--mixtapeEmbed-em">就像人跟鬼不能在一起，當我們在程式裡將東西儲存到變數時，東西的型別必須符合變數的型別，但時常我們手上的東西卻是另外一個型別，因此必須想盡辦法生出變數需要的東西。</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%BE%9E%E5%9E%8B%E5%88%A5-a-%E7%9A%84%E6%9D%B1%E8%A5%BF%E5%BE%97%E5%88%B0%E5%9E%8B%E5%88%A5-b-%E7%9A%84%E6%9D%B1%E8%A5%BF-dc411f3844bf" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bd841d4fd30d8907637fea714a35d986" data-thumbnail-img-id="1*h4rmEXIH4StDwapHyBF-Gw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*h4rmEXIH4StDwapHyBF-Gw.jpeg);"></a></div><p name="2b7a" id="2b7a" class="graf graf--p graf-after--mixtapeEmbed"><strong class="markup--strong markup--p-strong">3 生成 100 * 100 的紅色正方形 View。</strong></p><p name="5ae4" id="5ae4" class="graf graf--p graf-after--p">待會我們即將把它變成三角形。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9c4e" id="9c4e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<br /><span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> <span class="hljs-type">UIView</span>(frame: frame)<br />view.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>(red: <span class="hljs-number">1</span>, green: <span class="hljs-number">0</span>, blue: <span class="hljs-number">0</span>, alpha: <span class="hljs-number">1</span>)</span></pre><p name="3eac" id="3eac" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4 利用 CAShapeLayer 和 mask 將 view 變成三角形。</strong></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="9339" id="9339" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">view.layer.mask <span class="hljs-operator">=</span> triangleLayer</span></pre><p name="7365" id="7365" class="graf graf--p graf-after--pre">mask 中文是遮罩的意思，經由設定 CALayer 元件的 mask，我們將讓 view 只顯示 mask 裡非透明的區塊，其它部分被遮起來。在我們的例子，非透明的區塊即為剛剛 (0, 0)，(100, 0)，(100,100) 繪製的三角形。</p><figure name="2f78" id="2f78" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*srRthJg3UG2HJYCRIqmyxQ.jpeg" data-width="708" data-height="388" src="https://cdn-images-1.medium.com/max/800/1*srRthJg3UG2HJYCRIqmyxQ.jpeg"></figure><div name="c7cb" id="c7cb" class="graf graf--mixtapeEmbed graf-after--figure"><a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask" data-href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask"><strong class="markup--strong markup--mixtapeEmbed-strong">mask | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">An optional layer whose alpha channel is used to mask the layer&#39;s content.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="1d08882d793caf261571effbe74c6a65" data-thumbnail-img-id="0*Dwt--HwddcV4ppOr" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Dwt--HwddcV4ppOr);"></a></div><p name="845b" id="845b" class="graf graf--p graf-after--mixtapeEmbed">mask 的相關說明。</p><pre name="53e4" id="53e4" class="graf graf--pre graf-after--p">The layer’s alpha channel determines how much of the layer’s content and background shows through. Fully or partially opaque pixels allow the underlying content to show through but fully transparent pixels block that content.</pre><p name="a807" id="a807" class="graf graf--p graf-after--pre">如果從 view.layer.mask 看預覽，只會顯示 NSObject，因此我們還差最後一步。</p><figure name="e9c7" id="e9c7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0rLnmebDnotqU3sIwXnlHg.jpeg" data-width="786" data-height="318" src="https://cdn-images-1.medium.com/max/800/1*0rLnmebDnotqU3sIwXnlHg.jpeg"></figure><p name="846c" id="846c" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">5 從 view 看預覽。</strong></p><pre name="5683" id="5683" class="graf graf--pre graf-after--p">view</pre><p name="6d5d" id="6d5d" class="graf graf--p graf-after--pre">記得要從 view 才能看到它的模樣，從 layer 是看不到的，因此我們在最後一行輸入 view，查看 view 的模樣。</p><figure name="b594" id="b594" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*AqX9GUTmbvtMJYyieT90XA.jpeg" data-width="434" data-height="290" src="https://cdn-images-1.medium.com/max/800/1*AqX9GUTmbvtMJYyieT90XA.jpeg"></figure><p name="897c" id="897c" class="graf graf--p graf-after--figure">完整程式</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d91d" id="d91d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>()<br />path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>))<br />path.addLine(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">0</span>))<br />path.addLine(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">100</span>))<br />path.close()<br /><span class="hljs-keyword">let</span> triangleLayer <span class="hljs-operator">=</span> <span class="hljs-type">CAShapeLayer</span>()<br />triangleLayer.path <span class="hljs-operator">=</span> path.cgPath<br /><span class="hljs-keyword">let</span> frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<br /><span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> <span class="hljs-type">UIView</span>(frame: frame)<br />view.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>(red: <span class="hljs-number">1</span>, green: <span class="hljs-number">0</span>, blue: <span class="hljs-number">0</span>, alpha: <span class="hljs-number">1</span>)<br />view.layer.mask <span class="hljs-operator">=</span> triangleLayer<br />view</span></pre><p name="d22a" id="d22a" class="graf graf--p graf-after--pre">剛剛將 view 變成特定形狀的程式，基本上可分成以下三個步驟</p><ul class="postList"><li name="571c" id="571c" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">利用 UIBezierPath 繪製形狀的路徑。</strong></li><li name="8a23" id="8a23" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">產生 CAShapeLayer，透過 path 將它變成 UIBezierPath 繪製的形狀。</strong></li><li name="801e" id="801e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">產生 UIView，透過 mask 將它變成 CAShapeLayer 設定的形狀。</strong></li></ul><blockquote name="950c" id="950c" class="graf graf--blockquote graf-after--li"><strong class="markup--strong markup--blockquote-strong">小潘飛刀</strong></blockquote><p name="f486" id="f486" class="graf graf--p graf-after--blockquote">利用 UIBezierPath 的 addLine 畫線，我們已可將每一邊描繪出來，繪製出大部分的圖形，就算有一百邊也不是問題。比方以下彼得潘創作的小潘飛刀。(ps: 接下來的程式範例將只包含 UIBezierPath 生成路徑的段落，請記得最後要結合 CAShapeLayer 設為 mask。)</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="98a8" id="98a8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>()<br /><span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">20</span>)<br />path.move(to: point)<br />point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">0</span>)<br />path.addLine(to: point)<br />point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">100</span>)<br />path.addLine(to: point)<br />point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">75</span>, y: <span class="hljs-number">40</span>)<br />path.addLine(to: point)<br />path.close()</span></pre><figure name="eacc" id="eacc" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*IFBFXGF8swFx8bNLU9TsrQ.jpeg" data-width="394" data-height="240" src="https://cdn-images-1.medium.com/max/800/1*IFBFXGF8swFx8bNLU9TsrQ.jpeg"></figure><h3 name="770c" id="770c" class="graf graf--h3 graf-after--figure">運用 UIBezierPath 繪製其它形狀</h3><blockquote name="5fad" id="5fad" class="graf graf--blockquote graf-after--h3"><strong class="markup--strong markup--blockquote-strong">長方形</strong></blockquote><p name="51f5" id="51f5" class="graf graf--p graf-after--blockquote">若想繪製長方形，並不需要傻傻地用 UIBezierPath 的 addLine 畫四條線，因為建立 UIBezierPath 時即可傳入長方形的位置和大小。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="4a61" id="4a61" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(rect: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>, width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span>))</span></pre><blockquote name="1dc0" id="1dc0" class="graf graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">圓角的長方形</strong></blockquote><p name="aa5a" id="aa5a" class="graf graf--p graf-after--blockquote">利用 UIBezierPath 的 init(roundedRect:cornerRadius:) 繪製有圓角的長方形。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="e12f" id="e12f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(roundedRect: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>, width: <span class="hljs-number">80</span>, height: <span class="hljs-number">50</span>), cornerRadius: <span class="hljs-number">5</span>)</span></pre><figure name="2a53" id="2a53" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*Vy7JI670r2xxc6qDwQ_XuA.jpeg" data-width="218" data-height="136" src="https://cdn-images-1.medium.com/max/800/1*Vy7JI670r2xxc6qDwQ_XuA.jpeg"></figure><p name="543f" id="543f" class="graf graf--p graf-after--figure">如果不想四個頂點都有圓角，比方只有左下和右下有圓角，則可利用 UIBezierPath 的 init(roundedRect:byRoundingCorners:cornerRadii:)。</p><div name="ac16" id="ac16" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624368-init" data-href="https://developer.apple.com/documentation/uikit/uibezierpath/1624368-init" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/uikit/uibezierpath/1624368-init"><strong class="markup--strong markup--mixtapeEmbed-strong">init(roundedRect:byRoundingCorners:cornerRadii:) | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Creates and returns a new Bézier path object with a rectangular path rounded at the specified corners.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624368-init" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="cff29be7b2c34478126b8a70060765d5" data-thumbnail-img-id="0*OerIQN6tYEoIC4wx" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*OerIQN6tYEoIC4wx);"></a></div><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="c2c4" id="c2c4" class="graf graf--pre graf-after--mixtapeEmbed graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(roundedRect: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>, width: <span class="hljs-number">80</span>, height: <span class="hljs-number">50</span>), byRoundingCorners: [.bottomLeft, .bottomRight], cornerRadii: <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">5</span>, height: <span class="hljs-number">0</span>))</span></pre><p name="22a8" id="22a8" class="graf graf--p graf-after--pre">參數說明:</p><p name="7e48" id="7e48" class="graf graf--p graf-after--p">byRoundingCorners: 型別為 UIRectCorner，控制長方形圓角的位置。</p><div name="df90" id="df90" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/uikit/uirectcorner" data-href="https://developer.apple.com/documentation/uikit/uirectcorner" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/uikit/uirectcorner"><strong class="markup--strong markup--mixtapeEmbed-strong">UIRectCorner | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">The corners of a rectangle.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/uikit/uirectcorner" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="111815b2a67ddf3f66265ffb28dfa9f5" data-thumbnail-img-id="0*Bo6MvxGTB3tOCzDs" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Bo6MvxGTB3tOCzDs);"></a></div><p name="84bf" id="84bf" class="graf graf--p graf-after--mixtapeEmbed">cornerRadii: 控制圓角的程度，在此我們傳入的 CGSize 只要指定寬度即可，高度可設為 0。</p><figure name="5cf8" id="5cf8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Nka9ce9FyK1pc51rCPmhMw.jpeg" data-width="212" data-height="146" src="https://cdn-images-1.medium.com/max/800/1*Nka9ce9FyK1pc51rCPmhMw.jpeg"></figure><blockquote name="dacb" id="dacb" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">圓形</strong></blockquote><p name="1bcd" id="1bcd" class="graf graf--p graf-after--blockquote">利用 UIBezierPath 的 init(ovalIn:) 繪製橢圓，參數 ovalIn 的長方形決定橢圓的寬高。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8250" id="8250" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(ovalIn: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">10</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>))</span></pre><figure name="3f6d" id="3f6d" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*hoGtbch9-UYeeZdjiMmK9g.jpeg" data-width="240" data-height="134" src="https://cdn-images-1.medium.com/max/800/1*hoGtbch9-UYeeZdjiMmK9g.jpeg"></figure><p name="43a2" id="43a2" class="graf graf--p graf-after--figure">想繪製圓形也不是問題，只要參數 ovalIn 傳入正方形即可。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="6437" id="6437" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(ovalIn: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">10</span>, width: <span class="hljs-number">60</span>, height: <span class="hljs-number">60</span>))</span></pre><figure name="5afb" id="5afb" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*WZFqYwVTk84tRzFmQBr7Vw.jpeg" data-width="156" data-height="142" src="https://cdn-images-1.medium.com/max/800/1*WZFqYwVTk84tRzFmQBr7Vw.jpeg"></figure><p name="ac2c" id="ac2c" class="graf graf--p graf-after--figure">介紹完如何畫直線和圓形，接著來挑戰進階一點的主題吧，讓我們來繪製彎曲的曲線。</p><blockquote name="9887" id="9887" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">繪製剛好在圓上的圓弧</strong></blockquote><p name="b709" id="b709" class="graf graf--p graf-after--blockquote">利用 UIBezierPath 的 init(arcCenter:radius:startAngle:endAngle:clockwise:) 繪製圓弧。</p><div name="cfeb" id="cfeb" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624358-init" data-href="https://developer.apple.com/documentation/uikit/uibezierpath/1624358-init" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/uikit/uibezierpath/1624358-init"><strong class="markup--strong markup--mixtapeEmbed-strong">init(arcCenter:radius:startAngle:endAngle:clockwise:) | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Creates and returns a new Bézier path object with an arc of a circle.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624358-init" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fdbb4544565165458625cda09eb124f3" data-thumbnail-img-id="0*PFEu9SCu-AyoTmww" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*PFEu9SCu-AyoTmww);"></a></div><p name="d51e" id="d51e" class="graf graf--p graf-after--mixtapeEmbed">比方以下程式可畫出只能看不能吃的西瓜。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="b537" id="b537" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> aDegree <span class="hljs-operator">=</span> <span class="hljs-type">CGFloat</span>.pi <span class="hljs-operator">/</span> <span class="hljs-number">180</span><br /><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(arcCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">40</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">0</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">180</span>, clockwise: <span class="hljs-literal">true</span>)</span></pre><figure name="2e05" id="2e05" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*y7XqZ0H8rwEvcNldLMtV5A.jpeg" data-width="206" data-height="124" src="https://cdn-images-1.medium.com/max/800/1*y7XqZ0H8rwEvcNldLMtV5A.jpeg"></figure><p name="2e10" id="2e10" class="graf graf--p graf-after--figure">參數說明:</p><p name="140b" id="140b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">arcCenter: </strong>圓心座標。</p><p name="c46d" id="c46d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">radius: </strong>半徑。</p><p name="6abb" id="6abb" class="graf graf--p graf-after--p">startAngle &amp; endAngle: 圓弧開始和結束的角度。圓形有 360 度，如下圖所示，在程式裡我們以 2 pi 表示 360 度，1 pi 表示 180 度。</p><figure name="2eb6" id="2eb6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*p2XXv0zCfJxrUpWsRCD_Xg.jpeg" data-width="1140" data-height="670" src="https://cdn-images-1.medium.com/max/800/1*p2XXv0zCfJxrUpWsRCD_Xg.jpeg"></figure><p name="9793" id="9793" class="graf graf--p graf-after--figure">我們都知道 pi 是 3.1415926… ，可是我們只記得前面幾位，不記得後面的數字。沒關係，iOS SDK 已經幫我們定義好，透過 CGFloat.pi 即可取得。關於從型別 + . 讀取屬性的語法，相關說明可參考以下連結。</p><div name="b554" id="b554" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-ios-sdk-%E7%9A%84%E5%9E%8B%E5%88%A5%E5%B1%AC%E6%80%A7%E7%94%9F%E6%9D%B1%E8%A5%BF-a81cab56afc3" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-ios-sdk-%E7%9A%84%E5%9E%8B%E5%88%A5%E5%B1%AC%E6%80%A7%E7%94%9F%E6%9D%B1%E8%A5%BF-a81cab56afc3" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-ios-sdk-%E7%9A%84%E5%9E%8B%E5%88%A5%E5%B1%AC%E6%80%A7%E7%94%9F%E6%9D%B1%E8%A5%BF-a81cab56afc3"><strong class="markup--strong markup--mixtapeEmbed-strong">利用 iOS SDK 的型別屬性生東西</strong><br><em class="markup--em markup--mixtapeEmbed-em">開發 Swift iOS App 時，我們需要生出各種不同的東西幫我們實現不同的功能。大部分的時候，生東西的語法都是型別名稱 + ( )，比方 let view =…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E5%88%A9%E7%94%A8-ios-sdk-%E7%9A%84%E5%9E%8B%E5%88%A5%E5%B1%AC%E6%80%A7%E7%94%9F%E6%9D%B1%E8%A5%BF-a81cab56afc3" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7a98428655639b0ac5816ccd9201221e" data-thumbnail-img-id="1*u2BJE6uT9ke7UtwRuPiOIw.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*u2BJE6uT9ke7UtwRuPiOIw.jpeg);"></a></div><p name="0108" id="0108" class="graf graf--p graf-after--mixtapeEmbed">因此 1 度是 pi / 180，我們利用 <code class="markup--code markup--p-code">let aDegree = CGFloat.pi / 180</code> 算出一度的大小，存在常數 aDegree。而角度 0 度的位置在右邊，180 度在左邊。startAngle 傳入 aDegree * 0，endAngle 傳入 aDegree * 180時，表示從 0 度畫到 180 度。不過由於這個例子剛好整除，所以也可以簡化成傳入 0 &amp; CGFloat.pi。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0564" id="0564" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(arcCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">40</span>, startAngle: <span class="hljs-number">0</span>, endAngle: <span class="hljs-type">CGFloat</span>.pi, clockwise: <span class="hljs-literal">true</span>)</span></pre><p name="f9b3" id="f9b3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">clockwise: </strong>是否為順時針。畫圓時可以順時針，也可以逆時針。剛剛的例子， 參數 clockwise 傳入 true，因此我們順時針從 0 度畫到 180 度，產生西瓜形狀的下半圓。</p><p name="051a" id="051a" class="graf graf--p graf-after--p">其它例子:</p><p name="a6d8" id="a6d8" class="graf graf--p graf-after--p">逆時針從 10 度畫到 150 度。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="35d7" id="35d7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(arcCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">40</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">10</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">150</span>, clockwise: <span class="hljs-literal">false</span>)</span></pre><figure name="5d26" id="5d26" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*f12gug-wvxzGFNxoDKXCjQ.jpeg" data-width="202" data-height="152" src="https://cdn-images-1.medium.com/max/800/1*f12gug-wvxzGFNxoDKXCjQ.jpeg"></figure><p name="ed68" id="ed68" class="graf graf--p graf-after--figure">值得注意的，剛剛方法繪製的形狀填滿顏色時將以圓弧和圓弧兩端點連線包含的區塊，若想畫出從圓心連到圓弧兩端點的扇形，則須先用 move 移動到圓心，然後再呼叫 addArc(withCenter:radius:startAngle:endAngle:clockwise:) 加入圓弧，例如以下例子:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="0ba4" id="0ba4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>()<br />path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>))<br />path.addArc(withCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">40</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">10</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">150</span>, clockwise: <span class="hljs-literal">false</span>)</span></pre><figure name="a4e9" id="a4e9" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*hR1hG-EDdljImP95C0iSmg.jpeg" data-width="258" data-height="158" src="https://cdn-images-1.medium.com/max/800/1*hR1hG-EDdljImP95C0iSmg.jpeg"></figure><p name="1091" id="1091" class="graf graf--p graf-after--figure">其它例子:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="d5ab" id="d5ab" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// 畫出比較大的外圓弧，從 (0, 50) 到 (100, 50)</span><br /><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(arcCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">50</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">180</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">0</span>, clockwise: <span class="hljs-literal">true</span>)<br /><span class="hljs-comment">// 畫出右下方的橫線，從 (100, 50) 連到 (75, 50)</span><br />path.addLine(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">75</span>, y: <span class="hljs-number">50</span>))<br /><span class="hljs-comment">// 畫出比較小的內圓弧，從 (75, 50) 到 (25, 50)</span><br />path.addArc(withCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">25</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">0</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">180</span>, clockwise: <span class="hljs-literal">false</span>)<br />path.close()</span></pre><figure name="e8c8" id="e8c8" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*mWpDu1S6gjHV4hhYQMCBwA.jpeg" data-width="420" data-height="272" src="https://cdn-images-1.medium.com/max/800/1*mWpDu1S6gjHV4hhYQMCBwA.jpeg"></figure><blockquote name="1f6a" id="1f6a" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">繪製特別的曲線</strong></blockquote><p name="df8f" id="df8f" class="graf graf--p graf-after--blockquote">剛剛介紹的方法，只能畫出剛好在圓上的圓弧，但若想畫出特別弧度的曲線，則須運用以下兩個方法，addQuadCurve &amp; addQuadCurve。</p><div name="c81d" id="c81d" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624351-addquadcurve" data-href="https://developer.apple.com/documentation/uikit/uibezierpath/1624351-addquadcurve" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/uikit/uibezierpath/1624351-addquadcurve"><strong class="markup--strong markup--mixtapeEmbed-strong">addQuadCurve(to:controlPoint:) | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Appends a quadratic Bézier curve to the path.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624351-addquadcurve" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="779985fa54b256016cd9785a9254f549" data-thumbnail-img-id="0*32-kP8eR6TDym_OI" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*32-kP8eR6TDym_OI);"></a></div><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="8e80" id="8e80" class="graf graf--pre graf-after--mixtapeEmbed graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(arcCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">50</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">270</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">90</span>, clockwise: <span class="hljs-literal">true</span>)<br />path.addQuadCurve(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">0</span>), controlPoint: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">80</span>, y: <span class="hljs-number">50</span>))</span></pre><figure name="29f9" id="29f9" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*xvgnsLhmDzNaB9qUr7BJ3g.jpeg" data-width="420" data-height="286" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*xvgnsLhmDzNaB9qUr7BJ3g.jpeg"></figure><p name="1658" id="1658" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">UIBezierPath(arcCenter: CGPoint(x: 50, y: 50), radius: 50, startAngle: aDegree * 270, endAngle: aDegree * 90, clockwise: true)</code> 將從 (50, 0) 到 (50, 100) 畫出圓弧，接著呼叫 addQuadCurve 時，利用參數 controlPoint 控制從 (50, 100) 到 (50, 0) 的曲線弧度，即可畫出可愛的上弦月。</p><p name="6309" id="6309" class="graf graf--p graf-after--p">如下圖所示，controlPoint 控制曲線的弧度。剛剛 <code class="markup--code markup--p-code">addQuadCurve(to: CGPoint(x: 50, y: 0), controlPoint: CGPoint(x: 80, y: 50))</code> 的參數 to 對應下圖的 C 點，controlPoint 對應 B 點，那麼 A 點呢 ? A 點是在呼叫 addQuadCurve 前畫到的位置，因此是從 (50, 100) 開始。</p><figure name="a8df" id="a8df" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*eEb8Kgmw5Ya3yXNoek3aaw.jpeg" data-width="1190" data-height="504" src="https://cdn-images-1.medium.com/max/800/1*eEb8Kgmw5Ya3yXNoek3aaw.jpeg"></figure><p name="5c1a" id="5c1a" class="graf graf--p graf-after--figure">以下為 controlPoint 改成 (20,50) &amp; (120, 50) 的例子。</p></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="bd66" id="bd66" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--p" style="width: 51.26%;"><img class="graf-image" data-image-id="1*3dG8NAusE33DTzTIkLEPng.jpeg" data-width="322" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*3dG8NAusE33DTzTIkLEPng.jpeg"></figure><figure name="1527" id="1527" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 48.74%;"><img class="graf-image" data-image-id="1*mCZFyRG4Mk_zLwKBTzI1Lw.jpeg" data-width="312" data-height="218" src="https://cdn-images-1.medium.com/max/600/1*mCZFyRG4Mk_zLwKBTzI1Lw.jpeg"><figcaption class="imageCaption" style="width: 205.17%; left: -105.17%;">左邊是 (20,50)，右邊是 (120,50)</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><div name="ed59" id="ed59" class="graf graf--mixtapeEmbed graf-after--figure"><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624357-addcurve" data-href="https://developer.apple.com/documentation/uikit/uibezierpath/1624357-addcurve" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/uikit/uibezierpath/1624357-addcurve"><strong class="markup--strong markup--mixtapeEmbed-strong">addCurve(to:controlPoint1:controlPoint2:) | Apple Developer Documentation</strong><br><em class="markup--em markup--mixtapeEmbed-em">Appends a cubic Bézier curve to the path.</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/uikit/uibezierpath/1624357-addcurve" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="744cc121af76bf7ccf978f95044d952d" data-thumbnail-img-id="0*zMXsBHVqU-eznT4s" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*zMXsBHVqU-eznT4s);"></a></div><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="dda6" id="dda6" class="graf graf--pre graf-after--mixtapeEmbed graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(arcCenter: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>), radius: <span class="hljs-number">50</span>, startAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">180</span>, endAngle: aDegree <span class="hljs-operator">*</span> <span class="hljs-number">0</span>, clockwise: <span class="hljs-literal">true</span>)<br />path.addCurve(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">50</span>), controlPoint1: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">80</span>), controlPoint2: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">20</span>))</span></pre><p name="5be7" id="5be7" class="graf graf--p graf-after--pre">比剛剛複雜一點， addCurve(to:controlPoint1:controlPoint2:) 的控制點有兩個，利用 controlPoint1 &amp; controlPoint2 控制從 (100, 50) 到 (0, 50) 的曲線弧度。</p><figure name="34d1" id="34d1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*M2SqTd1YvtcYxuYhT-tamQ.jpeg" data-width="438" data-height="288" src="https://cdn-images-1.medium.com/max/800/1*M2SqTd1YvtcYxuYhT-tamQ.jpeg"></figure><p name="97b1" id="97b1" class="graf graf--p graf-after--figure">關於曲線繪製的更多說明，也可以參考 Jaba 同學的文章。</p><div name="cb24" id="cb24" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%95%AB%E5%87%BA%E5%99%97%E6%B5%AA%E5%BD%A9%E8%99%B9%E6%97%97-uibezierpath%E7%B9%AA%E5%9C%96%E7%B7%B4%E7%BF%92-9061fe131ce1" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%95%AB%E5%87%BA%E5%99%97%E6%B5%AA%E5%BD%A9%E8%99%B9%E6%97%97-uibezierpath%E7%B9%AA%E5%9C%96%E7%B7%B4%E7%BF%92-9061fe131ce1" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%95%AB%E5%87%BA%E5%99%97%E6%B5%AA%E5%BD%A9%E8%99%B9%E6%97%97-uibezierpath%E7%B9%AA%E5%9C%96%E7%B7%B4%E7%BF%92-9061fe131ce1"><strong class="markup--strong markup--mixtapeEmbed-strong">用程式畫出噗浪彩虹旗─UIBezierPath繪圖練習</strong><br><em class="markup--em markup--mixtapeEmbed-em">◆作業5–2：運用 UIBezierPath 繪製國旗＆各種形狀圖案◆</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E6%95%99%E5%AE%A4/%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%95%AB%E5%87%BA%E5%99%97%E6%B5%AA%E5%BD%A9%E8%99%B9%E6%97%97-uibezierpath%E7%B9%AA%E5%9C%96%E7%B7%B4%E7%BF%92-9061fe131ce1" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4ac3db1068143444ebe68a991b18b8b0" data-thumbnail-img-id="1*nwarKZPXVhjfZ7m6cEtdAg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*nwarKZPXVhjfZ7m6cEtdAg.png);"></a></div><blockquote name="82fe" id="82fe" class="graf graf--blockquote graf-after--mixtapeEmbed"><strong class="markup--strong markup--blockquote-strong">組合路徑</strong></blockquote><p name="ba35" id="ba35" class="graf graf--p graf-after--blockquote">剛剛介紹的都是單一路徑，其實我們也可將多個路徑結合，例如以下同時顯示圓形跟三角形的例子。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="19d2" id="19d2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> trianglePath <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>()<br /><span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>)<br />trianglePath.move(to: point)<br />point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">0</span>)<br />trianglePath.addLine(to: point)<br />point <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">100</span>)<br />trianglePath.addLine(to: point)<br />trianglePath.close()<br /><span class="hljs-keyword">let</span> rect <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">40</span>, width: <span class="hljs-number">40</span>, height: <span class="hljs-number">40</span>)<br /><span class="hljs-keyword">let</span> circlePath <span class="hljs-operator">=</span> <span class="hljs-type">UIBezierPath</span>(roundedRect: rect, cornerRadius: <span class="hljs-number">20</span>)<br />trianglePath.append(circlePath)</span></pre><figure name="a158" id="a158" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*JdWm4pljhHRCzubMntyadA.jpeg" data-width="364" data-height="256" src="https://cdn-images-1.medium.com/max/800/1*JdWm4pljhHRCzubMntyadA.jpeg"></figure><p name="4376" id="4376" class="graf graf--p graf-after--figure">說明:</p><p name="c2b2" id="c2b2" class="graf graf--p graf-after--p">結合多個路徑繪製的形狀。</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="swift" name="85d0" id="85d0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">trianglePath.append(circlePath)</span></pre><p name="d73c" id="d73c" class="graf graf--p graf-after--pre graf--trailing">我們可將多個 UIBezierPath 結合，透過 append 加入另一個 UIBezierPath。</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/3c858e194676"><time class="dt-published" datetime="2018-11-04T18:14:43.286Z">November 4, 2018</time></a>.</p><p><a href="https://medium.com/@apppeterpan/%E9%81%8B%E7%94%A8-uibezierpath-%E7%B9%AA%E8%A3%BD%E5%BD%A2-3c858e194676" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>