<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift closure 何時執行和執行的次數</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift closure 何時執行和執行的次數</h1>
</header>
<section data-field="subtitle" class="p-summary">
開發 iOS App 時，我們時常在呼叫 API 時傳入 closure，不過 closure 的執行卻有許多不同的變化，影響程式執行的順序和結果，常讓初學者不知所措。
</section>
<section data-field="body" class="e-content">
<section name="5085" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bff8" id="bff8" class="graf graf--h3 graf--leading graf--title">Swift closure 何時執行和執行的次數</h3><p name="e6a7" id="e6a7" class="graf graf--p graf-after--h3">開發 iOS App 時，我們時常在呼叫 API 時傳入 closure，不過 closure 的執行卻有許多不同的變化，影響程式執行的順序和結果，常讓初學者不知所措。</p><p name="d3f8" id="d3f8" class="graf graf--p graf-after--p">為了搞懂 closure， 接下來就讓我們好好認識 closure 何時執行跟它執行的次數 。</p><h3 name="6cef" id="6cef" class="graf graf--h3 graf-after--p">closure 何時執行</h3><p name="b229" id="b229" class="graf graf--p graf-after--h3">closure 的執行可分為 synchronously &amp; asynchronously 兩種。</p><ul class="postList"><li name="9484" id="9484" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">在 function 結束前執行的 synchronously (immediately)</strong></li></ul><pre name="520c" id="520c" class="graf graf--pre graf-after--li">let lyrics = [&quot;明天以後&quot;, &quot;若再次相遇在某個街頭&quot;, &quot;不要問我&quot;, &quot;當初離開你是什麼理由&quot;]<br>lyrics.forEach <strong class="markup--strong markup--pre-strong">{ (sentence) in<br>    for _ in 1...100000 {<br>        _ = Int.random(in: 1...1000)<br>    }<br>    print(Date(), sentence)<br>}</strong><br>print(Date(), &quot;after forEach&quot;)</pre><p name="564f" id="564f" class="graf graf--p graf-after--pre">我們傳入 forEach 的參數 body 將在 forEach 結束前執行，因此 array 的四句歌詞都印出後才印出 after forEach。(ps: 為了讓效果更明顯，我們故意利用亂數 100000 次的迴圈增加 closure 執行的時間。)</p><pre name="ca3f" id="ca3f" class="graf graf--pre graf-after--p">func forEach(_ body: (String) throws -&gt; Void) rethrows</pre><figure name="d27e" id="d27e" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*ez6UzENA9VBMGAYaLYrhDg.jpeg" data-width="1222" data-height="430" src="https://cdn-images-1.medium.com/max/800/1*ez6UzENA9VBMGAYaLYrhDg.jpeg"></figure><ul class="postList"><li name="90f4" id="90f4" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">function 結束後才執行的 asynchronously (sometime later)</strong></li></ul><pre name="5e46" id="5e46" class="graf graf--pre graf-after--li">Timer.scheduledTimer(withTimeInterval: 3, repeats: false) { (timer) in<br>    print(timer.fireDate, &quot;明天以後 若再次相遇在某個街頭&quot;)<br>}<br>print(Date(), &quot;after scheduledTimer&quot;)</pre><p name="23bb" id="23bb" class="graf graf--p graf-after--pre">我們傳入 scheduledTimer 的參數 block 將在 scheduledTimer 結束之後才執行，因此 <code class="markup--code markup--p-code">after scheduledTimer</code> 先印出，過一會才印出 <code class="markup--code markup--p-code">明天以後</code>。</p><pre name="0086" id="0086" class="graf graf--pre graf-after--p">class func scheduledTimer(withTimeInterval interval: TimeInterval, repeats: Bool, block: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Timer) -&gt; Void) -&gt; Timer</pre><figure name="1963" id="1963" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*t6-Ls2DyWjWVbg0ASs9YAQ.jpeg" data-width="1396" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*t6-Ls2DyWjWVbg0ASs9YAQ.jpeg"></figure><p name="0a57" id="0a57" class="graf graf--p graf-after--figure">要如何判斷 closure 是否會在 function 結束後才執行呢 ? 通常要從 API 文件查詢 function 的說明才會知道，比方從 <code class="markup--code markup--p-code">scheduledTimer(withTimeInterval:repeats:block:)</code> 的文件了解參數 block 是 timer 定時觸發的程式，所以它將在 scheduledTimer 結束之後才執行。</p><div name="80eb" id="80eb" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://developer.apple.com/documentation/foundation/timer/2091889-scheduledtimer" data-href="https://developer.apple.com/documentation/foundation/timer/2091889-scheduledtimer" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/foundation/timer/2091889-scheduledtimer"><strong class="markup--strong markup--mixtapeEmbed-strong">scheduledTimer(withTimeInterval:repeats:block:)</strong><br><em class="markup--em markup--mixtapeEmbed-em">Declaration The number of seconds between firings of the timer. If is less than or equal to , this method chooses the…</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/foundation/timer/2091889-scheduledtimer" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="c7adce1fe39e831a4a594bf4e15452e2"></a></div><p name="fc4d" id="fc4d" class="graf graf--p graf-after--mixtapeEmbed">懶得看文件嗎 ? 沒關係，其實有個簡單的方法能幫我們判斷:</p><p name="69a8" id="69a8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1 當 function 型別的參數沒有 @escaping，而且不是 optional 時</strong></p><p name="79eb" id="79eb" class="graf graf--p graf-after--p">若 closure 會執行它將在 function 結束前執行。</p><p name="6a1f" id="6a1f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2 當 function 型別的參數有 @escaping 或是 optional</strong></p><p name="b736" id="b736" class="graf graf--p graf-after--p">closure 有很大可能在 function 結束後才執行。</p><figure name="c586" id="c586" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*W2Y5nR97rq1aeWFuGNa74Q.jpeg" data-width="1352" data-height="904" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*W2Y5nR97rq1aeWFuGNa74Q.jpeg"></figure><p name="8ba0" id="8ba0" class="graf graf--p graf-after--figure">關於 @escaping 的說明可參考以下連結。</p><div name="ef96" id="ef96" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%AE%93-closure-%E5%9C%A8-function-%E5%A4%96%E7%B9%BC%E7%BA%8C%E4%BD%BF%E7%94%A8%E7%9A%84-escaping-40d50b17f75b" data-href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%AE%93-closure-%E5%9C%A8-function-%E5%A4%96%E7%B9%BC%E7%BA%8C%E4%BD%BF%E7%94%A8%E7%9A%84-escaping-40d50b17f75b" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%AE%93-closure-%E5%9C%A8-function-%E5%A4%96%E7%B9%BC%E7%BA%8C%E4%BD%BF%E7%94%A8%E7%9A%84-escaping-40d50b17f75b"><strong class="markup--strong markup--mixtapeEmbed-strong">讓 closure 在 function 外繼續使用的 @escaping</strong><br><em class="markup--em markup--mixtapeEmbed-em">@escaping 是個讓 closure 在 function 外繼續使用的特別語法。它有點難懂，但你卻不能忽略，因為 iOS SDK 裡不少 function 的參數都加了…</em>medium.com</a><a href="https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%AE%93-closure-%E5%9C%A8-function-%E5%A4%96%E7%B9%BC%E7%BA%8C%E4%BD%BF%E7%94%A8%E7%9A%84-escaping-40d50b17f75b" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="d50ef5942aff583b42da27281a507bee" data-thumbnail-img-id="1*QnkVr6acfggHlR9EaoinQA.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*QnkVr6acfggHlR9EaoinQA.jpeg);"></a></div><p name="15c6" id="15c6" class="graf graf--p graf-after--mixtapeEmbed">因此除了剛剛的 timer 例子，以下的 closure 也會在 function 結束後才執行。</p><p name="167b" id="167b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1 網路抓資料</strong></p><p name="b969" id="b969" class="graf graf--p graf-after--p">completionHandler 型別有 @escaping，因此推測 closure 將在 function dataTask 結束後才執行。</p><pre name="bac1" id="bac1" class="graf graf--pre graf-after--p">func dataTask(with url: URL, completionHandler: <a href="http://twitter.com/escaping" data-href="http://twitter.com/escaping" class="markup--anchor markup--pre-anchor" title="Twitter profile for @escaping" rel="noopener" target="_blank">@escaping</a> (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask</pre><p name="fa8f" id="fa8f" class="graf graf--p graf-after--pre">程式</p><pre name="d97a" id="d97a" class="graf graf--pre graf-after--p">let url = URL(string: &quot;<a href="https://itunes.apple.com/search?term=swift&amp;media=music" data-href="https://itunes.apple.com/search?term=swift&amp;media=music" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://itunes.apple.com/search?term=swift&amp;media=music</a>&quot;)!<br>URLSession.shared.dataTask(with: url) <strong class="markup--strong markup--pre-strong">{ (data, response, error) in<br>    for _ in 1...100000 {<br>        _ = Int.random(in: 1...1000)<br>    }<br>    print(Date(), &quot;execute closure&quot;)<br>}</strong>.resume()<br>print(Date(), &quot;after dataTask&quot;)</pre><figure name="5136" id="5136" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*7IYUekOwcwzDWyjOu3_HtQ.jpeg" data-width="1164" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*7IYUekOwcwzDWyjOu3_HtQ.jpeg"></figure><p name="1759" id="1759" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">2 顯示 controller</strong></p><p name="8293" id="8293" class="graf graf--p graf-after--p">completion 型別是 optional，因此推測 closure 將在 function present 結束後才執行。</p><pre name="64b7" id="64b7" class="graf graf--pre graf-after--p">func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -&gt; Void)? = nil)</pre><p name="8586" id="8586" class="graf graf--p graf-after--pre">程式</p><pre name="c08c" id="c08c" class="graf graf--pre graf-after--p">let controller = UIViewController()<br>present(controller, animated: true)<strong class="markup--strong markup--pre-strong"> {<br>     for _ in 1...100000 {<br>         _ = Int.random(in: 1...1000)<br>     }<br>     controller.view.backgroundColor = UIColor.yellow<br>     print(Date(), &quot;execute closure&quot;)<br>            <br>}</strong><br> print(Date(), &quot;after present&quot;)</pre><figure name="6ee4" id="6ee4" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*rt3znSqr2zn4ehqXNXZEvg.jpeg" data-width="1144" data-height="136" src="https://cdn-images-1.medium.com/max/800/1*rt3znSqr2zn4ehqXNXZEvg.jpeg"></figure><h3 name="95a1" id="95a1" class="graf graf--h3 graf-after--figure">closure 執行的次數</h3><p name="f469" id="f469" class="graf graf--p graf-after--h3">了解 closure 何時執行後，接著讓我們聊聊 closure 執行的次數。它可以執行一次，也可以執行多次，甚至要完全不執行也行。就像我們談戀愛一樣，我們可以交一個女朋友，也可以交很多女朋友，或是決定專心寫 App，沒有女朋友也行。</p><ul class="postList"><li name="9744" id="9744" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">執行一次的 closure</strong></li></ul><p name="2554" id="2554" class="graf graf--p graf-after--li">傳入 present 的 closure 將在 controller 畫面顯示後執行一次。</p><pre name="4984" id="4984" class="graf graf--pre graf-after--p">let controller = UIViewController()<br>present(controller, animated: true) <strong class="markup--strong markup--pre-strong">{<br>     for _ in 1...100000 {<br>            _ = Int.random(in: 1...1000)<br>     }<br>     controller.view.backgroundColor = UIColor.yellow<br>     print(Date(), &quot;execute closure&quot;)<br>            <br>}</strong><br> print(Date(), &quot;after present&quot;)</pre><ul class="postList"><li name="c6c2" id="c6c2" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">執行多次的 closure</strong></li></ul><p name="2a17" id="2a17" class="graf graf--p graf-after--li">array lyrics 儲存 Penny 明天以後的四句歌詞，所以傳入 forEach 的 closure 將執行四次。</p><pre name="ad8b" id="ad8b" class="graf graf--pre graf-after--p">let lyrics = [&quot;明天以後&quot;, &quot;若再次相遇在某個街頭&quot;, &quot;不要問我&quot;, &quot;當初離開你是什麼理由&quot;]<br>lyrics.forEach <strong class="markup--strong markup--pre-strong">{ (sentence) in<br>    for _ in 1...100000 {<br>           _ = Int.random(in: 1...1000)<br>    }<br>    print(Date(), sentence)<br>}</strong><br>print(Date(), &quot;after forEach&quot;)</pre><ul class="postList"><li name="339e" id="339e" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">沒有執行的 closure</strong></li></ul><p name="fe84" id="fe84" class="graf graf--p graf-after--li">array girlFriends 沒有女朋友，所以令人心碎地，傳入 forEach 的 closure 一次都沒有執行。</p><pre name="1e4d" id="1e4d" class="graf graf--pre graf-after--p">let girlFriends = [String]()<br>girlFriends.forEach<strong class="markup--strong markup--pre-strong"> { (girlFriend) in<br>    for _ in 1...100000 {<br>          _ = Int.random(in: 1...1000)<br>    }<br>    print(Date(), girlFriend)<br>}</strong><br>print(Date(), &quot;after forEach&quot;)</pre><figure name="fc64" id="fc64" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*848B-dsWNzr7LuQ78SgR7w.jpeg" data-width="1112" data-height="174" src="https://cdn-images-1.medium.com/max/800/1*848B-dsWNzr7LuQ78SgR7w.jpeg"></figure><h3 name="6603" id="6603" class="graf graf--h3 graf-after--figure">參考連結</h3><div name="8f90" id="8f90" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://developer.apple.com/documentation/swift/preventing_timing_problems_when_using_closures" data-href="https://developer.apple.com/documentation/swift/preventing_timing_problems_when_using_closures" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.apple.com/documentation/swift/preventing_timing_problems_when_using_closures"><strong class="markup--strong markup--mixtapeEmbed-strong">Preventing Timing Problems When Using Closures</strong><br><em class="markup--em markup--mixtapeEmbed-em">Many of the APIs you use in Swift take a closure-or a function passed as an instance-as a parameter. Because closures…</em>developer.apple.com</a><a href="https://developer.apple.com/documentation/swift/preventing_timing_problems_when_using_closures" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="df2078da19c969abda06c9da83a2fdda"></a></div><figure name="6b09" id="6b09" class="graf graf--figure graf--iframe graf-after--mixtapeEmbed graf--trailing"><iframe src="https://www.youtube.com/embed/tyso1q7t5V8?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@apppeterpan" class="p-author h-card">彼得潘的 iOS App Neverland</a> on <a href="https://medium.com/p/ae48c7931159"><time class="dt-published" datetime="2020-04-26T13:37:59.793Z">April 26, 2020</time></a>.</p><p><a href="https://medium.com/@apppeterpan/swift-closure-%E4%BD%95%E6%99%82%E5%9F%B7%E8%A1%8C%E5%92%8C%E5%9F%B7%E8%A1%8C%E7%9A%84%E6%AC%A1%E6%95%B8-ae48c7931159" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 16, 2025.</p></footer></article></body></html>